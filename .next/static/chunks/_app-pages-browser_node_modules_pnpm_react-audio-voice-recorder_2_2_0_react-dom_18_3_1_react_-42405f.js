"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_pnpm_react-audio-voice-recorder_2_2_0_react-dom_18_3_1_react_-42405f"],{

/***/ "(app-pages-browser)/./node_modules/.pnpm/react-audio-voice-recorder@2.2.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-audio-voice-recorder/dist/react-audio-visualize.es-69216c73.js":
/*!*******************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-audio-voice-recorder@2.2.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-audio-voice-recorder/dist/react-audio-visualize.es-69216c73.js ***!
  \*******************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioVisualizer: function() { return /* binding */ br; },\n/* harmony export */   LiveAudioVisualizer: function() { return /* binding */ Sr; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.3_@opentelemetry+api@1.9.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/index.js\");\n\nvar ne = { exports: {} }, z = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar je;\nfunction dr() {\n  if (je)\n    return z;\n  je = 1;\n  var y = react__WEBPACK_IMPORTED_MODULE_0__, m = Symbol.for(\"react.element\"), _ = Symbol.for(\"react.fragment\"), b = Object.prototype.hasOwnProperty, h = y.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, w = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function k(i, s, g) {\n    var o, a = {}, d = null, E = null;\n    g !== void 0 && (d = \"\" + g), s.key !== void 0 && (d = \"\" + s.key), s.ref !== void 0 && (E = s.ref);\n    for (o in s)\n      b.call(s, o) && !w.hasOwnProperty(o) && (a[o] = s[o]);\n    if (i && i.defaultProps)\n      for (o in s = i.defaultProps, s)\n        a[o] === void 0 && (a[o] = s[o]);\n    return { $$typeof: m, type: i, key: d, ref: E, props: a, _owner: h.current };\n  }\n  return z.Fragment = _, z.jsx = k, z.jsxs = k, z;\n}\nvar q = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Pe;\nfunction mr() {\n  return Pe || (Pe = 1,  true && function() {\n    var y = react__WEBPACK_IMPORTED_MODULE_0__, m = Symbol.for(\"react.element\"), _ = Symbol.for(\"react.portal\"), b = Symbol.for(\"react.fragment\"), h = Symbol.for(\"react.strict_mode\"), w = Symbol.for(\"react.profiler\"), k = Symbol.for(\"react.provider\"), i = Symbol.for(\"react.context\"), s = Symbol.for(\"react.forward_ref\"), g = Symbol.for(\"react.suspense\"), o = Symbol.for(\"react.suspense_list\"), a = Symbol.for(\"react.memo\"), d = Symbol.for(\"react.lazy\"), E = Symbol.for(\"react.offscreen\"), C = Symbol.iterator, T = \"@@iterator\";\n    function D(e) {\n      if (e === null || typeof e != \"object\")\n        return null;\n      var r = C && e[C] || e[T];\n      return typeof r == \"function\" ? r : null;\n    }\n    var l = y.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function f(e) {\n      {\n        for (var r = arguments.length, t = new Array(r > 1 ? r - 1 : 0), n = 1; n < r; n++)\n          t[n - 1] = arguments[n];\n        j(\"error\", e, t);\n      }\n    }\n    function j(e, r, t) {\n      {\n        var n = l.ReactDebugCurrentFrame, p = n.getStackAddendum();\n        p !== \"\" && (r += \"%s\", t = t.concat([p]));\n        var v = t.map(function(u) {\n          return String(u);\n        });\n        v.unshift(\"Warning: \" + r), Function.prototype.apply.call(console[e], console, v);\n      }\n    }\n    var xe = !1, Fe = !1, Ne = !1, Ae = !1, Ie = !1, oe;\n    oe = Symbol.for(\"react.module.reference\");\n    function Le(e) {\n      return !!(typeof e == \"string\" || typeof e == \"function\" || e === b || e === w || Ie || e === h || e === g || e === o || Ae || e === E || xe || Fe || Ne || typeof e == \"object\" && e !== null && (e.$$typeof === d || e.$$typeof === a || e.$$typeof === k || e.$$typeof === i || e.$$typeof === s || // This needs to include all possible module reference object\n      // types supported by any Flight configuration anywhere since\n      // we don't know which Flight build this will end up being used\n      // with.\n      e.$$typeof === oe || e.getModuleId !== void 0));\n    }\n    function ze(e, r, t) {\n      var n = e.displayName;\n      if (n)\n        return n;\n      var p = r.displayName || r.name || \"\";\n      return p !== \"\" ? t + \"(\" + p + \")\" : t;\n    }\n    function ae(e) {\n      return e.displayName || \"Context\";\n    }\n    function $(e) {\n      if (e == null)\n        return null;\n      if (typeof e.tag == \"number\" && f(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof e == \"function\")\n        return e.displayName || e.name || null;\n      if (typeof e == \"string\")\n        return e;\n      switch (e) {\n        case b:\n          return \"Fragment\";\n        case _:\n          return \"Portal\";\n        case w:\n          return \"Profiler\";\n        case h:\n          return \"StrictMode\";\n        case g:\n          return \"Suspense\";\n        case o:\n          return \"SuspenseList\";\n      }\n      if (typeof e == \"object\")\n        switch (e.$$typeof) {\n          case i:\n            var r = e;\n            return ae(r) + \".Consumer\";\n          case k:\n            var t = e;\n            return ae(t._context) + \".Provider\";\n          case s:\n            return ze(e, e.render, \"ForwardRef\");\n          case a:\n            var n = e.displayName || null;\n            return n !== null ? n : $(e.type) || \"Memo\";\n          case d: {\n            var p = e, v = p._payload, u = p._init;\n            try {\n              return $(u(v));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var F = Object.assign, I = 0, ie, ce, le, se, ue, fe, pe;\n    function ye() {\n    }\n    ye.__reactDisabledLog = !0;\n    function We() {\n      {\n        if (I === 0) {\n          ie = console.log, ce = console.info, le = console.warn, se = console.error, ue = console.group, fe = console.groupCollapsed, pe = console.groupEnd;\n          var e = {\n            configurable: !0,\n            enumerable: !0,\n            value: ye,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: e,\n            log: e,\n            warn: e,\n            error: e,\n            group: e,\n            groupCollapsed: e,\n            groupEnd: e\n          });\n        }\n        I++;\n      }\n    }\n    function Me() {\n      {\n        if (I--, I === 0) {\n          var e = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: F({}, e, {\n              value: ie\n            }),\n            info: F({}, e, {\n              value: ce\n            }),\n            warn: F({}, e, {\n              value: le\n            }),\n            error: F({}, e, {\n              value: se\n            }),\n            group: F({}, e, {\n              value: ue\n            }),\n            groupCollapsed: F({}, e, {\n              value: fe\n            }),\n            groupEnd: F({}, e, {\n              value: pe\n            })\n          });\n        }\n        I < 0 && f(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var X = l.ReactCurrentDispatcher, J;\n    function W(e, r, t) {\n      {\n        if (J === void 0)\n          try {\n            throw Error();\n          } catch (p) {\n            var n = p.stack.trim().match(/\\n( *(at )?)/);\n            J = n && n[1] || \"\";\n          }\n        return `\n` + J + e;\n      }\n    }\n    var K = !1, M;\n    {\n      var Ue = typeof WeakMap == \"function\" ? WeakMap : Map;\n      M = new Ue();\n    }\n    function de(e, r) {\n      if (!e || K)\n        return \"\";\n      {\n        var t = M.get(e);\n        if (t !== void 0)\n          return t;\n      }\n      var n;\n      K = !0;\n      var p = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var v;\n      v = X.current, X.current = null, We();\n      try {\n        if (r) {\n          var u = function() {\n            throw Error();\n          };\n          if (Object.defineProperty(u.prototype, \"props\", {\n            set: function() {\n              throw Error();\n            }\n          }), typeof Reflect == \"object\" && Reflect.construct) {\n            try {\n              Reflect.construct(u, []);\n            } catch (x) {\n              n = x;\n            }\n            Reflect.construct(e, [], u);\n          } else {\n            try {\n              u.call();\n            } catch (x) {\n              n = x;\n            }\n            e.call(u.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            n = x;\n          }\n          e();\n        }\n      } catch (x) {\n        if (x && n && typeof x.stack == \"string\") {\n          for (var c = x.stack.split(`\n`), O = n.stack.split(`\n`), S = c.length - 1, R = O.length - 1; S >= 1 && R >= 0 && c[S] !== O[R]; )\n            R--;\n          for (; S >= 1 && R >= 0; S--, R--)\n            if (c[S] !== O[R]) {\n              if (S !== 1 || R !== 1)\n                do\n                  if (S--, R--, R < 0 || c[S] !== O[R]) {\n                    var P = `\n` + c[S].replace(\" at new \", \" at \");\n                    return e.displayName && P.includes(\"<anonymous>\") && (P = P.replace(\"<anonymous>\", e.displayName)), typeof e == \"function\" && M.set(e, P), P;\n                  }\n                while (S >= 1 && R >= 0);\n              break;\n            }\n        }\n      } finally {\n        K = !1, X.current = v, Me(), Error.prepareStackTrace = p;\n      }\n      var A = e ? e.displayName || e.name : \"\", Oe = A ? W(A) : \"\";\n      return typeof e == \"function\" && M.set(e, Oe), Oe;\n    }\n    function Be(e, r, t) {\n      return de(e, !1);\n    }\n    function Ve(e) {\n      var r = e.prototype;\n      return !!(r && r.isReactComponent);\n    }\n    function U(e, r, t) {\n      if (e == null)\n        return \"\";\n      if (typeof e == \"function\")\n        return de(e, Ve(e));\n      if (typeof e == \"string\")\n        return W(e);\n      switch (e) {\n        case g:\n          return W(\"Suspense\");\n        case o:\n          return W(\"SuspenseList\");\n      }\n      if (typeof e == \"object\")\n        switch (e.$$typeof) {\n          case s:\n            return Be(e.render);\n          case a:\n            return U(e.type, r, t);\n          case d: {\n            var n = e, p = n._payload, v = n._init;\n            try {\n              return U(v(p), r, t);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var B = Object.prototype.hasOwnProperty, me = {}, ge = l.ReactDebugCurrentFrame;\n    function V(e) {\n      if (e) {\n        var r = e._owner, t = U(e.type, e._source, r ? r.type : null);\n        ge.setExtraStackFrame(t);\n      } else\n        ge.setExtraStackFrame(null);\n    }\n    function qe(e, r, t, n, p) {\n      {\n        var v = Function.call.bind(B);\n        for (var u in e)\n          if (v(e, u)) {\n            var c = void 0;\n            try {\n              if (typeof e[u] != \"function\") {\n                var O = Error((n || \"React class\") + \": \" + t + \" type `\" + u + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof e[u] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                throw O.name = \"Invariant Violation\", O;\n              }\n              c = e[u](r, u, n, t, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n            } catch (S) {\n              c = S;\n            }\n            c && !(c instanceof Error) && (V(p), f(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", n || \"React class\", t, u, typeof c), V(null)), c instanceof Error && !(c.message in me) && (me[c.message] = !0, V(p), f(\"Failed %s type: %s\", t, c.message), V(null));\n          }\n      }\n    }\n    var Ye = Array.isArray;\n    function Q(e) {\n      return Ye(e);\n    }\n    function He(e) {\n      {\n        var r = typeof Symbol == \"function\" && Symbol.toStringTag, t = r && e[Symbol.toStringTag] || e.constructor.name || \"Object\";\n        return t;\n      }\n    }\n    function Xe(e) {\n      try {\n        return ve(e), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function ve(e) {\n      return \"\" + e;\n    }\n    function he(e) {\n      if (Xe(e))\n        return f(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", He(e)), ve(e);\n    }\n    var L = l.ReactCurrentOwner, Je = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    }, be, we, Z;\n    Z = {};\n    function Ke(e) {\n      if (B.call(e, \"ref\")) {\n        var r = Object.getOwnPropertyDescriptor(e, \"ref\").get;\n        if (r && r.isReactWarning)\n          return !1;\n      }\n      return e.ref !== void 0;\n    }\n    function Qe(e) {\n      if (B.call(e, \"key\")) {\n        var r = Object.getOwnPropertyDescriptor(e, \"key\").get;\n        if (r && r.isReactWarning)\n          return !1;\n      }\n      return e.key !== void 0;\n    }\n    function Ze(e, r) {\n      if (typeof e.ref == \"string\" && L.current && r && L.current.stateNode !== r) {\n        var t = $(L.current.type);\n        Z[t] || (f('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(L.current.type), e.ref), Z[t] = !0);\n      }\n    }\n    function Ge(e, r) {\n      {\n        var t = function() {\n          be || (be = !0, f(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", r));\n        };\n        t.isReactWarning = !0, Object.defineProperty(e, \"key\", {\n          get: t,\n          configurable: !0\n        });\n      }\n    }\n    function er(e, r) {\n      {\n        var t = function() {\n          we || (we = !0, f(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", r));\n        };\n        t.isReactWarning = !0, Object.defineProperty(e, \"ref\", {\n          get: t,\n          configurable: !0\n        });\n      }\n    }\n    var rr = function(e, r, t, n, p, v, u) {\n      var c = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: m,\n        // Built-in properties that belong on the element\n        type: e,\n        key: r,\n        ref: t,\n        props: u,\n        // Record the component responsible for creating this element.\n        _owner: v\n      };\n      return c._store = {}, Object.defineProperty(c._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty(c, \"_self\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: n\n      }), Object.defineProperty(c, \"_source\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: p\n      }), Object.freeze && (Object.freeze(c.props), Object.freeze(c)), c;\n    };\n    function tr(e, r, t, n, p) {\n      {\n        var v, u = {}, c = null, O = null;\n        t !== void 0 && (he(t), c = \"\" + t), Qe(r) && (he(r.key), c = \"\" + r.key), Ke(r) && (O = r.ref, Ze(r, p));\n        for (v in r)\n          B.call(r, v) && !Je.hasOwnProperty(v) && (u[v] = r[v]);\n        if (e && e.defaultProps) {\n          var S = e.defaultProps;\n          for (v in S)\n            u[v] === void 0 && (u[v] = S[v]);\n        }\n        if (c || O) {\n          var R = typeof e == \"function\" ? e.displayName || e.name || \"Unknown\" : e;\n          c && Ge(u, R), O && er(u, R);\n        }\n        return rr(e, c, O, p, n, L.current, u);\n      }\n    }\n    var G = l.ReactCurrentOwner, Se = l.ReactDebugCurrentFrame;\n    function N(e) {\n      if (e) {\n        var r = e._owner, t = U(e.type, e._source, r ? r.type : null);\n        Se.setExtraStackFrame(t);\n      } else\n        Se.setExtraStackFrame(null);\n    }\n    var ee;\n    ee = !1;\n    function re(e) {\n      return typeof e == \"object\" && e !== null && e.$$typeof === m;\n    }\n    function ke() {\n      {\n        if (G.current) {\n          var e = $(G.current.type);\n          if (e)\n            return `\n\nCheck the render method of \\`` + e + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function nr(e) {\n      {\n        if (e !== void 0) {\n          var r = e.fileName.replace(/^.*[\\\\\\/]/, \"\"), t = e.lineNumber;\n          return `\n\nCheck your code at ` + r + \":\" + t + \".\";\n        }\n        return \"\";\n      }\n    }\n    var Re = {};\n    function or(e) {\n      {\n        var r = ke();\n        if (!r) {\n          var t = typeof e == \"string\" ? e : e.displayName || e.name;\n          t && (r = `\n\nCheck the top-level render call using <` + t + \">.\");\n        }\n        return r;\n      }\n    }\n    function _e(e, r) {\n      {\n        if (!e._store || e._store.validated || e.key != null)\n          return;\n        e._store.validated = !0;\n        var t = or(r);\n        if (Re[t])\n          return;\n        Re[t] = !0;\n        var n = \"\";\n        e && e._owner && e._owner !== G.current && (n = \" It was passed a child from \" + $(e._owner.type) + \".\"), N(e), f('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', t, n), N(null);\n      }\n    }\n    function Ee(e, r) {\n      {\n        if (typeof e != \"object\")\n          return;\n        if (Q(e))\n          for (var t = 0; t < e.length; t++) {\n            var n = e[t];\n            re(n) && _e(n, r);\n          }\n        else if (re(e))\n          e._store && (e._store.validated = !0);\n        else if (e) {\n          var p = D(e);\n          if (typeof p == \"function\" && p !== e.entries)\n            for (var v = p.call(e), u; !(u = v.next()).done; )\n              re(u.value) && _e(u.value, r);\n        }\n      }\n    }\n    function ar(e) {\n      {\n        var r = e.type;\n        if (r == null || typeof r == \"string\")\n          return;\n        var t;\n        if (typeof r == \"function\")\n          t = r.propTypes;\n        else if (typeof r == \"object\" && (r.$$typeof === s || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        r.$$typeof === a))\n          t = r.propTypes;\n        else\n          return;\n        if (t) {\n          var n = $(r);\n          qe(t, e.props, \"prop\", n, e);\n        } else if (r.PropTypes !== void 0 && !ee) {\n          ee = !0;\n          var p = $(r);\n          f(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", p || \"Unknown\");\n        }\n        typeof r.getDefaultProps == \"function\" && !r.getDefaultProps.isReactClassApproved && f(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n      }\n    }\n    function ir(e) {\n      {\n        for (var r = Object.keys(e.props), t = 0; t < r.length; t++) {\n          var n = r[t];\n          if (n !== \"children\" && n !== \"key\") {\n            N(e), f(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", n), N(null);\n            break;\n          }\n        }\n        e.ref !== null && (N(e), f(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), N(null));\n      }\n    }\n    function Ce(e, r, t, n, p, v) {\n      {\n        var u = Le(e);\n        if (!u) {\n          var c = \"\";\n          (e === void 0 || typeof e == \"object\" && e !== null && Object.keys(e).length === 0) && (c += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var O = nr(p);\n          O ? c += O : c += ke();\n          var S;\n          e === null ? S = \"null\" : Q(e) ? S = \"array\" : e !== void 0 && e.$$typeof === m ? (S = \"<\" + ($(e.type) || \"Unknown\") + \" />\", c = \" Did you accidentally export a JSX literal instead of a component?\") : S = typeof e, f(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", S, c);\n        }\n        var R = tr(e, r, t, p, v);\n        if (R == null)\n          return R;\n        if (u) {\n          var P = r.children;\n          if (P !== void 0)\n            if (n)\n              if (Q(P)) {\n                for (var A = 0; A < P.length; A++)\n                  Ee(P[A], e);\n                Object.freeze && Object.freeze(P);\n              } else\n                f(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              Ee(P, e);\n        }\n        return e === b ? ir(R) : ar(R), R;\n      }\n    }\n    function cr(e, r, t) {\n      return Ce(e, r, t, !0);\n    }\n    function lr(e, r, t) {\n      return Ce(e, r, t, !1);\n    }\n    var sr = lr, ur = cr;\n    q.Fragment = b, q.jsx = sr, q.jsxs = ur;\n  }()), q;\n}\n false ? 0 : ne.exports = mr();\nvar $e = ne.exports;\nconst gr = (y, m, _, b) => {\n  let h = m / (_ + b), w = Math.floor(y.length / h);\n  h > y.length && (h = y.length, w = 1);\n  const k = [];\n  for (let i = 0; i < h; i++) {\n    let s = 0;\n    for (let g = 0; g < w && i * w + g < y.length; g++)\n      s += y[i * w + g];\n    k.push(s / w);\n  }\n  return k;\n}, vr = (y, m, _, b, h, w) => {\n  const k = m.height / 2, i = m.getContext(\"2d\");\n  i && (i.clearRect(0, 0, m.width, m.height), h !== \"transparent\" && (i.fillStyle = h, i.fillRect(0, 0, m.width, m.height)), y.forEach((s, g) => {\n    i.fillStyle = w;\n    const o = g * (_ + b), a = k - s / 2, d = _, E = s || 1;\n    i.beginPath(), i.roundRect ? (i.roundRect(o, a, d, E, 50), i.fill()) : i.fillRect(o, a, d, E);\n  }));\n}, Sr = ({\n  mediaRecorder: y,\n  width: m = \"100%\",\n  height: _ = \"100%\",\n  barWidth: b = 2,\n  gap: h = 1,\n  backgroundColor: w = \"transparent\",\n  barColor: k = \"rgb(160, 198, 255)\",\n  fftSize: i = 1024,\n  maxDecibels: s = -10,\n  minDecibels: g = -90,\n  smoothingTimeConstant: o = 0.4\n}) => {\n  const [a] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => new AudioContext()), [d, E] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), C = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!y.stream)\n      return;\n    const l = a.createAnalyser();\n    E(l), l.fftSize = i, l.minDecibels = g, l.maxDecibels = s, l.smoothingTimeConstant = o, a.createMediaStreamSource(y.stream).connect(l);\n  }, [y.stream]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    d && y.state === \"recording\" && T();\n  }, [d, y.state]);\n  const T = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    if (!d)\n      return;\n    const l = new Uint8Array(d == null ? void 0 : d.frequencyBinCount);\n    y.state === \"recording\" ? (d == null || d.getByteFrequencyData(l), D(l), requestAnimationFrame(T)) : y.state === \"paused\" ? D(l) : y.state === \"inactive\" && a.state !== \"closed\" && a.close();\n  }, [d, a.state]), D = (l) => {\n    if (!C.current)\n      return;\n    const f = gr(\n      l,\n      C.current.width,\n      b,\n      h\n    );\n    vr(\n      f,\n      C.current,\n      b,\n      h,\n      w,\n      k\n    );\n  };\n  return /* @__PURE__ */ $e.jsx(\n    \"canvas\",\n    {\n      ref: C,\n      width: m,\n      height: _,\n      style: {\n        aspectRatio: \"unset\"\n      }\n    }\n  );\n}, hr = (y, m, _, b, h) => {\n  const w = y.getChannelData(0), k = _ / (b + h), i = Math.floor(w.length / k), s = m / 2;\n  let g = [], o = 0;\n  for (let a = 0; a < k; a++) {\n    const d = [];\n    let E = 0;\n    const C = [];\n    let T = 0;\n    for (let f = 0; f < i && a * i + f < y.length; f++) {\n      const j = w[a * i + f];\n      j <= 0 && (d.push(j), E++), j > 0 && (C.push(j), T++);\n    }\n    const D = d.reduce((f, j) => f + j, 0) / E, l = { max: C.reduce((f, j) => f + j, 0) / T, min: D };\n    l.max > o && (o = l.max), Math.abs(l.min) > o && (o = Math.abs(l.min)), g.push(l);\n  }\n  if (s * 0.8 > o * s) {\n    const a = s * 0.8 / o;\n    g = g.map((d) => ({\n      max: d.max * a,\n      min: d.min * a\n    }));\n  }\n  return g;\n}, te = (y, m, _, b, h, w, k, i = 0, s = 1) => {\n  const g = m.height / 2, o = m.getContext(\"2d\");\n  if (!o)\n    return;\n  o.clearRect(0, 0, m.width, m.height), h !== \"transparent\" && (o.fillStyle = h, o.fillRect(0, 0, m.width, m.height));\n  const a = (i || 0) / s;\n  y.forEach((d, E) => {\n    const C = E / y.length, T = a > C;\n    o.fillStyle = T && k ? k : w;\n    const D = E * (_ + b), l = g + d.min, f = _, j = g + d.max - l;\n    o.beginPath(), o.roundRect ? (o.roundRect(D, l, f, j, 50), o.fill()) : o.fillRect(D, l, f, j);\n  });\n}, br = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(\n  ({\n    blob: y,\n    width: m,\n    height: _,\n    barWidth: b = 2,\n    gap: h = 1,\n    currentTime: w,\n    style: k,\n    backgroundColor: i = \"transparent\",\n    barColor: s = \"rgb(184, 184, 184)\",\n    barPlayedColor: g = \"rgb(160, 198, 255)\"\n  }, o) => {\n    const a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), [d, E] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]), [C, T] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(\n      o,\n      () => a.current,\n      []\n    ), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      (async () => {\n        if (!a.current)\n          return;\n        if (!y) {\n          const l = Array.from({ length: 100 }, () => ({\n            max: 0,\n            min: 0\n          }));\n          te(\n            l,\n            a.current,\n            b,\n            h,\n            i,\n            s,\n            g\n          );\n          return;\n        }\n        const D = await y.arrayBuffer();\n        await new AudioContext().decodeAudioData(D, (l) => {\n          if (!a.current)\n            return;\n          T(l.duration);\n          const f = hr(\n            l,\n            _,\n            m,\n            b,\n            h\n          );\n          E(f), te(\n            f,\n            a.current,\n            b,\n            h,\n            i,\n            s,\n            g\n          );\n        });\n      })();\n    }, [y, a.current]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      a.current && te(\n        d,\n        a.current,\n        b,\n        h,\n        i,\n        s,\n        g,\n        w,\n        C\n      );\n    }, [w, C]), /* @__PURE__ */ $e.jsx(\n      \"canvas\",\n      {\n        ref: a,\n        width: m,\n        height: _,\n        style: {\n          ...k\n        }\n      }\n    );\n  }\n);\nbr.displayName = \"AudioVisualizer\";\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1hdWRpby12b2ljZS1yZWNvcmRlckAyLjIuMF9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9yZWFjdC1hdWRpby12b2ljZS1yZWNvcmRlci9kaXN0L3JlYWN0LWF1ZGlvLXZpc3VhbGl6ZS5lcy02OTIxNmM3My5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBd0k7QUFDeEksV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtDQUFFLDRMQUE0TDtBQUN4TTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQXFDO0FBQzdELFlBQVksa0NBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsT0FBTztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QjtBQUNBLGFBQWE7QUFDYix1QkFBdUI7QUFDdkI7QUFDQSxhQUFhO0FBQ2IsdUJBQXVCO0FBQ3ZCO0FBQ0EsYUFBYTtBQUNiLGdDQUFnQztBQUNoQztBQUNBLGFBQWE7QUFDYiwwQkFBMEI7QUFDMUI7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxtQ0FBbUM7QUFDM0U7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxrR0FBa0c7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLE1BQXFDLEdBQUcsQ0FBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGNBQWMsK0NBQUMscUNBQXFDLCtDQUFDLFFBQVEsNkNBQUU7QUFDL0QsRUFBRSxnREFBQztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxlQUFlLGdEQUFDO0FBQ25CO0FBQ0EsR0FBRztBQUNILFlBQVksa0RBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMsT0FBTyxpREFBRTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYyw2Q0FBRSxpQkFBaUIsK0NBQUMsZUFBZSwrQ0FBQztBQUNsRCxXQUFXLDBEQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsT0FBTyxnREFBQztBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGFBQWE7QUFDOUM7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLLG1CQUFtQixnREFBQztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWF1ZGlvLXZvaWNlLXJlY29yZGVyQDIuMi4wX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjEvbm9kZV9tb2R1bGVzL3JlYWN0LWF1ZGlvLXZvaWNlLXJlY29yZGVyL2Rpc3QvcmVhY3QtYXVkaW8tdmlzdWFsaXplLmVzLTY5MjE2YzczLmpzPzU5OGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFRlLCB7IHVzZVN0YXRlIGFzIFksIHVzZVJlZiBhcyBEZSwgdXNlRWZmZWN0IGFzIEgsIHVzZUNhbGxiYWNrIGFzIGZyLCBmb3J3YXJkUmVmIGFzIHByLCB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHlyIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgbmUgPSB7IGV4cG9ydHM6IHt9IH0sIHogPSB7fTtcbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBqZTtcbmZ1bmN0aW9uIGRyKCkge1xuICBpZiAoamUpXG4gICAgcmV0dXJuIHo7XG4gIGplID0gMTtcbiAgdmFyIHkgPSBUZSwgbSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLCBfID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLCBiID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgaCA9IHkuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQuUmVhY3RDdXJyZW50T3duZXIsIHcgPSB7IGtleTogITAsIHJlZjogITAsIF9fc2VsZjogITAsIF9fc291cmNlOiAhMCB9O1xuICBmdW5jdGlvbiBrKGksIHMsIGcpIHtcbiAgICB2YXIgbywgYSA9IHt9LCBkID0gbnVsbCwgRSA9IG51bGw7XG4gICAgZyAhPT0gdm9pZCAwICYmIChkID0gXCJcIiArIGcpLCBzLmtleSAhPT0gdm9pZCAwICYmIChkID0gXCJcIiArIHMua2V5KSwgcy5yZWYgIT09IHZvaWQgMCAmJiAoRSA9IHMucmVmKTtcbiAgICBmb3IgKG8gaW4gcylcbiAgICAgIGIuY2FsbChzLCBvKSAmJiAhdy5oYXNPd25Qcm9wZXJ0eShvKSAmJiAoYVtvXSA9IHNbb10pO1xuICAgIGlmIChpICYmIGkuZGVmYXVsdFByb3BzKVxuICAgICAgZm9yIChvIGluIHMgPSBpLmRlZmF1bHRQcm9wcywgcylcbiAgICAgICAgYVtvXSA9PT0gdm9pZCAwICYmIChhW29dID0gc1tvXSk7XG4gICAgcmV0dXJuIHsgJCR0eXBlb2Y6IG0sIHR5cGU6IGksIGtleTogZCwgcmVmOiBFLCBwcm9wczogYSwgX293bmVyOiBoLmN1cnJlbnQgfTtcbiAgfVxuICByZXR1cm4gei5GcmFnbWVudCA9IF8sIHouanN4ID0gaywgei5qc3hzID0gaywgejtcbn1cbnZhciBxID0ge307XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIgUGU7XG5mdW5jdGlvbiBtcigpIHtcbiAgcmV0dXJuIFBlIHx8IChQZSA9IDEsIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBmdW5jdGlvbigpIHtcbiAgICB2YXIgeSA9IFRlLCBtID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksIF8gPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLCBiID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLCBoID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLCB3ID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLCBrID0gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpLCBpID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksIHMgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksIGcgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksIG8gPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSwgYSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLCBkID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksIEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpLCBDID0gU3ltYm9sLml0ZXJhdG9yLCBUID0gXCJAQGl0ZXJhdG9yXCI7XG4gICAgZnVuY3Rpb24gRChlKSB7XG4gICAgICBpZiAoZSA9PT0gbnVsbCB8fCB0eXBlb2YgZSAhPSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIHZhciByID0gQyAmJiBlW0NdIHx8IGVbVF07XG4gICAgICByZXR1cm4gdHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiID8gciA6IG51bGw7XG4gICAgfVxuICAgIHZhciBsID0geS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcbiAgICBmdW5jdGlvbiBmKGUpIHtcbiAgICAgIHtcbiAgICAgICAgZm9yICh2YXIgciA9IGFyZ3VtZW50cy5sZW5ndGgsIHQgPSBuZXcgQXJyYXkociA+IDEgPyByIC0gMSA6IDApLCBuID0gMTsgbiA8IHI7IG4rKylcbiAgICAgICAgICB0W24gLSAxXSA9IGFyZ3VtZW50c1tuXTtcbiAgICAgICAgaihcImVycm9yXCIsIGUsIHQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBqKGUsIHIsIHQpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIG4gPSBsLlJlYWN0RGVidWdDdXJyZW50RnJhbWUsIHAgPSBuLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAgICAgcCAhPT0gXCJcIiAmJiAociArPSBcIiVzXCIsIHQgPSB0LmNvbmNhdChbcF0pKTtcbiAgICAgICAgdmFyIHYgPSB0Lm1hcChmdW5jdGlvbih1KSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh1KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHYudW5zaGlmdChcIldhcm5pbmc6IFwiICsgciksIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbZV0sIGNvbnNvbGUsIHYpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgeGUgPSAhMSwgRmUgPSAhMSwgTmUgPSAhMSwgQWUgPSAhMSwgSWUgPSAhMSwgb2U7XG4gICAgb2UgPSBTeW1ib2wuZm9yKFwicmVhY3QubW9kdWxlLnJlZmVyZW5jZVwiKTtcbiAgICBmdW5jdGlvbiBMZShlKSB7XG4gICAgICByZXR1cm4gISEodHlwZW9mIGUgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgfHwgZSA9PT0gYiB8fCBlID09PSB3IHx8IEllIHx8IGUgPT09IGggfHwgZSA9PT0gZyB8fCBlID09PSBvIHx8IEFlIHx8IGUgPT09IEUgfHwgeGUgfHwgRmUgfHwgTmUgfHwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiBlICE9PSBudWxsICYmIChlLiQkdHlwZW9mID09PSBkIHx8IGUuJCR0eXBlb2YgPT09IGEgfHwgZS4kJHR5cGVvZiA9PT0gayB8fCBlLiQkdHlwZW9mID09PSBpIHx8IGUuJCR0eXBlb2YgPT09IHMgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgICAvLyB3aXRoLlxuICAgICAgZS4kJHR5cGVvZiA9PT0gb2UgfHwgZS5nZXRNb2R1bGVJZCAhPT0gdm9pZCAwKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHplKGUsIHIsIHQpIHtcbiAgICAgIHZhciBuID0gZS5kaXNwbGF5TmFtZTtcbiAgICAgIGlmIChuKVxuICAgICAgICByZXR1cm4gbjtcbiAgICAgIHZhciBwID0gci5kaXNwbGF5TmFtZSB8fCByLm5hbWUgfHwgXCJcIjtcbiAgICAgIHJldHVybiBwICE9PSBcIlwiID8gdCArIFwiKFwiICsgcCArIFwiKVwiIDogdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWUoZSkge1xuICAgICAgcmV0dXJuIGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uICQoZSkge1xuICAgICAgaWYgKGUgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBpZiAodHlwZW9mIGUudGFnID09IFwibnVtYmVyXCIgJiYgZihcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIpLCB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBlLmRpc3BsYXlOYW1lIHx8IGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBlO1xuICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgIGNhc2UgYjpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIF86XG4gICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgIGNhc2UgdzpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIGg6XG4gICAgICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgICAgICBjYXNlIGc6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSBvOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlID09IFwib2JqZWN0XCIpXG4gICAgICAgIHN3aXRjaCAoZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgaTpcbiAgICAgICAgICAgIHZhciByID0gZTtcbiAgICAgICAgICAgIHJldHVybiBhZShyKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSBrOlxuICAgICAgICAgICAgdmFyIHQgPSBlO1xuICAgICAgICAgICAgcmV0dXJuIGFlKHQuX2NvbnRleHQpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgICBjYXNlIHM6XG4gICAgICAgICAgICByZXR1cm4gemUoZSwgZS5yZW5kZXIsIFwiRm9yd2FyZFJlZlwiKTtcbiAgICAgICAgICBjYXNlIGE6XG4gICAgICAgICAgICB2YXIgbiA9IGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBuICE9PSBudWxsID8gbiA6ICQoZS50eXBlKSB8fCBcIk1lbW9cIjtcbiAgICAgICAgICBjYXNlIGQ6IHtcbiAgICAgICAgICAgIHZhciBwID0gZSwgdiA9IHAuX3BheWxvYWQsIHUgPSBwLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuICQodSh2KSk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIEYgPSBPYmplY3QuYXNzaWduLCBJID0gMCwgaWUsIGNlLCBsZSwgc2UsIHVlLCBmZSwgcGU7XG4gICAgZnVuY3Rpb24geWUoKSB7XG4gICAgfVxuICAgIHllLl9fcmVhY3REaXNhYmxlZExvZyA9ICEwO1xuICAgIGZ1bmN0aW9uIFdlKCkge1xuICAgICAge1xuICAgICAgICBpZiAoSSA9PT0gMCkge1xuICAgICAgICAgIGllID0gY29uc29sZS5sb2csIGNlID0gY29uc29sZS5pbmZvLCBsZSA9IGNvbnNvbGUud2Fybiwgc2UgPSBjb25zb2xlLmVycm9yLCB1ZSA9IGNvbnNvbGUuZ3JvdXAsIGZlID0gY29uc29sZS5ncm91cENvbGxhcHNlZCwgcGUgPSBjb25zb2xlLmdyb3VwRW5kO1xuICAgICAgICAgIHZhciBlID0ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgdmFsdWU6IHllLFxuICAgICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgICBpbmZvOiBlLFxuICAgICAgICAgICAgbG9nOiBlLFxuICAgICAgICAgICAgd2FybjogZSxcbiAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgZ3JvdXA6IGUsXG4gICAgICAgICAgICBncm91cENvbGxhcHNlZDogZSxcbiAgICAgICAgICAgIGdyb3VwRW5kOiBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgSSsrO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBNZSgpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKEktLSwgSSA9PT0gMCkge1xuICAgICAgICAgIHZhciBlID0ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgICBsb2c6IEYoe30sIGUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGllXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGluZm86IEYoe30sIGUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGNlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHdhcm46IEYoe30sIGUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGxlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGVycm9yOiBGKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBzZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cDogRih7fSwgZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogdWVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IEYoe30sIGUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGZlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdyb3VwRW5kOiBGKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBwZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBJIDwgMCAmJiBmKFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIFggPSBsLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsIEo7XG4gICAgZnVuY3Rpb24gVyhlLCByLCB0KSB7XG4gICAgICB7XG4gICAgICAgIGlmIChKID09PSB2b2lkIDApXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAocCkge1xuICAgICAgICAgICAgdmFyIG4gPSBwLnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICAgICAgSiA9IG4gJiYgblsxXSB8fCBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBcbmAgKyBKICsgZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIEsgPSAhMSwgTTtcbiAgICB7XG4gICAgICB2YXIgVWUgPSB0eXBlb2YgV2Vha01hcCA9PSBcImZ1bmN0aW9uXCIgPyBXZWFrTWFwIDogTWFwO1xuICAgICAgTSA9IG5ldyBVZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZShlLCByKSB7XG4gICAgICBpZiAoIWUgfHwgSylcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB7XG4gICAgICAgIHZhciB0ID0gTS5nZXQoZSk7XG4gICAgICAgIGlmICh0ICE9PSB2b2lkIDApXG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9XG4gICAgICB2YXIgbjtcbiAgICAgIEsgPSAhMDtcbiAgICAgIHZhciBwID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHZvaWQgMDtcbiAgICAgIHZhciB2O1xuICAgICAgdiA9IFguY3VycmVudCwgWC5jdXJyZW50ID0gbnVsbCwgV2UoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgdmFyIHUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KHUucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIHR5cGVvZiBSZWZsZWN0ID09IFwib2JqZWN0XCIgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KHUsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgbiA9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChlLCBbXSwgdSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHUuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBuID0geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUuY2FsbCh1LnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIG4gPSB4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgaWYgKHggJiYgbiAmJiB0eXBlb2YgeC5zdGFjayA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgZm9yICh2YXIgYyA9IHguc3RhY2suc3BsaXQoYFxuYCksIE8gPSBuLnN0YWNrLnNwbGl0KGBcbmApLCBTID0gYy5sZW5ndGggLSAxLCBSID0gTy5sZW5ndGggLSAxOyBTID49IDEgJiYgUiA+PSAwICYmIGNbU10gIT09IE9bUl07IClcbiAgICAgICAgICAgIFItLTtcbiAgICAgICAgICBmb3IgKDsgUyA+PSAxICYmIFIgPj0gMDsgUy0tLCBSLS0pXG4gICAgICAgICAgICBpZiAoY1tTXSAhPT0gT1tSXSkge1xuICAgICAgICAgICAgICBpZiAoUyAhPT0gMSB8fCBSICE9PSAxKVxuICAgICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgICBpZiAoUy0tLCBSLS0sIFIgPCAwIHx8IGNbU10gIT09IE9bUl0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFAgPSBgXG5gICsgY1tTXS5yZXBsYWNlKFwiIGF0IG5ldyBcIiwgXCIgYXQgXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5kaXNwbGF5TmFtZSAmJiBQLmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiYgKFAgPSBQLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBlLmRpc3BsYXlOYW1lKSksIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiAmJiBNLnNldChlLCBQKSwgUDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoUyA+PSAxICYmIFIgPj0gMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBLID0gITEsIFguY3VycmVudCA9IHYsIE1lKCksIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcDtcbiAgICAgIH1cbiAgICAgIHZhciBBID0gZSA/IGUuZGlzcGxheU5hbWUgfHwgZS5uYW1lIDogXCJcIiwgT2UgPSBBID8gVyhBKSA6IFwiXCI7XG4gICAgICByZXR1cm4gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiICYmIE0uc2V0KGUsIE9lKSwgT2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEJlKGUsIHIsIHQpIHtcbiAgICAgIHJldHVybiBkZShlLCAhMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFZlKGUpIHtcbiAgICAgIHZhciByID0gZS5wcm90b3R5cGU7XG4gICAgICByZXR1cm4gISEociAmJiByLmlzUmVhY3RDb21wb25lbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVKGUsIHIsIHQpIHtcbiAgICAgIGlmIChlID09IG51bGwpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgaWYgKHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIGRlKGUsIFZlKGUpKTtcbiAgICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gVyhlKTtcbiAgICAgIHN3aXRjaCAoZSkge1xuICAgICAgICBjYXNlIGc6XG4gICAgICAgICAgcmV0dXJuIFcoXCJTdXNwZW5zZVwiKTtcbiAgICAgICAgY2FzZSBvOlxuICAgICAgICAgIHJldHVybiBXKFwiU3VzcGVuc2VMaXN0XCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlID09IFwib2JqZWN0XCIpXG4gICAgICAgIHN3aXRjaCAoZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgczpcbiAgICAgICAgICAgIHJldHVybiBCZShlLnJlbmRlcik7XG4gICAgICAgICAgY2FzZSBhOlxuICAgICAgICAgICAgcmV0dXJuIFUoZS50eXBlLCByLCB0KTtcbiAgICAgICAgICBjYXNlIGQ6IHtcbiAgICAgICAgICAgIHZhciBuID0gZSwgcCA9IG4uX3BheWxvYWQsIHYgPSBuLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIFUodihwKSwgciwgdCk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICB2YXIgQiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIG1lID0ge30sIGdlID0gbC5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIGZ1bmN0aW9uIFYoZSkge1xuICAgICAgaWYgKGUpIHtcbiAgICAgICAgdmFyIHIgPSBlLl9vd25lciwgdCA9IFUoZS50eXBlLCBlLl9zb3VyY2UsIHIgPyByLnR5cGUgOiBudWxsKTtcbiAgICAgICAgZ2Uuc2V0RXh0cmFTdGFja0ZyYW1lKHQpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGdlLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcWUoZSwgciwgdCwgbiwgcCkge1xuICAgICAge1xuICAgICAgICB2YXIgdiA9IEZ1bmN0aW9uLmNhbGwuYmluZChCKTtcbiAgICAgICAgZm9yICh2YXIgdSBpbiBlKVxuICAgICAgICAgIGlmICh2KGUsIHUpKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZVt1XSAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgTyA9IEVycm9yKChuIHx8IFwiUmVhY3QgY2xhc3NcIikgKyBcIjogXCIgKyB0ICsgXCIgdHlwZSBgXCIgKyB1ICsgXCJgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGBcIiArIHR5cGVvZiBlW3VdICsgXCJgLlRoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLlwiKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBPLm5hbWUgPSBcIkludmFyaWFudCBWaW9sYXRpb25cIiwgTztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjID0gZVt1XShyLCB1LCBuLCB0LCBudWxsLCBcIlNFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEXCIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoUykge1xuICAgICAgICAgICAgICBjID0gUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMgJiYgIShjIGluc3RhbmNlb2YgRXJyb3IpICYmIChWKHApLCBmKFwiJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuIFlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyIGNyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLlwiLCBuIHx8IFwiUmVhY3QgY2xhc3NcIiwgdCwgdSwgdHlwZW9mIGMpLCBWKG51bGwpKSwgYyBpbnN0YW5jZW9mIEVycm9yICYmICEoYy5tZXNzYWdlIGluIG1lKSAmJiAobWVbYy5tZXNzYWdlXSA9ICEwLCBWKHApLCBmKFwiRmFpbGVkICVzIHR5cGU6ICVzXCIsIHQsIGMubWVzc2FnZSksIFYobnVsbCkpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIFllID0gQXJyYXkuaXNBcnJheTtcbiAgICBmdW5jdGlvbiBRKGUpIHtcbiAgICAgIHJldHVybiBZZShlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSGUoZSkge1xuICAgICAge1xuICAgICAgICB2YXIgciA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC50b1N0cmluZ1RhZywgdCA9IHIgJiYgZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IGUuY29uc3RydWN0b3IubmFtZSB8fCBcIk9iamVjdFwiO1xuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gWGUoZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHZlKGUpLCAhMTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZlKGUpIHtcbiAgICAgIHJldHVybiBcIlwiICsgZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGUoZSkge1xuICAgICAgaWYgKFhlKGUpKVxuICAgICAgICByZXR1cm4gZihcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLCBIZShlKSksIHZlKGUpO1xuICAgIH1cbiAgICB2YXIgTCA9IGwuUmVhY3RDdXJyZW50T3duZXIsIEplID0ge1xuICAgICAga2V5OiAhMCxcbiAgICAgIHJlZjogITAsXG4gICAgICBfX3NlbGY6ICEwLFxuICAgICAgX19zb3VyY2U6ICEwXG4gICAgfSwgYmUsIHdlLCBaO1xuICAgIFogPSB7fTtcbiAgICBmdW5jdGlvbiBLZShlKSB7XG4gICAgICBpZiAoQi5jYWxsKGUsIFwicmVmXCIpKSB7XG4gICAgICAgIHZhciByID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBcInJlZlwiKS5nZXQ7XG4gICAgICAgIGlmIChyICYmIHIuaXNSZWFjdFdhcm5pbmcpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGUucmVmICE9PSB2b2lkIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFFlKGUpIHtcbiAgICAgIGlmIChCLmNhbGwoZSwgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKHIgJiYgci5pc1JlYWN0V2FybmluZylcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gZS5rZXkgIT09IHZvaWQgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gWmUoZSwgcikge1xuICAgICAgaWYgKHR5cGVvZiBlLnJlZiA9PSBcInN0cmluZ1wiICYmIEwuY3VycmVudCAmJiByICYmIEwuY3VycmVudC5zdGF0ZU5vZGUgIT09IHIpIHtcbiAgICAgICAgdmFyIHQgPSAkKEwuY3VycmVudC50eXBlKTtcbiAgICAgICAgWlt0XSB8fCAoZignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuIFN1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiBXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsICQoTC5jdXJyZW50LnR5cGUpLCBlLnJlZiksIFpbdF0gPSAhMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIEdlKGUsIHIpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBiZSB8fCAoYmUgPSAhMCwgZihcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpXCIsIHIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdC5pc1JlYWN0V2FybmluZyA9ICEwLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJrZXlcIiwge1xuICAgICAgICAgIGdldDogdCxcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBlcihlLCByKSB7XG4gICAgICB7XG4gICAgICAgIHZhciB0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgd2UgfHwgKHdlID0gITAsIGYoXCIlczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKVwiLCByKSk7XG4gICAgICAgIH07XG4gICAgICAgIHQuaXNSZWFjdFdhcm5pbmcgPSAhMCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicmVmXCIsIHtcbiAgICAgICAgICBnZXQ6IHQsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJyID0gZnVuY3Rpb24oZSwgciwgdCwgbiwgcCwgdiwgdSkge1xuICAgICAgdmFyIGMgPSB7XG4gICAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgICAkJHR5cGVvZjogbSxcbiAgICAgICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgICAgICB0eXBlOiBlLFxuICAgICAgICBrZXk6IHIsXG4gICAgICAgIHJlZjogdCxcbiAgICAgICAgcHJvcHM6IHUsXG4gICAgICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgICAgIF9vd25lcjogdlxuICAgICAgfTtcbiAgICAgIHJldHVybiBjLl9zdG9yZSA9IHt9LCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYy5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6ICExXG4gICAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGMsIFwiX3NlbGZcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICExLFxuICAgICAgICB2YWx1ZTogblxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjLCBcIl9zb3VyY2VcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICExLFxuICAgICAgICB2YWx1ZTogcFxuICAgICAgfSksIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUoYy5wcm9wcyksIE9iamVjdC5mcmVlemUoYykpLCBjO1xuICAgIH07XG4gICAgZnVuY3Rpb24gdHIoZSwgciwgdCwgbiwgcCkge1xuICAgICAge1xuICAgICAgICB2YXIgdiwgdSA9IHt9LCBjID0gbnVsbCwgTyA9IG51bGw7XG4gICAgICAgIHQgIT09IHZvaWQgMCAmJiAoaGUodCksIGMgPSBcIlwiICsgdCksIFFlKHIpICYmIChoZShyLmtleSksIGMgPSBcIlwiICsgci5rZXkpLCBLZShyKSAmJiAoTyA9IHIucmVmLCBaZShyLCBwKSk7XG4gICAgICAgIGZvciAodiBpbiByKVxuICAgICAgICAgIEIuY2FsbChyLCB2KSAmJiAhSmUuaGFzT3duUHJvcGVydHkodikgJiYgKHVbdl0gPSByW3ZdKTtcbiAgICAgICAgaWYgKGUgJiYgZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICB2YXIgUyA9IGUuZGVmYXVsdFByb3BzO1xuICAgICAgICAgIGZvciAodiBpbiBTKVxuICAgICAgICAgICAgdVt2XSA9PT0gdm9pZCAwICYmICh1W3ZdID0gU1t2XSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgfHwgTykge1xuICAgICAgICAgIHZhciBSID0gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWUgfHwgXCJVbmtub3duXCIgOiBlO1xuICAgICAgICAgIGMgJiYgR2UodSwgUiksIE8gJiYgZXIodSwgUik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJyKGUsIGMsIE8sIHAsIG4sIEwuY3VycmVudCwgdSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBHID0gbC5SZWFjdEN1cnJlbnRPd25lciwgU2UgPSBsLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgZnVuY3Rpb24gTihlKSB7XG4gICAgICBpZiAoZSkge1xuICAgICAgICB2YXIgciA9IGUuX293bmVyLCB0ID0gVShlLnR5cGUsIGUuX3NvdXJjZSwgciA/IHIudHlwZSA6IG51bGwpO1xuICAgICAgICBTZS5zZXRFeHRyYVN0YWNrRnJhbWUodCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgU2Uuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgICB2YXIgZWU7XG4gICAgZWUgPSAhMTtcbiAgICBmdW5jdGlvbiByZShlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiBlICE9PSBudWxsICYmIGUuJCR0eXBlb2YgPT09IG07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGtlKCkge1xuICAgICAge1xuICAgICAgICBpZiAoRy5jdXJyZW50KSB7XG4gICAgICAgICAgdmFyIGUgPSAkKEcuY3VycmVudC50eXBlKTtcbiAgICAgICAgICBpZiAoZSlcbiAgICAgICAgICAgIHJldHVybiBgXG5cbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIFxcYGAgKyBlICsgXCJgLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBucihlKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB2YXIgciA9IGUuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgXCJcIiksIHQgPSBlLmxpbmVOdW1iZXI7XG4gICAgICAgICAgcmV0dXJuIGBcblxuQ2hlY2sgeW91ciBjb2RlIGF0IGAgKyByICsgXCI6XCIgKyB0ICsgXCIuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBSZSA9IHt9O1xuICAgIGZ1bmN0aW9uIG9yKGUpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHIgPSBrZSgpO1xuICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICB2YXIgdCA9IHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyBlIDogZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWU7XG4gICAgICAgICAgdCAmJiAociA9IGBcblxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8YCArIHQgKyBcIj4uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfZShlLCByKSB7XG4gICAgICB7XG4gICAgICAgIGlmICghZS5fc3RvcmUgfHwgZS5fc3RvcmUudmFsaWRhdGVkIHx8IGUua2V5ICE9IG51bGwpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlLl9zdG9yZS52YWxpZGF0ZWQgPSAhMDtcbiAgICAgICAgdmFyIHQgPSBvcihyKTtcbiAgICAgICAgaWYgKFJlW3RdKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgUmVbdF0gPSAhMDtcbiAgICAgICAgdmFyIG4gPSBcIlwiO1xuICAgICAgICBlICYmIGUuX293bmVyICYmIGUuX293bmVyICE9PSBHLmN1cnJlbnQgJiYgKG4gPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArICQoZS5fb3duZXIudHlwZSkgKyBcIi5cIiksIE4oZSksIGYoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4lcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIHQsIG4pLCBOKG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBFZShlLCByKSB7XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgZSAhPSBcIm9iamVjdFwiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKFEoZSkpXG4gICAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCBlLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgICB2YXIgbiA9IGVbdF07XG4gICAgICAgICAgICByZShuKSAmJiBfZShuLCByKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlKGUpKVxuICAgICAgICAgIGUuX3N0b3JlICYmIChlLl9zdG9yZS52YWxpZGF0ZWQgPSAhMCk7XG4gICAgICAgIGVsc2UgaWYgKGUpIHtcbiAgICAgICAgICB2YXIgcCA9IEQoZSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwID09IFwiZnVuY3Rpb25cIiAmJiBwICE9PSBlLmVudHJpZXMpXG4gICAgICAgICAgICBmb3IgKHZhciB2ID0gcC5jYWxsKGUpLCB1OyAhKHUgPSB2Lm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgICAgICByZSh1LnZhbHVlKSAmJiBfZSh1LnZhbHVlLCByKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhcihlKSB7XG4gICAgICB7XG4gICAgICAgIHZhciByID0gZS50eXBlO1xuICAgICAgICBpZiAociA9PSBudWxsIHx8IHR5cGVvZiByID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgaWYgKHR5cGVvZiByID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICB0ID0gci5wcm9wVHlwZXM7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiByID09IFwib2JqZWN0XCIgJiYgKHIuJCR0eXBlb2YgPT09IHMgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgICAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICAgICAgci4kJHR5cGVvZiA9PT0gYSkpXG4gICAgICAgICAgdCA9IHIucHJvcFR5cGVzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodCkge1xuICAgICAgICAgIHZhciBuID0gJChyKTtcbiAgICAgICAgICBxZSh0LCBlLnByb3BzLCBcInByb3BcIiwgbiwgZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoci5Qcm9wVHlwZXMgIT09IHZvaWQgMCAmJiAhZWUpIHtcbiAgICAgICAgICBlZSA9ICEwO1xuICAgICAgICAgIHZhciBwID0gJChyKTtcbiAgICAgICAgICBmKFwiQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/XCIsIHAgfHwgXCJVbmtub3duXCIpO1xuICAgICAgICB9XG4gICAgICAgIHR5cGVvZiByLmdldERlZmF1bHRQcm9wcyA9PSBcImZ1bmN0aW9uXCIgJiYgIXIuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmIGYoXCJnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXIoZSkge1xuICAgICAge1xuICAgICAgICBmb3IgKHZhciByID0gT2JqZWN0LmtleXMoZS5wcm9wcyksIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykge1xuICAgICAgICAgIHZhciBuID0gclt0XTtcbiAgICAgICAgICBpZiAobiAhPT0gXCJjaGlsZHJlblwiICYmIG4gIT09IFwia2V5XCIpIHtcbiAgICAgICAgICAgIE4oZSksIGYoXCJJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiBSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLlwiLCBuKSwgTihudWxsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlLnJlZiAhPT0gbnVsbCAmJiAoTihlKSwgZihcIkludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuXCIpLCBOKG51bGwpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gQ2UoZSwgciwgdCwgbiwgcCwgdikge1xuICAgICAge1xuICAgICAgICB2YXIgdSA9IExlKGUpO1xuICAgICAgICBpZiAoIXUpIHtcbiAgICAgICAgICB2YXIgYyA9IFwiXCI7XG4gICAgICAgICAgKGUgPT09IHZvaWQgMCB8fCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXMoZSkubGVuZ3RoID09PSAwKSAmJiAoYyArPSBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCIpO1xuICAgICAgICAgIHZhciBPID0gbnIocCk7XG4gICAgICAgICAgTyA/IGMgKz0gTyA6IGMgKz0ga2UoKTtcbiAgICAgICAgICB2YXIgUztcbiAgICAgICAgICBlID09PSBudWxsID8gUyA9IFwibnVsbFwiIDogUShlKSA/IFMgPSBcImFycmF5XCIgOiBlICE9PSB2b2lkIDAgJiYgZS4kJHR5cGVvZiA9PT0gbSA/IChTID0gXCI8XCIgKyAoJChlLnR5cGUpIHx8IFwiVW5rbm93blwiKSArIFwiIC8+XCIsIGMgPSBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50P1wiKSA6IFMgPSB0eXBlb2YgZSwgZihcIlJlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lc1wiLCBTLCBjKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgUiA9IHRyKGUsIHIsIHQsIHAsIHYpO1xuICAgICAgICBpZiAoUiA9PSBudWxsKVxuICAgICAgICAgIHJldHVybiBSO1xuICAgICAgICBpZiAodSkge1xuICAgICAgICAgIHZhciBQID0gci5jaGlsZHJlbjtcbiAgICAgICAgICBpZiAoUCAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgaWYgKG4pXG4gICAgICAgICAgICAgIGlmIChRKFApKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgQSA9IDA7IEEgPCBQLmxlbmd0aDsgQSsrKVxuICAgICAgICAgICAgICAgICAgRWUoUFtBXSwgZSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKFApO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBmKFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgRWUoUCwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGUgPT09IGIgPyBpcihSKSA6IGFyKFIpLCBSO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjcihlLCByLCB0KSB7XG4gICAgICByZXR1cm4gQ2UoZSwgciwgdCwgITApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBscihlLCByLCB0KSB7XG4gICAgICByZXR1cm4gQ2UoZSwgciwgdCwgITEpO1xuICAgIH1cbiAgICB2YXIgc3IgPSBsciwgdXIgPSBjcjtcbiAgICBxLkZyYWdtZW50ID0gYiwgcS5qc3ggPSBzciwgcS5qc3hzID0gdXI7XG4gIH0oKSksIHE7XG59XG5wcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBuZS5leHBvcnRzID0gZHIoKSA6IG5lLmV4cG9ydHMgPSBtcigpO1xudmFyICRlID0gbmUuZXhwb3J0cztcbmNvbnN0IGdyID0gKHksIG0sIF8sIGIpID0+IHtcbiAgbGV0IGggPSBtIC8gKF8gKyBiKSwgdyA9IE1hdGguZmxvb3IoeS5sZW5ndGggLyBoKTtcbiAgaCA+IHkubGVuZ3RoICYmIChoID0geS5sZW5ndGgsIHcgPSAxKTtcbiAgY29uc3QgayA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGg7IGkrKykge1xuICAgIGxldCBzID0gMDtcbiAgICBmb3IgKGxldCBnID0gMDsgZyA8IHcgJiYgaSAqIHcgKyBnIDwgeS5sZW5ndGg7IGcrKylcbiAgICAgIHMgKz0geVtpICogdyArIGddO1xuICAgIGsucHVzaChzIC8gdyk7XG4gIH1cbiAgcmV0dXJuIGs7XG59LCB2ciA9ICh5LCBtLCBfLCBiLCBoLCB3KSA9PiB7XG4gIGNvbnN0IGsgPSBtLmhlaWdodCAvIDIsIGkgPSBtLmdldENvbnRleHQoXCIyZFwiKTtcbiAgaSAmJiAoaS5jbGVhclJlY3QoMCwgMCwgbS53aWR0aCwgbS5oZWlnaHQpLCBoICE9PSBcInRyYW5zcGFyZW50XCIgJiYgKGkuZmlsbFN0eWxlID0gaCwgaS5maWxsUmVjdCgwLCAwLCBtLndpZHRoLCBtLmhlaWdodCkpLCB5LmZvckVhY2goKHMsIGcpID0+IHtcbiAgICBpLmZpbGxTdHlsZSA9IHc7XG4gICAgY29uc3QgbyA9IGcgKiAoXyArIGIpLCBhID0gayAtIHMgLyAyLCBkID0gXywgRSA9IHMgfHwgMTtcbiAgICBpLmJlZ2luUGF0aCgpLCBpLnJvdW5kUmVjdCA/IChpLnJvdW5kUmVjdChvLCBhLCBkLCBFLCA1MCksIGkuZmlsbCgpKSA6IGkuZmlsbFJlY3QobywgYSwgZCwgRSk7XG4gIH0pKTtcbn0sIFNyID0gKHtcbiAgbWVkaWFSZWNvcmRlcjogeSxcbiAgd2lkdGg6IG0gPSBcIjEwMCVcIixcbiAgaGVpZ2h0OiBfID0gXCIxMDAlXCIsXG4gIGJhcldpZHRoOiBiID0gMixcbiAgZ2FwOiBoID0gMSxcbiAgYmFja2dyb3VuZENvbG9yOiB3ID0gXCJ0cmFuc3BhcmVudFwiLFxuICBiYXJDb2xvcjogayA9IFwicmdiKDE2MCwgMTk4LCAyNTUpXCIsXG4gIGZmdFNpemU6IGkgPSAxMDI0LFxuICBtYXhEZWNpYmVsczogcyA9IC0xMCxcbiAgbWluRGVjaWJlbHM6IGcgPSAtOTAsXG4gIHNtb290aGluZ1RpbWVDb25zdGFudDogbyA9IDAuNFxufSkgPT4ge1xuICBjb25zdCBbYV0gPSBZKCgpID0+IG5ldyBBdWRpb0NvbnRleHQoKSksIFtkLCBFXSA9IFkoKSwgQyA9IERlKG51bGwpO1xuICBIKCgpID0+IHtcbiAgICBpZiAoIXkuc3RyZWFtKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGwgPSBhLmNyZWF0ZUFuYWx5c2VyKCk7XG4gICAgRShsKSwgbC5mZnRTaXplID0gaSwgbC5taW5EZWNpYmVscyA9IGcsIGwubWF4RGVjaWJlbHMgPSBzLCBsLnNtb290aGluZ1RpbWVDb25zdGFudCA9IG8sIGEuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UoeS5zdHJlYW0pLmNvbm5lY3QobCk7XG4gIH0sIFt5LnN0cmVhbV0pLCBIKCgpID0+IHtcbiAgICBkICYmIHkuc3RhdGUgPT09IFwicmVjb3JkaW5nXCIgJiYgVCgpO1xuICB9LCBbZCwgeS5zdGF0ZV0pO1xuICBjb25zdCBUID0gZnIoKCkgPT4ge1xuICAgIGlmICghZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBsID0gbmV3IFVpbnQ4QXJyYXkoZCA9PSBudWxsID8gdm9pZCAwIDogZC5mcmVxdWVuY3lCaW5Db3VudCk7XG4gICAgeS5zdGF0ZSA9PT0gXCJyZWNvcmRpbmdcIiA/IChkID09IG51bGwgfHwgZC5nZXRCeXRlRnJlcXVlbmN5RGF0YShsKSwgRChsKSwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKFQpKSA6IHkuc3RhdGUgPT09IFwicGF1c2VkXCIgPyBEKGwpIDogeS5zdGF0ZSA9PT0gXCJpbmFjdGl2ZVwiICYmIGEuc3RhdGUgIT09IFwiY2xvc2VkXCIgJiYgYS5jbG9zZSgpO1xuICB9LCBbZCwgYS5zdGF0ZV0pLCBEID0gKGwpID0+IHtcbiAgICBpZiAoIUMuY3VycmVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBmID0gZ3IoXG4gICAgICBsLFxuICAgICAgQy5jdXJyZW50LndpZHRoLFxuICAgICAgYixcbiAgICAgIGhcbiAgICApO1xuICAgIHZyKFxuICAgICAgZixcbiAgICAgIEMuY3VycmVudCxcbiAgICAgIGIsXG4gICAgICBoLFxuICAgICAgdyxcbiAgICAgIGtcbiAgICApO1xuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovICRlLmpzeChcbiAgICBcImNhbnZhc1wiLFxuICAgIHtcbiAgICAgIHJlZjogQyxcbiAgICAgIHdpZHRoOiBtLFxuICAgICAgaGVpZ2h0OiBfLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgYXNwZWN0UmF0aW86IFwidW5zZXRcIlxuICAgICAgfVxuICAgIH1cbiAgKTtcbn0sIGhyID0gKHksIG0sIF8sIGIsIGgpID0+IHtcbiAgY29uc3QgdyA9IHkuZ2V0Q2hhbm5lbERhdGEoMCksIGsgPSBfIC8gKGIgKyBoKSwgaSA9IE1hdGguZmxvb3Iody5sZW5ndGggLyBrKSwgcyA9IG0gLyAyO1xuICBsZXQgZyA9IFtdLCBvID0gMDtcbiAgZm9yIChsZXQgYSA9IDA7IGEgPCBrOyBhKyspIHtcbiAgICBjb25zdCBkID0gW107XG4gICAgbGV0IEUgPSAwO1xuICAgIGNvbnN0IEMgPSBbXTtcbiAgICBsZXQgVCA9IDA7XG4gICAgZm9yIChsZXQgZiA9IDA7IGYgPCBpICYmIGEgKiBpICsgZiA8IHkubGVuZ3RoOyBmKyspIHtcbiAgICAgIGNvbnN0IGogPSB3W2EgKiBpICsgZl07XG4gICAgICBqIDw9IDAgJiYgKGQucHVzaChqKSwgRSsrKSwgaiA+IDAgJiYgKEMucHVzaChqKSwgVCsrKTtcbiAgICB9XG4gICAgY29uc3QgRCA9IGQucmVkdWNlKChmLCBqKSA9PiBmICsgaiwgMCkgLyBFLCBsID0geyBtYXg6IEMucmVkdWNlKChmLCBqKSA9PiBmICsgaiwgMCkgLyBULCBtaW46IEQgfTtcbiAgICBsLm1heCA+IG8gJiYgKG8gPSBsLm1heCksIE1hdGguYWJzKGwubWluKSA+IG8gJiYgKG8gPSBNYXRoLmFicyhsLm1pbikpLCBnLnB1c2gobCk7XG4gIH1cbiAgaWYgKHMgKiAwLjggPiBvICogcykge1xuICAgIGNvbnN0IGEgPSBzICogMC44IC8gbztcbiAgICBnID0gZy5tYXAoKGQpID0+ICh7XG4gICAgICBtYXg6IGQubWF4ICogYSxcbiAgICAgIG1pbjogZC5taW4gKiBhXG4gICAgfSkpO1xuICB9XG4gIHJldHVybiBnO1xufSwgdGUgPSAoeSwgbSwgXywgYiwgaCwgdywgaywgaSA9IDAsIHMgPSAxKSA9PiB7XG4gIGNvbnN0IGcgPSBtLmhlaWdodCAvIDIsIG8gPSBtLmdldENvbnRleHQoXCIyZFwiKTtcbiAgaWYgKCFvKVxuICAgIHJldHVybjtcbiAgby5jbGVhclJlY3QoMCwgMCwgbS53aWR0aCwgbS5oZWlnaHQpLCBoICE9PSBcInRyYW5zcGFyZW50XCIgJiYgKG8uZmlsbFN0eWxlID0gaCwgby5maWxsUmVjdCgwLCAwLCBtLndpZHRoLCBtLmhlaWdodCkpO1xuICBjb25zdCBhID0gKGkgfHwgMCkgLyBzO1xuICB5LmZvckVhY2goKGQsIEUpID0+IHtcbiAgICBjb25zdCBDID0gRSAvIHkubGVuZ3RoLCBUID0gYSA+IEM7XG4gICAgby5maWxsU3R5bGUgPSBUICYmIGsgPyBrIDogdztcbiAgICBjb25zdCBEID0gRSAqIChfICsgYiksIGwgPSBnICsgZC5taW4sIGYgPSBfLCBqID0gZyArIGQubWF4IC0gbDtcbiAgICBvLmJlZ2luUGF0aCgpLCBvLnJvdW5kUmVjdCA/IChvLnJvdW5kUmVjdChELCBsLCBmLCBqLCA1MCksIG8uZmlsbCgpKSA6IG8uZmlsbFJlY3QoRCwgbCwgZiwgaik7XG4gIH0pO1xufSwgYnIgPSBwcihcbiAgKHtcbiAgICBibG9iOiB5LFxuICAgIHdpZHRoOiBtLFxuICAgIGhlaWdodDogXyxcbiAgICBiYXJXaWR0aDogYiA9IDIsXG4gICAgZ2FwOiBoID0gMSxcbiAgICBjdXJyZW50VGltZTogdyxcbiAgICBzdHlsZTogayxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGkgPSBcInRyYW5zcGFyZW50XCIsXG4gICAgYmFyQ29sb3I6IHMgPSBcInJnYigxODQsIDE4NCwgMTg0KVwiLFxuICAgIGJhclBsYXllZENvbG9yOiBnID0gXCJyZ2IoMTYwLCAxOTgsIDI1NSlcIlxuICB9LCBvKSA9PiB7XG4gICAgY29uc3QgYSA9IERlKG51bGwpLCBbZCwgRV0gPSBZKFtdKSwgW0MsIFRdID0gWSgwKTtcbiAgICByZXR1cm4geXIoXG4gICAgICBvLFxuICAgICAgKCkgPT4gYS5jdXJyZW50LFxuICAgICAgW11cbiAgICApLCBIKCgpID0+IHtcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICghYS5jdXJyZW50KVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCF5KSB7XG4gICAgICAgICAgY29uc3QgbCA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDEwMCB9LCAoKSA9PiAoe1xuICAgICAgICAgICAgbWF4OiAwLFxuICAgICAgICAgICAgbWluOiAwXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHRlKFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGEuY3VycmVudCxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBoLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHMsXG4gICAgICAgICAgICBnXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgRCA9IGF3YWl0IHkuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgYXdhaXQgbmV3IEF1ZGlvQ29udGV4dCgpLmRlY29kZUF1ZGlvRGF0YShELCAobCkgPT4ge1xuICAgICAgICAgIGlmICghYS5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIFQobC5kdXJhdGlvbik7XG4gICAgICAgICAgY29uc3QgZiA9IGhyKFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIF8sXG4gICAgICAgICAgICBtLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGhcbiAgICAgICAgICApO1xuICAgICAgICAgIEUoZiksIHRlKFxuICAgICAgICAgICAgZixcbiAgICAgICAgICAgIGEuY3VycmVudCxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBoLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHMsXG4gICAgICAgICAgICBnXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSgpO1xuICAgIH0sIFt5LCBhLmN1cnJlbnRdKSwgSCgoKSA9PiB7XG4gICAgICBhLmN1cnJlbnQgJiYgdGUoXG4gICAgICAgIGQsXG4gICAgICAgIGEuY3VycmVudCxcbiAgICAgICAgYixcbiAgICAgICAgaCxcbiAgICAgICAgaSxcbiAgICAgICAgcyxcbiAgICAgICAgZyxcbiAgICAgICAgdyxcbiAgICAgICAgQ1xuICAgICAgKTtcbiAgICB9LCBbdywgQ10pLCAvKiBAX19QVVJFX18gKi8gJGUuanN4KFxuICAgICAgXCJjYW52YXNcIixcbiAgICAgIHtcbiAgICAgICAgcmVmOiBhLFxuICAgICAgICB3aWR0aDogbSxcbiAgICAgICAgaGVpZ2h0OiBfLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIC4uLmtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH1cbik7XG5ici5kaXNwbGF5TmFtZSA9IFwiQXVkaW9WaXN1YWxpemVyXCI7XG5leHBvcnQge1xuICBiciBhcyBBdWRpb1Zpc3VhbGl6ZXIsXG4gIFNyIGFzIExpdmVBdWRpb1Zpc3VhbGl6ZXJcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/react-audio-voice-recorder@2.2.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-audio-voice-recorder/dist/react-audio-visualize.es-69216c73.js\n"));

/***/ })

}]);