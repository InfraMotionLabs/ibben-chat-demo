"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-audio-voice-recorder@2.2.0_react-dom@18.3.1_react@18.3.1__react@18.3.1";
exports.ids = ["vendor-chunks/react-audio-voice-recorder@2.2.0_react-dom@18.3.1_react@18.3.1__react@18.3.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/react-audio-voice-recorder@2.2.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-audio-voice-recorder/dist/index-1c988149.js":
/*!************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-audio-voice-recorder@2.2.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-audio-voice-recorder/dist/index-1c988149.js ***!
  \************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   i: () => (/* binding */ qe)\n/* harmony export */ });\nfunction re(o, f) {\n  for (var s = 0; s < f.length; s++) {\n    const p = f[s];\n    if (typeof p != \"string\" && !Array.isArray(p)) {\n      for (const c in p)\n        if (c !== \"default\" && !(c in o)) {\n          const l = Object.getOwnPropertyDescriptor(p, c);\n          l && Object.defineProperty(o, c, l.get ? l : {\n            enumerable: !0,\n            get: () => p[c]\n          });\n        }\n    }\n  }\n  return Object.freeze(Object.defineProperty(o, Symbol.toStringTag, { value: \"Module\" }));\n}\nfunction oe(o) {\n  return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, \"default\") ? o.default : o;\n}\nfunction ne(o) {\n  if (o.__esModule)\n    return o;\n  var f = o.default;\n  if (typeof f == \"function\") {\n    var s = function p() {\n      if (this instanceof p) {\n        var c = [null];\n        c.push.apply(c, arguments);\n        var l = Function.bind.apply(f, c);\n        return new l();\n      }\n      return f.apply(this, arguments);\n    };\n    s.prototype = f.prototype;\n  } else\n    s = {};\n  return Object.defineProperty(s, \"__esModule\", { value: !0 }), Object.keys(o).forEach(function(p) {\n    var c = Object.getOwnPropertyDescriptor(o, p);\n    Object.defineProperty(s, p, c.get ? c : {\n      enumerable: !0,\n      get: function() {\n        return o[p];\n      }\n    });\n  }), s;\n}\nvar ie = { exports: {} };\n(function(o) {\n  var f = function(s) {\n    var p = Object.prototype, c = p.hasOwnProperty, l, j = typeof Symbol == \"function\" ? Symbol : {}, y = j.iterator || \"@@iterator\", m = j.asyncIterator || \"@@asyncIterator\", v = j.toStringTag || \"@@toStringTag\";\n    function w(t, e, r) {\n      return Object.defineProperty(t, e, {\n        value: r,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }), t[e];\n    }\n    try {\n      w({}, \"\");\n    } catch {\n      w = function(e, r, i) {\n        return e[r] = i;\n      };\n    }\n    function C(t, e, r, i) {\n      var n = e && e.prototype instanceof O ? e : O, d = Object.create(n.prototype), b = new u(i || []);\n      return d._invoke = V(t, r, b), d;\n    }\n    s.wrap = C;\n    function N(t, e, r) {\n      try {\n        return { type: \"normal\", arg: t.call(e, r) };\n      } catch (i) {\n        return { type: \"throw\", arg: i };\n      }\n    }\n    var _ = \"suspendedStart\", G = \"suspendedYield\", U = \"executing\", P = \"completed\", L = {};\n    function O() {\n    }\n    function T() {\n    }\n    function k() {\n    }\n    var D = {};\n    w(D, y, function() {\n      return this;\n    });\n    var B = Object.getPrototypeOf, M = B && B(B(h([])));\n    M && M !== p && c.call(M, y) && (D = M);\n    var $ = k.prototype = O.prototype = Object.create(D);\n    T.prototype = k, w($, \"constructor\", k), w(k, \"constructor\", T), T.displayName = w(\n      k,\n      v,\n      \"GeneratorFunction\"\n    );\n    function Y(t) {\n      [\"next\", \"throw\", \"return\"].forEach(function(e) {\n        w(t, e, function(r) {\n          return this._invoke(e, r);\n        });\n      });\n    }\n    s.isGeneratorFunction = function(t) {\n      var e = typeof t == \"function\" && t.constructor;\n      return e ? e === T || // For the native GeneratorFunction constructor, the best we can\n      // do is to check its .name property.\n      (e.displayName || e.name) === \"GeneratorFunction\" : !1;\n    }, s.mark = function(t) {\n      return Object.setPrototypeOf ? Object.setPrototypeOf(t, k) : (t.__proto__ = k, w(t, v, \"GeneratorFunction\")), t.prototype = Object.create($), t;\n    }, s.awrap = function(t) {\n      return { __await: t };\n    };\n    function I(t, e) {\n      function r(d, b, F, S) {\n        var E = N(t[d], t, b);\n        if (E.type === \"throw\")\n          S(E.arg);\n        else {\n          var H = E.arg, z = H.value;\n          return z && typeof z == \"object\" && c.call(z, \"__await\") ? e.resolve(z.__await).then(function(R) {\n            r(\"next\", R, F, S);\n          }, function(R) {\n            r(\"throw\", R, F, S);\n          }) : e.resolve(z).then(function(R) {\n            H.value = R, F(H);\n          }, function(R) {\n            return r(\"throw\", R, F, S);\n          });\n        }\n      }\n      var i;\n      function n(d, b) {\n        function F() {\n          return new e(function(S, E) {\n            r(d, b, S, E);\n          });\n        }\n        return i = // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        i ? i.then(\n          F,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          F\n        ) : F();\n      }\n      this._invoke = n;\n    }\n    Y(I.prototype), w(I.prototype, m, function() {\n      return this;\n    }), s.AsyncIterator = I, s.async = function(t, e, r, i, n) {\n      n === void 0 && (n = Promise);\n      var d = new I(\n        C(t, e, r, i),\n        n\n      );\n      return s.isGeneratorFunction(e) ? d : d.next().then(function(b) {\n        return b.done ? b.value : d.next();\n      });\n    };\n    function V(t, e, r) {\n      var i = _;\n      return function(d, b) {\n        if (i === U)\n          throw new Error(\"Generator is already running\");\n        if (i === P) {\n          if (d === \"throw\")\n            throw b;\n          return g();\n        }\n        for (r.method = d, r.arg = b; ; ) {\n          var F = r.delegate;\n          if (F) {\n            var S = q(F, r);\n            if (S) {\n              if (S === L)\n                continue;\n              return S;\n            }\n          }\n          if (r.method === \"next\")\n            r.sent = r._sent = r.arg;\n          else if (r.method === \"throw\") {\n            if (i === _)\n              throw i = P, r.arg;\n            r.dispatchException(r.arg);\n          } else\n            r.method === \"return\" && r.abrupt(\"return\", r.arg);\n          i = U;\n          var E = N(t, e, r);\n          if (E.type === \"normal\") {\n            if (i = r.done ? P : G, E.arg === L)\n              continue;\n            return {\n              value: E.arg,\n              done: r.done\n            };\n          } else\n            E.type === \"throw\" && (i = P, r.method = \"throw\", r.arg = E.arg);\n        }\n      };\n    }\n    function q(t, e) {\n      var r = t.iterator[e.method];\n      if (r === l) {\n        if (e.delegate = null, e.method === \"throw\") {\n          if (t.iterator.return && (e.method = \"return\", e.arg = l, q(t, e), e.method === \"throw\"))\n            return L;\n          e.method = \"throw\", e.arg = new TypeError(\n            \"The iterator does not provide a 'throw' method\"\n          );\n        }\n        return L;\n      }\n      var i = N(r, t.iterator, e.arg);\n      if (i.type === \"throw\")\n        return e.method = \"throw\", e.arg = i.arg, e.delegate = null, L;\n      var n = i.arg;\n      if (!n)\n        return e.method = \"throw\", e.arg = new TypeError(\"iterator result is not an object\"), e.delegate = null, L;\n      if (n.done)\n        e[t.resultName] = n.value, e.next = t.nextLoc, e.method !== \"return\" && (e.method = \"next\", e.arg = l);\n      else\n        return n;\n      return e.delegate = null, L;\n    }\n    Y($), w($, v, \"Generator\"), w($, y, function() {\n      return this;\n    }), w($, \"toString\", function() {\n      return \"[object Generator]\";\n    });\n    function x(t) {\n      var e = { tryLoc: t[0] };\n      1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);\n    }\n    function a(t) {\n      var e = t.completion || {};\n      e.type = \"normal\", delete e.arg, t.completion = e;\n    }\n    function u(t) {\n      this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(x, this), this.reset(!0);\n    }\n    s.keys = function(t) {\n      var e = [];\n      for (var r in t)\n        e.push(r);\n      return e.reverse(), function i() {\n        for (; e.length; ) {\n          var n = e.pop();\n          if (n in t)\n            return i.value = n, i.done = !1, i;\n        }\n        return i.done = !0, i;\n      };\n    };\n    function h(t) {\n      if (t) {\n        var e = t[y];\n        if (e)\n          return e.call(t);\n        if (typeof t.next == \"function\")\n          return t;\n        if (!isNaN(t.length)) {\n          var r = -1, i = function n() {\n            for (; ++r < t.length; )\n              if (c.call(t, r))\n                return n.value = t[r], n.done = !1, n;\n            return n.value = l, n.done = !0, n;\n          };\n          return i.next = i;\n        }\n      }\n      return { next: g };\n    }\n    s.values = h;\n    function g() {\n      return { value: l, done: !0 };\n    }\n    return u.prototype = {\n      constructor: u,\n      reset: function(t) {\n        if (this.prev = 0, this.next = 0, this.sent = this._sent = l, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = l, this.tryEntries.forEach(a), !t)\n          for (var e in this)\n            e.charAt(0) === \"t\" && c.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = l);\n      },\n      stop: function() {\n        this.done = !0;\n        var t = this.tryEntries[0], e = t.completion;\n        if (e.type === \"throw\")\n          throw e.arg;\n        return this.rval;\n      },\n      dispatchException: function(t) {\n        if (this.done)\n          throw t;\n        var e = this;\n        function r(S, E) {\n          return d.type = \"throw\", d.arg = t, e.next = S, E && (e.method = \"next\", e.arg = l), !!E;\n        }\n        for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n          var n = this.tryEntries[i], d = n.completion;\n          if (n.tryLoc === \"root\")\n            return r(\"end\");\n          if (n.tryLoc <= this.prev) {\n            var b = c.call(n, \"catchLoc\"), F = c.call(n, \"finallyLoc\");\n            if (b && F) {\n              if (this.prev < n.catchLoc)\n                return r(n.catchLoc, !0);\n              if (this.prev < n.finallyLoc)\n                return r(n.finallyLoc);\n            } else if (b) {\n              if (this.prev < n.catchLoc)\n                return r(n.catchLoc, !0);\n            } else if (F) {\n              if (this.prev < n.finallyLoc)\n                return r(n.finallyLoc);\n            } else\n              throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      },\n      abrupt: function(t, e) {\n        for (var r = this.tryEntries.length - 1; r >= 0; --r) {\n          var i = this.tryEntries[r];\n          if (i.tryLoc <= this.prev && c.call(i, \"finallyLoc\") && this.prev < i.finallyLoc) {\n            var n = i;\n            break;\n          }\n        }\n        n && (t === \"break\" || t === \"continue\") && n.tryLoc <= e && e <= n.finallyLoc && (n = null);\n        var d = n ? n.completion : {};\n        return d.type = t, d.arg = e, n ? (this.method = \"next\", this.next = n.finallyLoc, L) : this.complete(d);\n      },\n      complete: function(t, e) {\n        if (t.type === \"throw\")\n          throw t.arg;\n        return t.type === \"break\" || t.type === \"continue\" ? this.next = t.arg : t.type === \"return\" ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : t.type === \"normal\" && e && (this.next = e), L;\n      },\n      finish: function(t) {\n        for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n          var r = this.tryEntries[e];\n          if (r.finallyLoc === t)\n            return this.complete(r.completion, r.afterLoc), a(r), L;\n        }\n      },\n      catch: function(t) {\n        for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n          var r = this.tryEntries[e];\n          if (r.tryLoc === t) {\n            var i = r.completion;\n            if (i.type === \"throw\") {\n              var n = i.arg;\n              a(r);\n            }\n            return n;\n          }\n        }\n        throw new Error(\"illegal catch attempt\");\n      },\n      delegateYield: function(t, e, r) {\n        return this.delegate = {\n          iterator: h(t),\n          resultName: e,\n          nextLoc: r\n        }, this.method === \"next\" && (this.arg = l), L;\n      }\n    }, s;\n  }(\n    // If this script is executing as a CommonJS module, use module.exports\n    // as the regeneratorRuntime namespace. Otherwise create a new empty\n    // object. Either way, the resulting object will be used to initialize\n    // the regeneratorRuntime variable at the top of this file.\n    o.exports\n  );\n  try {\n    regeneratorRuntime = f;\n  } catch {\n    typeof globalThis == \"object\" ? globalThis.regeneratorRuntime = f : Function(\"r\", \"regeneratorRuntime = r\")(f);\n  }\n})(ie);\nvar ae = {\n  defaultArgs: [\n    /* args[0] is always the binary path */\n    \"./ffmpeg\",\n    /* Disable interaction mode */\n    \"-nostdin\",\n    /* Force to override output file */\n    \"-y\"\n  ],\n  baseOptions: {\n    /* Flag to turn on/off log messages in console */\n    log: !1,\n    /*\n     * Custom logger to get ffmpeg.wasm output messages.\n     * a sample logger looks like this:\n     *\n     * ```\n     * logger = ({ type, message }) => {\n     *   console.log(type, message);\n     * }\n     * ```\n     *\n     * type can be one of following:\n     *\n     * info: internal workflow debug messages\n     * fferr: ffmpeg native stderr output\n     * ffout: ffmpeg native stdout output\n     */\n    logger: () => {\n    },\n    /*\n     * Progress handler to get current progress of ffmpeg command.\n     * a sample progress handler looks like this:\n     *\n     * ```\n     * progress = ({ ratio }) => {\n     *   console.log(ratio);\n     * }\n     * ```\n     *\n     * ratio is a float number between 0 to 1.\n     */\n    progress: () => {\n    },\n    /*\n     * Path to find/download ffmpeg.wasm-core,\n     * this value should be overwriten by `defaultOptions` in\n     * each environment.\n     */\n    corePath: \"\"\n  }\n}, se = (o, f) => {\n  const s = o._malloc(f.length * Uint32Array.BYTES_PER_ELEMENT);\n  return f.forEach((p, c) => {\n    const l = o.lengthBytesUTF8(p) + 1, j = o._malloc(l);\n    o.stringToUTF8(p, j, l), o.setValue(s + Uint32Array.BYTES_PER_ELEMENT * c, j, \"i32\");\n  }), [f.length, s];\n};\nconst fe = \"@ffmpeg/ffmpeg\", ce = \"0.11.6\", le = \"FFmpeg WebAssembly version\", pe = \"src/index.js\", ue = \"src/index.d.ts\", he = {\n  example: \"examples\"\n}, de = {\n  start: \"node scripts/server.js\",\n  \"start:worker\": \"node scripts/worker-server.js\",\n  build: \"rimraf dist && webpack --config scripts/webpack.config.prod.js\",\n  \"build:worker\": \"rimraf dist && webpack --config scripts/webpack.config.worker.prod.js\",\n  prepublishOnly: \"npm run build\",\n  lint: \"eslint src\",\n  wait: \"rimraf dist && wait-on http://localhost:3000/dist/ffmpeg.dev.js\",\n  test: \"npm-run-all -p -r start test:all\",\n  \"test:all\": \"npm-run-all wait test:browser:ffmpeg test:node:all\",\n  \"test:node\": \"node node_modules/mocha/bin/_mocha --exit --bail --require ./scripts/test-helper.js\",\n  \"test:node:all\": \"npm run test:node -- ./tests/*.test.js\",\n  \"test:browser\": \"mocha-headless-chrome -a allow-file-access-from-files -a incognito -a no-sandbox -a disable-setuid-sandbox -a disable-logging -t 300000\",\n  \"test:browser:ffmpeg\": \"npm run test:browser -- -f ./tests/ffmpeg.test.html\"\n}, me = {\n  \"./src/node/index.js\": \"./src/browser/index.js\"\n}, ge = {\n  type: \"git\",\n  url: \"git+https://github.com/ffmpegwasm/ffmpeg.wasm.git\"\n}, we = [\n  \"ffmpeg\",\n  \"WebAssembly\",\n  \"video\"\n], ye = \"Jerome Wu <jeromewus@gmail.com>\", ve = \"MIT\", be = {\n  url: \"https://github.com/ffmpegwasm/ffmpeg.wasm/issues\"\n}, Fe = {\n  node: \">=12.16.1\"\n}, Ee = \"https://github.com/ffmpegwasm/ffmpeg.wasm#readme\", je = {\n  \"is-url\": \"^1.2.4\",\n  \"node-fetch\": \"^2.6.1\",\n  \"regenerator-runtime\": \"^0.13.7\",\n  \"resolve-url\": \"^0.2.1\"\n}, Le = {\n  \"@babel/core\": \"^7.12.3\",\n  \"@babel/preset-env\": \"^7.12.1\",\n  \"@ffmpeg/core\": \"^0.11.0\",\n  \"@types/emscripten\": \"^1.39.4\",\n  \"babel-eslint\": \"^10.1.0\",\n  \"babel-loader\": \"^8.1.0\",\n  chai: \"^4.2.0\",\n  cors: \"^2.8.5\",\n  eslint: \"^7.12.1\",\n  \"eslint-config-airbnb-base\": \"^14.1.0\",\n  \"eslint-plugin-import\": \"^2.22.1\",\n  express: \"^4.17.1\",\n  mocha: \"^8.2.1\",\n  \"mocha-headless-chrome\": \"^2.0.3\",\n  \"npm-run-all\": \"^4.1.5\",\n  \"wait-on\": \"^5.3.0\",\n  webpack: \"^5.3.2\",\n  \"webpack-cli\": \"^4.1.0\",\n  \"webpack-dev-middleware\": \"^4.0.0\"\n}, Q = {\n  name: fe,\n  version: ce,\n  description: le,\n  main: pe,\n  types: ue,\n  directories: he,\n  scripts: de,\n  browser: me,\n  repository: ge,\n  keywords: we,\n  author: ye,\n  license: ve,\n  bugs: be,\n  engines: Fe,\n  homepage: Ee,\n  dependencies: je,\n  devDependencies: Le\n}, Oe = typeof process < \"u\" && \"development\" === \"development\" ? new URL(\"/node_modules/@ffmpeg/core/dist/ffmpeg-core.js\", self.location).href : `https://unpkg.com/@ffmpeg/core@${Q.devDependencies[\"@ffmpeg/core\"].substring(1)}/dist/ffmpeg-core.js`, Se = { corePath: Oe };\nlet Z = !1, X = () => {\n};\nconst _e = (o) => {\n  Z = o;\n}, Pe = (o) => {\n  X = o;\n}, ke = (o, f) => {\n  X({ type: o, message: f }), Z && console.log(`[${o}] ${f}`);\n};\nvar A = {\n  logging: Z,\n  setLogging: _e,\n  setCustomLogger: Pe,\n  log: ke\n};\nconst $e = (o) => `\ncreateFFmpegCore is not defined. ffmpeg.wasm is unable to find createFFmpegCore after loading ffmpeg-core.js from ${o}. Use another URL when calling createFFmpeg():\n\nconst ffmpeg = createFFmpeg({\n  corePath: 'http://localhost:3000/ffmpeg-core.js',\n});\n`;\nvar K = {\n  CREATE_FFMPEG_CORE_IS_NOT_DEFINED: $e\n};\nconst W = async (o, f) => {\n  A.log(\"info\", `fetch ${o}`);\n  const s = await (await fetch(o)).arrayBuffer();\n  A.log(\"info\", `${o} file size = ${s.byteLength} bytes`);\n  const p = new Blob([s], { type: f }), c = URL.createObjectURL(p);\n  return A.log(\"info\", `${o} blob URL = ${c}`), c;\n}, Ce = async ({\n  corePath: o,\n  workerPath: f,\n  wasmPath: s\n}) => {\n  if (typeof WorkerGlobalScope < \"u\" && self instanceof WorkerGlobalScope) {\n    if (typeof o != \"string\")\n      throw Error(\"corePath should be a string!\");\n    const y = new URL(o, \"file:///Users/sznehan/Desktop/projects/ibben/node_modules/.pnpm/react-audio-voice-recorder@2.2.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-audio-voice-recorder/dist/index-1c988149.js\").href, m = await W(\n      y,\n      \"application/javascript\"\n    ), v = await W(\n      s !== void 0 ? s : y.replace(\"ffmpeg-core.js\", \"ffmpeg-core.wasm\"),\n      \"application/wasm\"\n    ), w = await W(\n      f !== void 0 ? f : y.replace(\"ffmpeg-core.js\", \"ffmpeg-core.worker.js\"),\n      \"application/javascript\"\n    );\n    return typeof createFFmpegCore > \"u\" ? new Promise((C) => {\n      if (globalThis.importScripts(m), typeof createFFmpegCore > \"u\")\n        throw Error(K.CREATE_FFMPEG_CORE_IS_NOT_DEFINED(y));\n      A.log(\"info\", \"ffmpeg-core.js script loaded\"), C({\n        createFFmpegCore,\n        corePath: m,\n        wasmPath: v,\n        workerPath: w\n      });\n    }) : (A.log(\"info\", \"ffmpeg-core.js script is loaded already\"), Promise.resolve({\n      createFFmpegCore,\n      corePath: m,\n      wasmPath: v,\n      workerPath: w\n    }));\n  }\n  if (typeof o != \"string\")\n    throw Error(\"corePath should be a string!\");\n  const p = new URL(o, \"file:///Users/sznehan/Desktop/projects/ibben/node_modules/.pnpm/react-audio-voice-recorder@2.2.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-audio-voice-recorder/dist/index-1c988149.js\").href, c = await W(\n    p,\n    \"application/javascript\"\n  ), l = await W(\n    s !== void 0 ? s : p.replace(\"ffmpeg-core.js\", \"ffmpeg-core.wasm\"),\n    \"application/wasm\"\n  ), j = await W(\n    f !== void 0 ? f : p.replace(\"ffmpeg-core.js\", \"ffmpeg-core.worker.js\"),\n    \"application/javascript\"\n  );\n  return typeof createFFmpegCore > \"u\" ? new Promise((y) => {\n    const m = document.createElement(\"script\"), v = () => {\n      if (m.removeEventListener(\"load\", v), typeof createFFmpegCore > \"u\")\n        throw Error(K.CREATE_FFMPEG_CORE_IS_NOT_DEFINED(p));\n      A.log(\"info\", \"ffmpeg-core.js script loaded\"), y({\n        createFFmpegCore,\n        corePath: c,\n        wasmPath: l,\n        workerPath: j\n      });\n    };\n    m.src = c, m.type = \"text/javascript\", m.addEventListener(\"load\", v), document.getElementsByTagName(\"head\")[0].appendChild(m);\n  }) : (A.log(\"info\", \"ffmpeg-core.js script is loaded already\"), Promise.resolve({\n    createFFmpegCore,\n    corePath: c,\n    wasmPath: l,\n    workerPath: j\n  }));\n}, Te = (o) => new Promise((f, s) => {\n  const p = new FileReader();\n  p.onload = () => {\n    f(p.result);\n  }, p.onerror = ({ target: { error: { code: c } } }) => {\n    s(Error(`File could not be read! Code=${c}`));\n  }, p.readAsArrayBuffer(o);\n}), Re = async (o) => {\n  let f = o;\n  return typeof o > \"u\" ? new Uint8Array() : (typeof o == \"string\" ? /data:_data\\/([a-zA-Z]*);base64,([^\"]*)/.test(o) ? f = atob(o.split(\",\")[1]).split(\"\").map((s) => s.charCodeAt(0)) : f = await (await fetch(new URL(o, \"file:///Users/sznehan/Desktop/projects/ibben/node_modules/.pnpm/react-audio-voice-recorder@2.2.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-audio-voice-recorder/dist/index-1c988149.js\").href)).arrayBuffer() : (o instanceof File || o instanceof Blob) && (f = await Te(o)), new Uint8Array(f));\n}, Ae = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  defaultOptions: Se,\n  fetchFile: Re,\n  getCreateFFmpegCore: Ce\n}, Symbol.toStringTag, { value: \"Module\" })), ee = /* @__PURE__ */ ne(Ae), { defaultArgs: Ne, baseOptions: Ge } = ae, Ue = se, { defaultOptions: De, getCreateFFmpegCore: Me } = ee, { version: Ie } = Q, J = Error(\"ffmpeg.wasm is not ready, make sure you have completed load().\");\nvar We = (o = {}) => {\n  const {\n    log: f,\n    logger: s,\n    progress: p,\n    ...c\n  } = {\n    ...Ge,\n    ...De,\n    ...o\n  };\n  let l = null, j = null, y = null, m = null, v = !1, w = () => {\n  }, C = f, N = p, _ = 0, G = 0, U = !1, P = 0;\n  const L = (a) => {\n    a === \"FFMPEG_END\" && y !== null && (y(), y = null, m = null, v = !1);\n  }, O = (a, u) => {\n    w({ type: a, message: u }), C && console.log(`[${a}] ${u}`);\n  }, T = (a) => {\n    const [u, h, g] = a.split(\":\");\n    return parseFloat(u) * 60 * 60 + parseFloat(h) * 60 + parseFloat(g);\n  }, k = (a, u) => {\n    if (typeof a == \"string\")\n      if (a.startsWith(\"  Duration\")) {\n        const h = a.split(\", \")[0].split(\": \")[1], g = T(h);\n        u({ duration: g, ratio: P }), (_ === 0 || _ > g) && (_ = g, U = !0);\n      } else if (U && a.startsWith(\"    Stream\")) {\n        const h = a.match(/([\\d.]+) fps/);\n        if (h) {\n          const g = parseFloat(h[1]);\n          G = _ * g;\n        } else\n          G = 0;\n        U = !1;\n      } else if (a.startsWith(\"frame\") || a.startsWith(\"size\")) {\n        const h = a.split(\"time=\")[1].split(\" \")[0], g = T(h), t = a.match(/frame=\\s*(\\d+)/);\n        if (G && t) {\n          const e = parseFloat(t[1]);\n          P = Math.min(e / G, 1);\n        } else\n          P = g / _;\n        u({ ratio: P, time: g });\n      } else\n        a.startsWith(\"video:\") && (u({ ratio: 1 }), _ = 0);\n  }, D = ({ type: a, message: u }) => {\n    O(a, u), k(u, N), L(u);\n  }, B = async () => {\n    if (O(\"info\", \"load ffmpeg-core\"), l === null) {\n      O(\"info\", \"loading ffmpeg-core\");\n      const {\n        createFFmpegCore: a,\n        corePath: u,\n        workerPath: h,\n        wasmPath: g\n      } = await Me(c);\n      l = await a({\n        /*\n         * Assign mainScriptUrlOrBlob fixes chrome extension web worker issue\n         * as there is no document.currentScript in the context of content_scripts\n         */\n        mainScriptUrlOrBlob: u,\n        printErr: (t) => D({ type: \"fferr\", message: t }),\n        print: (t) => D({ type: \"ffout\", message: t }),\n        /*\n         * locateFile overrides paths of files that is loaded by main script (ffmpeg-core.js).\n         * It is critical for browser environment and we override both wasm and worker paths\n         * as we are using blob URL instead of original URL to avoid cross origin issues.\n         */\n        locateFile: (t, e) => {\n          if (typeof window < \"u\" || typeof WorkerGlobalScope < \"u\") {\n            if (typeof g < \"u\" && t.endsWith(\"ffmpeg-core.wasm\"))\n              return g;\n            if (typeof h < \"u\" && t.endsWith(\"ffmpeg-core.worker.js\"))\n              return h;\n          }\n          return e + t;\n        }\n      }), j = l.cwrap(c.mainName || \"proxy_main\", \"number\", [\"number\", \"number\"]), O(\"info\", \"ffmpeg-core loaded\");\n    } else\n      throw Error(\"ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.\");\n  }, M = () => l !== null, $ = (...a) => {\n    if (O(\"info\", `run ffmpeg command: ${a.join(\" \")}`), l === null)\n      throw J;\n    if (v)\n      throw Error(\"ffmpeg.wasm can only run one command at a time\");\n    return v = !0, new Promise((u, h) => {\n      const g = [...Ne, ...a].filter((t) => t.length !== 0);\n      y = u, m = h, j(...Ue(l, g));\n    });\n  }, Y = (a, ...u) => {\n    if (O(\"info\", `run FS.${a} ${u.map((h) => typeof h == \"string\" ? h : `<${h.length} bytes binary file>`).join(\" \")}`), l === null)\n      throw J;\n    {\n      let h = null;\n      try {\n        h = l.FS[a](...u);\n      } catch {\n        throw Error(a === \"readdir\" ? `ffmpeg.FS('readdir', '${u[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')` : a === \"readFile\" ? `ffmpeg.FS('readFile', '${u[0]}') error. Check if the path exists` : \"Oops, something went wrong in FS operation.\");\n      }\n      return h;\n    }\n  }, I = () => {\n    if (l === null)\n      throw J;\n    m && m(\"ffmpeg has exited\"), v = !1;\n    try {\n      l.exit(1);\n    } catch (a) {\n      O(a.message), m && m(a);\n    } finally {\n      l = null, j = null, y = null, m = null;\n    }\n  }, V = (a) => {\n    N = a;\n  }, q = (a) => {\n    w = a;\n  }, x = (a) => {\n    C = a;\n  };\n  return O(\"info\", `use ffmpeg.wasm v${Ie}`), {\n    setProgress: V,\n    setLogger: q,\n    setLogging: x,\n    load: B,\n    isLoaded: M,\n    run: $,\n    exit: I,\n    FS: Y\n  };\n};\nconst Be = We, { fetchFile: ze } = ee;\nvar te = {\n  /*\n   * Create ffmpeg instance.\n   * Each ffmpeg instance owns an isolated MEMFS and works\n   * independently.\n   *\n   * For example:\n   *\n   * ```\n   * const ffmpeg = createFFmpeg({\n   *  log: true,\n   *  logger: () => {},\n   *  progress: () => {},\n   *  corePath: '',\n   * })\n   * ```\n   *\n   * For the usage of these four arguments, check config.js\n   *\n   */\n  createFFmpeg: Be,\n  /*\n   * Helper function for fetching files from various resource.\n   * Sometimes the video/audio file you want to process may located\n   * in a remote URL and somewhere in your local file system.\n   *\n   * This helper function helps you to fetch to file and return an\n   * Uint8Array variable for ffmpeg.wasm to consume.\n   *\n   */\n  fetchFile: ze\n};\nconst Ye = /* @__PURE__ */ oe(te), qe = /* @__PURE__ */ re({\n  __proto__: null,\n  default: Ye\n}, [te]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtYXVkaW8tdm9pY2UtcmVjb3JkZXJAMi4yLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvcmVhY3QtYXVkaW8tdm9pY2UtcmVjb3JkZXIvZGlzdC9pbmRleC0xYzk4ODE0OS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxpQkFBaUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxrREFBa0QsV0FBVztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxvR0FBb0c7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsUUFBUTtBQUNSLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0ws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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFHQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lubm92YV9jaGF0Ym90Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWF1ZGlvLXZvaWNlLXJlY29yZGVyQDIuMi4wX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjEvbm9kZV9tb2R1bGVzL3JlYWN0LWF1ZGlvLXZvaWNlLXJlY29yZGVyL2Rpc3QvaW5kZXgtMWM5ODgxNDkuanM/NTBhZiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiByZShvLCBmKSB7XG4gIGZvciAodmFyIHMgPSAwOyBzIDwgZi5sZW5ndGg7IHMrKykge1xuICAgIGNvbnN0IHAgPSBmW3NdO1xuICAgIGlmICh0eXBlb2YgcCAhPSBcInN0cmluZ1wiICYmICFBcnJheS5pc0FycmF5KHApKSB7XG4gICAgICBmb3IgKGNvbnN0IGMgaW4gcClcbiAgICAgICAgaWYgKGMgIT09IFwiZGVmYXVsdFwiICYmICEoYyBpbiBvKSkge1xuICAgICAgICAgIGNvbnN0IGwgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHAsIGMpO1xuICAgICAgICAgIGwgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGMsIGwuZ2V0ID8gbCA6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiBwW2NdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSk7XG59XG5mdW5jdGlvbiBvZShvKSB7XG4gIHJldHVybiBvICYmIG8uX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgXCJkZWZhdWx0XCIpID8gby5kZWZhdWx0IDogbztcbn1cbmZ1bmN0aW9uIG5lKG8pIHtcbiAgaWYgKG8uX19lc01vZHVsZSlcbiAgICByZXR1cm4gbztcbiAgdmFyIGYgPSBvLmRlZmF1bHQ7XG4gIGlmICh0eXBlb2YgZiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgcyA9IGZ1bmN0aW9uIHAoKSB7XG4gICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIHApIHtcbiAgICAgICAgdmFyIGMgPSBbbnVsbF07XG4gICAgICAgIGMucHVzaC5hcHBseShjLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgbCA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoZiwgYyk7XG4gICAgICAgIHJldHVybiBuZXcgbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIHMucHJvdG90eXBlID0gZi5wcm90b3R5cGU7XG4gIH0gZWxzZVxuICAgIHMgPSB7fTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgIHZhciBjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvLCBwKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocywgcCwgYy5nZXQgPyBjIDoge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gb1twXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSksIHM7XG59XG52YXIgaWUgPSB7IGV4cG9ydHM6IHt9IH07XG4oZnVuY3Rpb24obykge1xuICB2YXIgZiA9IGZ1bmN0aW9uKHMpIHtcbiAgICB2YXIgcCA9IE9iamVjdC5wcm90b3R5cGUsIGMgPSBwLmhhc093blByb3BlcnR5LCBsLCBqID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fSwgeSA9IGouaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCIsIG0gPSBqLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIiwgdiA9IGoudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG4gICAgZnVuY3Rpb24gdyh0LCBlLCByKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIGUsIHtcbiAgICAgICAgdmFsdWU6IHIsXG4gICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICB3cml0YWJsZTogITBcbiAgICAgIH0pLCB0W2VdO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgdyh7fSwgXCJcIik7XG4gICAgfSBjYXRjaCB7XG4gICAgICB3ID0gZnVuY3Rpb24oZSwgciwgaSkge1xuICAgICAgICByZXR1cm4gZVtyXSA9IGk7XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBDKHQsIGUsIHIsIGkpIHtcbiAgICAgIHZhciBuID0gZSAmJiBlLnByb3RvdHlwZSBpbnN0YW5jZW9mIE8gPyBlIDogTywgZCA9IE9iamVjdC5jcmVhdGUobi5wcm90b3R5cGUpLCBiID0gbmV3IHUoaSB8fCBbXSk7XG4gICAgICByZXR1cm4gZC5faW52b2tlID0gVih0LCByLCBiKSwgZDtcbiAgICB9XG4gICAgcy53cmFwID0gQztcbiAgICBmdW5jdGlvbiBOKHQsIGUsIHIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogdC5jYWxsKGUsIHIpIH07XG4gICAgICB9IGNhdGNoIChpKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBpIH07XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBfID0gXCJzdXNwZW5kZWRTdGFydFwiLCBHID0gXCJzdXNwZW5kZWRZaWVsZFwiLCBVID0gXCJleGVjdXRpbmdcIiwgUCA9IFwiY29tcGxldGVkXCIsIEwgPSB7fTtcbiAgICBmdW5jdGlvbiBPKCkge1xuICAgIH1cbiAgICBmdW5jdGlvbiBUKCkge1xuICAgIH1cbiAgICBmdW5jdGlvbiBrKCkge1xuICAgIH1cbiAgICB2YXIgRCA9IHt9O1xuICAgIHcoRCwgeSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgICB2YXIgQiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiwgTSA9IEIgJiYgQihCKGgoW10pKSk7XG4gICAgTSAmJiBNICE9PSBwICYmIGMuY2FsbChNLCB5KSAmJiAoRCA9IE0pO1xuICAgIHZhciAkID0gay5wcm90b3R5cGUgPSBPLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRCk7XG4gICAgVC5wcm90b3R5cGUgPSBrLCB3KCQsIFwiY29uc3RydWN0b3JcIiwgayksIHcoaywgXCJjb25zdHJ1Y3RvclwiLCBUKSwgVC5kaXNwbGF5TmFtZSA9IHcoXG4gICAgICBrLFxuICAgICAgdixcbiAgICAgIFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICk7XG4gICAgZnVuY3Rpb24gWSh0KSB7XG4gICAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgICAgIHcodCwgZSwgZnVuY3Rpb24ocikge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UoZSwgcik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBlID0gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiICYmIHQuY29uc3RydWN0b3I7XG4gICAgICByZXR1cm4gZSA/IGUgPT09IFQgfHwgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgKGUuZGlzcGxheU5hbWUgfHwgZS5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiIDogITE7XG4gICAgfSwgcy5tYXJrID0gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZih0LCBrKSA6ICh0Ll9fcHJvdG9fXyA9IGssIHcodCwgdiwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksIHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSgkKSwgdDtcbiAgICB9LCBzLmF3cmFwID0gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIHsgX19hd2FpdDogdCB9O1xuICAgIH07XG4gICAgZnVuY3Rpb24gSSh0LCBlKSB7XG4gICAgICBmdW5jdGlvbiByKGQsIGIsIEYsIFMpIHtcbiAgICAgICAgdmFyIEUgPSBOKHRbZF0sIHQsIGIpO1xuICAgICAgICBpZiAoRS50eXBlID09PSBcInRocm93XCIpXG4gICAgICAgICAgUyhFLmFyZyk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBIID0gRS5hcmcsIHogPSBILnZhbHVlO1xuICAgICAgICAgIHJldHVybiB6ICYmIHR5cGVvZiB6ID09IFwib2JqZWN0XCIgJiYgYy5jYWxsKHosIFwiX19hd2FpdFwiKSA/IGUucmVzb2x2ZSh6Ll9fYXdhaXQpLnRoZW4oZnVuY3Rpb24oUikge1xuICAgICAgICAgICAgcihcIm5leHRcIiwgUiwgRiwgUyk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oUikge1xuICAgICAgICAgICAgcihcInRocm93XCIsIFIsIEYsIFMpO1xuICAgICAgICAgIH0pIDogZS5yZXNvbHZlKHopLnRoZW4oZnVuY3Rpb24oUikge1xuICAgICAgICAgICAgSC52YWx1ZSA9IFIsIEYoSCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oUikge1xuICAgICAgICAgICAgcmV0dXJuIHIoXCJ0aHJvd1wiLCBSLCBGLCBTKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGk7XG4gICAgICBmdW5jdGlvbiBuKGQsIGIpIHtcbiAgICAgICAgZnVuY3Rpb24gRigpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IGUoZnVuY3Rpb24oUywgRSkge1xuICAgICAgICAgICAgcihkLCBiLCBTLCBFKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaSA9IC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBpID8gaS50aGVuKFxuICAgICAgICAgIEYsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgRlxuICAgICAgICApIDogRigpO1xuICAgICAgfVxuICAgICAgdGhpcy5faW52b2tlID0gbjtcbiAgICB9XG4gICAgWShJLnByb3RvdHlwZSksIHcoSS5wcm90b3R5cGUsIG0sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSksIHMuQXN5bmNJdGVyYXRvciA9IEksIHMuYXN5bmMgPSBmdW5jdGlvbih0LCBlLCByLCBpLCBuKSB7XG4gICAgICBuID09PSB2b2lkIDAgJiYgKG4gPSBQcm9taXNlKTtcbiAgICAgIHZhciBkID0gbmV3IEkoXG4gICAgICAgIEModCwgZSwgciwgaSksXG4gICAgICAgIG5cbiAgICAgICk7XG4gICAgICByZXR1cm4gcy5pc0dlbmVyYXRvckZ1bmN0aW9uKGUpID8gZCA6IGQubmV4dCgpLnRoZW4oZnVuY3Rpb24oYikge1xuICAgICAgICByZXR1cm4gYi5kb25lID8gYi52YWx1ZSA6IGQubmV4dCgpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBWKHQsIGUsIHIpIHtcbiAgICAgIHZhciBpID0gXztcbiAgICAgIHJldHVybiBmdW5jdGlvbihkLCBiKSB7XG4gICAgICAgIGlmIChpID09PSBVKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICAgIGlmIChpID09PSBQKSB7XG4gICAgICAgICAgaWYgKGQgPT09IFwidGhyb3dcIilcbiAgICAgICAgICAgIHRocm93IGI7XG4gICAgICAgICAgcmV0dXJuIGcoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHIubWV0aG9kID0gZCwgci5hcmcgPSBiOyA7ICkge1xuICAgICAgICAgIHZhciBGID0gci5kZWxlZ2F0ZTtcbiAgICAgICAgICBpZiAoRikge1xuICAgICAgICAgICAgdmFyIFMgPSBxKEYsIHIpO1xuICAgICAgICAgICAgaWYgKFMpIHtcbiAgICAgICAgICAgICAgaWYgKFMgPT09IEwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIHJldHVybiBTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoci5tZXRob2QgPT09IFwibmV4dFwiKVxuICAgICAgICAgICAgci5zZW50ID0gci5fc2VudCA9IHIuYXJnO1xuICAgICAgICAgIGVsc2UgaWYgKHIubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIGlmIChpID09PSBfKVxuICAgICAgICAgICAgICB0aHJvdyBpID0gUCwgci5hcmc7XG4gICAgICAgICAgICByLmRpc3BhdGNoRXhjZXB0aW9uKHIuYXJnKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHIubWV0aG9kID09PSBcInJldHVyblwiICYmIHIuYWJydXB0KFwicmV0dXJuXCIsIHIuYXJnKTtcbiAgICAgICAgICBpID0gVTtcbiAgICAgICAgICB2YXIgRSA9IE4odCwgZSwgcik7XG4gICAgICAgICAgaWYgKEUudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgICAgaWYgKGkgPSByLmRvbmUgPyBQIDogRywgRS5hcmcgPT09IEwpXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsdWU6IEUuYXJnLFxuICAgICAgICAgICAgICBkb25lOiByLmRvbmVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBFLnR5cGUgPT09IFwidGhyb3dcIiAmJiAoaSA9IFAsIHIubWV0aG9kID0gXCJ0aHJvd1wiLCByLmFyZyA9IEUuYXJnKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcSh0LCBlKSB7XG4gICAgICB2YXIgciA9IHQuaXRlcmF0b3JbZS5tZXRob2RdO1xuICAgICAgaWYgKHIgPT09IGwpIHtcbiAgICAgICAgaWYgKGUuZGVsZWdhdGUgPSBudWxsLCBlLm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHQuaXRlcmF0b3IucmV0dXJuICYmIChlLm1ldGhvZCA9IFwicmV0dXJuXCIsIGUuYXJnID0gbCwgcSh0LCBlKSwgZS5tZXRob2QgPT09IFwidGhyb3dcIikpXG4gICAgICAgICAgICByZXR1cm4gTDtcbiAgICAgICAgICBlLm1ldGhvZCA9IFwidGhyb3dcIiwgZS5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBMO1xuICAgICAgfVxuICAgICAgdmFyIGkgPSBOKHIsIHQuaXRlcmF0b3IsIGUuYXJnKTtcbiAgICAgIGlmIChpLnR5cGUgPT09IFwidGhyb3dcIilcbiAgICAgICAgcmV0dXJuIGUubWV0aG9kID0gXCJ0aHJvd1wiLCBlLmFyZyA9IGkuYXJnLCBlLmRlbGVnYXRlID0gbnVsbCwgTDtcbiAgICAgIHZhciBuID0gaS5hcmc7XG4gICAgICBpZiAoIW4pXG4gICAgICAgIHJldHVybiBlLm1ldGhvZCA9IFwidGhyb3dcIiwgZS5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIiksIGUuZGVsZWdhdGUgPSBudWxsLCBMO1xuICAgICAgaWYgKG4uZG9uZSlcbiAgICAgICAgZVt0LnJlc3VsdE5hbWVdID0gbi52YWx1ZSwgZS5uZXh0ID0gdC5uZXh0TG9jLCBlLm1ldGhvZCAhPT0gXCJyZXR1cm5cIiAmJiAoZS5tZXRob2QgPSBcIm5leHRcIiwgZS5hcmcgPSBsKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICByZXR1cm4gZS5kZWxlZ2F0ZSA9IG51bGwsIEw7XG4gICAgfVxuICAgIFkoJCksIHcoJCwgdiwgXCJHZW5lcmF0b3JcIiksIHcoJCwgeSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KSwgdygkLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24geCh0KSB7XG4gICAgICB2YXIgZSA9IHsgdHJ5TG9jOiB0WzBdIH07XG4gICAgICAxIGluIHQgJiYgKGUuY2F0Y2hMb2MgPSB0WzFdKSwgMiBpbiB0ICYmIChlLmZpbmFsbHlMb2MgPSB0WzJdLCBlLmFmdGVyTG9jID0gdFszXSksIHRoaXMudHJ5RW50cmllcy5wdXNoKGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhKHQpIHtcbiAgICAgIHZhciBlID0gdC5jb21wbGV0aW9uIHx8IHt9O1xuICAgICAgZS50eXBlID0gXCJub3JtYWxcIiwgZGVsZXRlIGUuYXJnLCB0LmNvbXBsZXRpb24gPSBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1KHQpIHtcbiAgICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV0sIHQuZm9yRWFjaCh4LCB0aGlzKSwgdGhpcy5yZXNldCghMCk7XG4gICAgfVxuICAgIHMua2V5cyA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBlID0gW107XG4gICAgICBmb3IgKHZhciByIGluIHQpXG4gICAgICAgIGUucHVzaChyKTtcbiAgICAgIHJldHVybiBlLnJldmVyc2UoKSwgZnVuY3Rpb24gaSgpIHtcbiAgICAgICAgZm9yICg7IGUubGVuZ3RoOyApIHtcbiAgICAgICAgICB2YXIgbiA9IGUucG9wKCk7XG4gICAgICAgICAgaWYgKG4gaW4gdClcbiAgICAgICAgICAgIHJldHVybiBpLnZhbHVlID0gbiwgaS5kb25lID0gITEsIGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGkuZG9uZSA9ICEwLCBpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGgodCkge1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgdmFyIGUgPSB0W3ldO1xuICAgICAgICBpZiAoZSlcbiAgICAgICAgICByZXR1cm4gZS5jYWxsKHQpO1xuICAgICAgICBpZiAodHlwZW9mIHQubmV4dCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIGlmICghaXNOYU4odC5sZW5ndGgpKSB7XG4gICAgICAgICAgdmFyIHIgPSAtMSwgaSA9IGZ1bmN0aW9uIG4oKSB7XG4gICAgICAgICAgICBmb3IgKDsgKytyIDwgdC5sZW5ndGg7IClcbiAgICAgICAgICAgICAgaWYgKGMuY2FsbCh0LCByKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbi52YWx1ZSA9IHRbcl0sIG4uZG9uZSA9ICExLCBuO1xuICAgICAgICAgICAgcmV0dXJuIG4udmFsdWUgPSBsLCBuLmRvbmUgPSAhMCwgbjtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBpLm5leHQgPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyBuZXh0OiBnIH07XG4gICAgfVxuICAgIHMudmFsdWVzID0gaDtcbiAgICBmdW5jdGlvbiBnKCkge1xuICAgICAgcmV0dXJuIHsgdmFsdWU6IGwsIGRvbmU6ICEwIH07XG4gICAgfVxuICAgIHJldHVybiB1LnByb3RvdHlwZSA9IHtcbiAgICAgIGNvbnN0cnVjdG9yOiB1LFxuICAgICAgcmVzZXQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKHRoaXMucHJldiA9IDAsIHRoaXMubmV4dCA9IDAsIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSBsLCB0aGlzLmRvbmUgPSAhMSwgdGhpcy5kZWxlZ2F0ZSA9IG51bGwsIHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMuYXJnID0gbCwgdGhpcy50cnlFbnRyaWVzLmZvckVhY2goYSksICF0KVxuICAgICAgICAgIGZvciAodmFyIGUgaW4gdGhpcylcbiAgICAgICAgICAgIGUuY2hhckF0KDApID09PSBcInRcIiAmJiBjLmNhbGwodGhpcywgZSkgJiYgIWlzTmFOKCtlLnNsaWNlKDEpKSAmJiAodGhpc1tlXSA9IGwpO1xuICAgICAgfSxcbiAgICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRvbmUgPSAhMDtcbiAgICAgICAgdmFyIHQgPSB0aGlzLnRyeUVudHJpZXNbMF0sIGUgPSB0LmNvbXBsZXRpb247XG4gICAgICAgIGlmIChlLnR5cGUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICB0aHJvdyBlLmFyZztcbiAgICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICAgIH0sXG4gICAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24odCkge1xuICAgICAgICBpZiAodGhpcy5kb25lKVxuICAgICAgICAgIHRocm93IHQ7XG4gICAgICAgIHZhciBlID0gdGhpcztcbiAgICAgICAgZnVuY3Rpb24gcihTLCBFKSB7XG4gICAgICAgICAgcmV0dXJuIGQudHlwZSA9IFwidGhyb3dcIiwgZC5hcmcgPSB0LCBlLm5leHQgPSBTLCBFICYmIChlLm1ldGhvZCA9IFwibmV4dFwiLCBlLmFyZyA9IGwpLCAhIUU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgIHZhciBuID0gdGhpcy50cnlFbnRyaWVzW2ldLCBkID0gbi5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChuLnRyeUxvYyA9PT0gXCJyb290XCIpXG4gICAgICAgICAgICByZXR1cm4gcihcImVuZFwiKTtcbiAgICAgICAgICBpZiAobi50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgICB2YXIgYiA9IGMuY2FsbChuLCBcImNhdGNoTG9jXCIpLCBGID0gYy5jYWxsKG4sIFwiZmluYWxseUxvY1wiKTtcbiAgICAgICAgICAgIGlmIChiICYmIEYpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IG4uY2F0Y2hMb2MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHIobi5jYXRjaExvYywgITApO1xuICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgbi5maW5hbGx5TG9jKVxuICAgICAgICAgICAgICAgIHJldHVybiByKG4uZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IG4uY2F0Y2hMb2MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHIobi5jYXRjaExvYywgITApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChGKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBuLmZpbmFsbHlMb2MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHIobi5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgICAgZm9yICh2YXIgciA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyByID49IDA7IC0tcikge1xuICAgICAgICAgIHZhciBpID0gdGhpcy50cnlFbnRyaWVzW3JdO1xuICAgICAgICAgIGlmIChpLnRyeUxvYyA8PSB0aGlzLnByZXYgJiYgYy5jYWxsKGksIFwiZmluYWxseUxvY1wiKSAmJiB0aGlzLnByZXYgPCBpLmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgIHZhciBuID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuICYmICh0ID09PSBcImJyZWFrXCIgfHwgdCA9PT0gXCJjb250aW51ZVwiKSAmJiBuLnRyeUxvYyA8PSBlICYmIGUgPD0gbi5maW5hbGx5TG9jICYmIChuID0gbnVsbCk7XG4gICAgICAgIHZhciBkID0gbiA/IG4uY29tcGxldGlvbiA6IHt9O1xuICAgICAgICByZXR1cm4gZC50eXBlID0gdCwgZC5hcmcgPSBlLCBuID8gKHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMubmV4dCA9IG4uZmluYWxseUxvYywgTCkgOiB0aGlzLmNvbXBsZXRlKGQpO1xuICAgICAgfSxcbiAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbih0LCBlKSB7XG4gICAgICAgIGlmICh0LnR5cGUgPT09IFwidGhyb3dcIilcbiAgICAgICAgICB0aHJvdyB0LmFyZztcbiAgICAgICAgcmV0dXJuIHQudHlwZSA9PT0gXCJicmVha1wiIHx8IHQudHlwZSA9PT0gXCJjb250aW51ZVwiID8gdGhpcy5uZXh0ID0gdC5hcmcgOiB0LnR5cGUgPT09IFwicmV0dXJuXCIgPyAodGhpcy5ydmFsID0gdGhpcy5hcmcgPSB0LmFyZywgdGhpcy5tZXRob2QgPSBcInJldHVyblwiLCB0aGlzLm5leHQgPSBcImVuZFwiKSA6IHQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBlICYmICh0aGlzLm5leHQgPSBlKSwgTDtcbiAgICAgIH0sXG4gICAgICBmaW5pc2g6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBlID49IDA7IC0tZSkge1xuICAgICAgICAgIHZhciByID0gdGhpcy50cnlFbnRyaWVzW2VdO1xuICAgICAgICAgIGlmIChyLmZpbmFsbHlMb2MgPT09IHQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyLmNvbXBsZXRpb24sIHIuYWZ0ZXJMb2MpLCBhKHIpLCBMO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2F0Y2g6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgZSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBlID49IDA7IC0tZSkge1xuICAgICAgICAgIHZhciByID0gdGhpcy50cnlFbnRyaWVzW2VdO1xuICAgICAgICAgIGlmIChyLnRyeUxvYyA9PT0gdCkge1xuICAgICAgICAgICAgdmFyIGkgPSByLmNvbXBsZXRpb247XG4gICAgICAgICAgICBpZiAoaS50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgdmFyIG4gPSBpLmFyZztcbiAgICAgICAgICAgICAgYShyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgICB9LFxuICAgICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24odCwgZSwgcikge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgICBpdGVyYXRvcjogaCh0KSxcbiAgICAgICAgICByZXN1bHROYW1lOiBlLFxuICAgICAgICAgIG5leHRMb2M6IHJcbiAgICAgICAgfSwgdGhpcy5tZXRob2QgPT09IFwibmV4dFwiICYmICh0aGlzLmFyZyA9IGwpLCBMO1xuICAgICAgfVxuICAgIH0sIHM7XG4gIH0oXG4gICAgLy8gSWYgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlLCB1c2UgbW9kdWxlLmV4cG9ydHNcbiAgICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAgIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgICAvLyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIHZhcmlhYmxlIGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlLlxuICAgIG8uZXhwb3J0c1xuICApO1xuICB0cnkge1xuICAgIHJlZ2VuZXJhdG9yUnVudGltZSA9IGY7XG4gIH0gY2F0Y2gge1xuICAgIHR5cGVvZiBnbG9iYWxUaGlzID09IFwib2JqZWN0XCIgPyBnbG9iYWxUaGlzLnJlZ2VuZXJhdG9yUnVudGltZSA9IGYgOiBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKGYpO1xuICB9XG59KShpZSk7XG52YXIgYWUgPSB7XG4gIGRlZmF1bHRBcmdzOiBbXG4gICAgLyogYXJnc1swXSBpcyBhbHdheXMgdGhlIGJpbmFyeSBwYXRoICovXG4gICAgXCIuL2ZmbXBlZ1wiLFxuICAgIC8qIERpc2FibGUgaW50ZXJhY3Rpb24gbW9kZSAqL1xuICAgIFwiLW5vc3RkaW5cIixcbiAgICAvKiBGb3JjZSB0byBvdmVycmlkZSBvdXRwdXQgZmlsZSAqL1xuICAgIFwiLXlcIlxuICBdLFxuICBiYXNlT3B0aW9uczoge1xuICAgIC8qIEZsYWcgdG8gdHVybiBvbi9vZmYgbG9nIG1lc3NhZ2VzIGluIGNvbnNvbGUgKi9cbiAgICBsb2c6ICExLFxuICAgIC8qXG4gICAgICogQ3VzdG9tIGxvZ2dlciB0byBnZXQgZmZtcGVnLndhc20gb3V0cHV0IG1lc3NhZ2VzLlxuICAgICAqIGEgc2FtcGxlIGxvZ2dlciBsb29rcyBsaWtlIHRoaXM6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBsb2dnZXIgPSAoeyB0eXBlLCBtZXNzYWdlIH0pID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHR5cGUsIG1lc3NhZ2UpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIHR5cGUgY2FuIGJlIG9uZSBvZiBmb2xsb3dpbmc6XG4gICAgICpcbiAgICAgKiBpbmZvOiBpbnRlcm5hbCB3b3JrZmxvdyBkZWJ1ZyBtZXNzYWdlc1xuICAgICAqIGZmZXJyOiBmZm1wZWcgbmF0aXZlIHN0ZGVyciBvdXRwdXRcbiAgICAgKiBmZm91dDogZmZtcGVnIG5hdGl2ZSBzdGRvdXQgb3V0cHV0XG4gICAgICovXG4gICAgbG9nZ2VyOiAoKSA9PiB7XG4gICAgfSxcbiAgICAvKlxuICAgICAqIFByb2dyZXNzIGhhbmRsZXIgdG8gZ2V0IGN1cnJlbnQgcHJvZ3Jlc3Mgb2YgZmZtcGVnIGNvbW1hbmQuXG4gICAgICogYSBzYW1wbGUgcHJvZ3Jlc3MgaGFuZGxlciBsb29rcyBsaWtlIHRoaXM6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBwcm9ncmVzcyA9ICh7IHJhdGlvIH0pID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHJhdGlvKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiByYXRpbyBpcyBhIGZsb2F0IG51bWJlciBiZXR3ZWVuIDAgdG8gMS5cbiAgICAgKi9cbiAgICBwcm9ncmVzczogKCkgPT4ge1xuICAgIH0sXG4gICAgLypcbiAgICAgKiBQYXRoIHRvIGZpbmQvZG93bmxvYWQgZmZtcGVnLndhc20tY29yZSxcbiAgICAgKiB0aGlzIHZhbHVlIHNob3VsZCBiZSBvdmVyd3JpdGVuIGJ5IGBkZWZhdWx0T3B0aW9uc2AgaW5cbiAgICAgKiBlYWNoIGVudmlyb25tZW50LlxuICAgICAqL1xuICAgIGNvcmVQYXRoOiBcIlwiXG4gIH1cbn0sIHNlID0gKG8sIGYpID0+IHtcbiAgY29uc3QgcyA9IG8uX21hbGxvYyhmLmxlbmd0aCAqIFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgcmV0dXJuIGYuZm9yRWFjaCgocCwgYykgPT4ge1xuICAgIGNvbnN0IGwgPSBvLmxlbmd0aEJ5dGVzVVRGOChwKSArIDEsIGogPSBvLl9tYWxsb2MobCk7XG4gICAgby5zdHJpbmdUb1VURjgocCwgaiwgbCksIG8uc2V0VmFsdWUocyArIFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UICogYywgaiwgXCJpMzJcIik7XG4gIH0pLCBbZi5sZW5ndGgsIHNdO1xufTtcbmNvbnN0IGZlID0gXCJAZmZtcGVnL2ZmbXBlZ1wiLCBjZSA9IFwiMC4xMS42XCIsIGxlID0gXCJGRm1wZWcgV2ViQXNzZW1ibHkgdmVyc2lvblwiLCBwZSA9IFwic3JjL2luZGV4LmpzXCIsIHVlID0gXCJzcmMvaW5kZXguZC50c1wiLCBoZSA9IHtcbiAgZXhhbXBsZTogXCJleGFtcGxlc1wiXG59LCBkZSA9IHtcbiAgc3RhcnQ6IFwibm9kZSBzY3JpcHRzL3NlcnZlci5qc1wiLFxuICBcInN0YXJ0OndvcmtlclwiOiBcIm5vZGUgc2NyaXB0cy93b3JrZXItc2VydmVyLmpzXCIsXG4gIGJ1aWxkOiBcInJpbXJhZiBkaXN0ICYmIHdlYnBhY2sgLS1jb25maWcgc2NyaXB0cy93ZWJwYWNrLmNvbmZpZy5wcm9kLmpzXCIsXG4gIFwiYnVpbGQ6d29ya2VyXCI6IFwicmltcmFmIGRpc3QgJiYgd2VicGFjayAtLWNvbmZpZyBzY3JpcHRzL3dlYnBhY2suY29uZmlnLndvcmtlci5wcm9kLmpzXCIsXG4gIHByZXB1Ymxpc2hPbmx5OiBcIm5wbSBydW4gYnVpbGRcIixcbiAgbGludDogXCJlc2xpbnQgc3JjXCIsXG4gIHdhaXQ6IFwicmltcmFmIGRpc3QgJiYgd2FpdC1vbiBodHRwOi8vbG9jYWxob3N0OjMwMDAvZGlzdC9mZm1wZWcuZGV2LmpzXCIsXG4gIHRlc3Q6IFwibnBtLXJ1bi1hbGwgLXAgLXIgc3RhcnQgdGVzdDphbGxcIixcbiAgXCJ0ZXN0OmFsbFwiOiBcIm5wbS1ydW4tYWxsIHdhaXQgdGVzdDpicm93c2VyOmZmbXBlZyB0ZXN0Om5vZGU6YWxsXCIsXG4gIFwidGVzdDpub2RlXCI6IFwibm9kZSBub2RlX21vZHVsZXMvbW9jaGEvYmluL19tb2NoYSAtLWV4aXQgLS1iYWlsIC0tcmVxdWlyZSAuL3NjcmlwdHMvdGVzdC1oZWxwZXIuanNcIixcbiAgXCJ0ZXN0Om5vZGU6YWxsXCI6IFwibnBtIHJ1biB0ZXN0Om5vZGUgLS0gLi90ZXN0cy8qLnRlc3QuanNcIixcbiAgXCJ0ZXN0OmJyb3dzZXJcIjogXCJtb2NoYS1oZWFkbGVzcy1jaHJvbWUgLWEgYWxsb3ctZmlsZS1hY2Nlc3MtZnJvbS1maWxlcyAtYSBpbmNvZ25pdG8gLWEgbm8tc2FuZGJveCAtYSBkaXNhYmxlLXNldHVpZC1zYW5kYm94IC1hIGRpc2FibGUtbG9nZ2luZyAtdCAzMDAwMDBcIixcbiAgXCJ0ZXN0OmJyb3dzZXI6ZmZtcGVnXCI6IFwibnBtIHJ1biB0ZXN0OmJyb3dzZXIgLS0gLWYgLi90ZXN0cy9mZm1wZWcudGVzdC5odG1sXCJcbn0sIG1lID0ge1xuICBcIi4vc3JjL25vZGUvaW5kZXguanNcIjogXCIuL3NyYy9icm93c2VyL2luZGV4LmpzXCJcbn0sIGdlID0ge1xuICB0eXBlOiBcImdpdFwiLFxuICB1cmw6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9mZm1wZWd3YXNtL2ZmbXBlZy53YXNtLmdpdFwiXG59LCB3ZSA9IFtcbiAgXCJmZm1wZWdcIixcbiAgXCJXZWJBc3NlbWJseVwiLFxuICBcInZpZGVvXCJcbl0sIHllID0gXCJKZXJvbWUgV3UgPGplcm9tZXd1c0BnbWFpbC5jb20+XCIsIHZlID0gXCJNSVRcIiwgYmUgPSB7XG4gIHVybDogXCJodHRwczovL2dpdGh1Yi5jb20vZmZtcGVnd2FzbS9mZm1wZWcud2FzbS9pc3N1ZXNcIlxufSwgRmUgPSB7XG4gIG5vZGU6IFwiPj0xMi4xNi4xXCJcbn0sIEVlID0gXCJodHRwczovL2dpdGh1Yi5jb20vZmZtcGVnd2FzbS9mZm1wZWcud2FzbSNyZWFkbWVcIiwgamUgPSB7XG4gIFwiaXMtdXJsXCI6IFwiXjEuMi40XCIsXG4gIFwibm9kZS1mZXRjaFwiOiBcIl4yLjYuMVwiLFxuICBcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIjogXCJeMC4xMy43XCIsXG4gIFwicmVzb2x2ZS11cmxcIjogXCJeMC4yLjFcIlxufSwgTGUgPSB7XG4gIFwiQGJhYmVsL2NvcmVcIjogXCJeNy4xMi4zXCIsXG4gIFwiQGJhYmVsL3ByZXNldC1lbnZcIjogXCJeNy4xMi4xXCIsXG4gIFwiQGZmbXBlZy9jb3JlXCI6IFwiXjAuMTEuMFwiLFxuICBcIkB0eXBlcy9lbXNjcmlwdGVuXCI6IFwiXjEuMzkuNFwiLFxuICBcImJhYmVsLWVzbGludFwiOiBcIl4xMC4xLjBcIixcbiAgXCJiYWJlbC1sb2FkZXJcIjogXCJeOC4xLjBcIixcbiAgY2hhaTogXCJeNC4yLjBcIixcbiAgY29yczogXCJeMi44LjVcIixcbiAgZXNsaW50OiBcIl43LjEyLjFcIixcbiAgXCJlc2xpbnQtY29uZmlnLWFpcmJuYi1iYXNlXCI6IFwiXjE0LjEuMFwiLFxuICBcImVzbGludC1wbHVnaW4taW1wb3J0XCI6IFwiXjIuMjIuMVwiLFxuICBleHByZXNzOiBcIl40LjE3LjFcIixcbiAgbW9jaGE6IFwiXjguMi4xXCIsXG4gIFwibW9jaGEtaGVhZGxlc3MtY2hyb21lXCI6IFwiXjIuMC4zXCIsXG4gIFwibnBtLXJ1bi1hbGxcIjogXCJeNC4xLjVcIixcbiAgXCJ3YWl0LW9uXCI6IFwiXjUuMy4wXCIsXG4gIHdlYnBhY2s6IFwiXjUuMy4yXCIsXG4gIFwid2VicGFjay1jbGlcIjogXCJeNC4xLjBcIixcbiAgXCJ3ZWJwYWNrLWRldi1taWRkbGV3YXJlXCI6IFwiXjQuMC4wXCJcbn0sIFEgPSB7XG4gIG5hbWU6IGZlLFxuICB2ZXJzaW9uOiBjZSxcbiAgZGVzY3JpcHRpb246IGxlLFxuICBtYWluOiBwZSxcbiAgdHlwZXM6IHVlLFxuICBkaXJlY3RvcmllczogaGUsXG4gIHNjcmlwdHM6IGRlLFxuICBicm93c2VyOiBtZSxcbiAgcmVwb3NpdG9yeTogZ2UsXG4gIGtleXdvcmRzOiB3ZSxcbiAgYXV0aG9yOiB5ZSxcbiAgbGljZW5zZTogdmUsXG4gIGJ1Z3M6IGJlLFxuICBlbmdpbmVzOiBGZSxcbiAgaG9tZXBhZ2U6IEVlLFxuICBkZXBlbmRlbmNpZXM6IGplLFxuICBkZXZEZXBlbmRlbmNpZXM6IExlXG59LCBPZSA9IHR5cGVvZiBwcm9jZXNzIDwgXCJ1XCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIiA/IG5ldyBVUkwoXCIvbm9kZV9tb2R1bGVzL0BmZm1wZWcvY29yZS9kaXN0L2ZmbXBlZy1jb3JlLmpzXCIsIHNlbGYubG9jYXRpb24pLmhyZWYgOiBgaHR0cHM6Ly91bnBrZy5jb20vQGZmbXBlZy9jb3JlQCR7US5kZXZEZXBlbmRlbmNpZXNbXCJAZmZtcGVnL2NvcmVcIl0uc3Vic3RyaW5nKDEpfS9kaXN0L2ZmbXBlZy1jb3JlLmpzYCwgU2UgPSB7IGNvcmVQYXRoOiBPZSB9O1xubGV0IFogPSAhMSwgWCA9ICgpID0+IHtcbn07XG5jb25zdCBfZSA9IChvKSA9PiB7XG4gIFogPSBvO1xufSwgUGUgPSAobykgPT4ge1xuICBYID0gbztcbn0sIGtlID0gKG8sIGYpID0+IHtcbiAgWCh7IHR5cGU6IG8sIG1lc3NhZ2U6IGYgfSksIFogJiYgY29uc29sZS5sb2coYFske299XSAke2Z9YCk7XG59O1xudmFyIEEgPSB7XG4gIGxvZ2dpbmc6IFosXG4gIHNldExvZ2dpbmc6IF9lLFxuICBzZXRDdXN0b21Mb2dnZXI6IFBlLFxuICBsb2c6IGtlXG59O1xuY29uc3QgJGUgPSAobykgPT4gYFxuY3JlYXRlRkZtcGVnQ29yZSBpcyBub3QgZGVmaW5lZC4gZmZtcGVnLndhc20gaXMgdW5hYmxlIHRvIGZpbmQgY3JlYXRlRkZtcGVnQ29yZSBhZnRlciBsb2FkaW5nIGZmbXBlZy1jb3JlLmpzIGZyb20gJHtvfS4gVXNlIGFub3RoZXIgVVJMIHdoZW4gY2FsbGluZyBjcmVhdGVGRm1wZWcoKTpcblxuY29uc3QgZmZtcGVnID0gY3JlYXRlRkZtcGVnKHtcbiAgY29yZVBhdGg6ICdodHRwOi8vbG9jYWxob3N0OjMwMDAvZmZtcGVnLWNvcmUuanMnLFxufSk7XG5gO1xudmFyIEsgPSB7XG4gIENSRUFURV9GRk1QRUdfQ09SRV9JU19OT1RfREVGSU5FRDogJGVcbn07XG5jb25zdCBXID0gYXN5bmMgKG8sIGYpID0+IHtcbiAgQS5sb2coXCJpbmZvXCIsIGBmZXRjaCAke299YCk7XG4gIGNvbnN0IHMgPSBhd2FpdCAoYXdhaXQgZmV0Y2gobykpLmFycmF5QnVmZmVyKCk7XG4gIEEubG9nKFwiaW5mb1wiLCBgJHtvfSBmaWxlIHNpemUgPSAke3MuYnl0ZUxlbmd0aH0gYnl0ZXNgKTtcbiAgY29uc3QgcCA9IG5ldyBCbG9iKFtzXSwgeyB0eXBlOiBmIH0pLCBjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChwKTtcbiAgcmV0dXJuIEEubG9nKFwiaW5mb1wiLCBgJHtvfSBibG9iIFVSTCA9ICR7Y31gKSwgYztcbn0sIENlID0gYXN5bmMgKHtcbiAgY29yZVBhdGg6IG8sXG4gIHdvcmtlclBhdGg6IGYsXG4gIHdhc21QYXRoOiBzXG59KSA9PiB7XG4gIGlmICh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgPCBcInVcIiAmJiBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpIHtcbiAgICBpZiAodHlwZW9mIG8gIT0gXCJzdHJpbmdcIilcbiAgICAgIHRocm93IEVycm9yKFwiY29yZVBhdGggc2hvdWxkIGJlIGEgc3RyaW5nIVwiKTtcbiAgICBjb25zdCB5ID0gbmV3IFVSTChvLCBpbXBvcnQubWV0YS51cmwpLmhyZWYsIG0gPSBhd2FpdCBXKFxuICAgICAgeSxcbiAgICAgIFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiXG4gICAgKSwgdiA9IGF3YWl0IFcoXG4gICAgICBzICE9PSB2b2lkIDAgPyBzIDogeS5yZXBsYWNlKFwiZmZtcGVnLWNvcmUuanNcIiwgXCJmZm1wZWctY29yZS53YXNtXCIpLFxuICAgICAgXCJhcHBsaWNhdGlvbi93YXNtXCJcbiAgICApLCB3ID0gYXdhaXQgVyhcbiAgICAgIGYgIT09IHZvaWQgMCA/IGYgOiB5LnJlcGxhY2UoXCJmZm1wZWctY29yZS5qc1wiLCBcImZmbXBlZy1jb3JlLndvcmtlci5qc1wiKSxcbiAgICAgIFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiXG4gICAgKTtcbiAgICByZXR1cm4gdHlwZW9mIGNyZWF0ZUZGbXBlZ0NvcmUgPiBcInVcIiA/IG5ldyBQcm9taXNlKChDKSA9PiB7XG4gICAgICBpZiAoZ2xvYmFsVGhpcy5pbXBvcnRTY3JpcHRzKG0pLCB0eXBlb2YgY3JlYXRlRkZtcGVnQ29yZSA+IFwidVwiKVxuICAgICAgICB0aHJvdyBFcnJvcihLLkNSRUFURV9GRk1QRUdfQ09SRV9JU19OT1RfREVGSU5FRCh5KSk7XG4gICAgICBBLmxvZyhcImluZm9cIiwgXCJmZm1wZWctY29yZS5qcyBzY3JpcHQgbG9hZGVkXCIpLCBDKHtcbiAgICAgICAgY3JlYXRlRkZtcGVnQ29yZSxcbiAgICAgICAgY29yZVBhdGg6IG0sXG4gICAgICAgIHdhc21QYXRoOiB2LFxuICAgICAgICB3b3JrZXJQYXRoOiB3XG4gICAgICB9KTtcbiAgICB9KSA6IChBLmxvZyhcImluZm9cIiwgXCJmZm1wZWctY29yZS5qcyBzY3JpcHQgaXMgbG9hZGVkIGFscmVhZHlcIiksIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICBjcmVhdGVGRm1wZWdDb3JlLFxuICAgICAgY29yZVBhdGg6IG0sXG4gICAgICB3YXNtUGF0aDogdixcbiAgICAgIHdvcmtlclBhdGg6IHdcbiAgICB9KSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBvICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgRXJyb3IoXCJjb3JlUGF0aCBzaG91bGQgYmUgYSBzdHJpbmchXCIpO1xuICBjb25zdCBwID0gbmV3IFVSTChvLCBpbXBvcnQubWV0YS51cmwpLmhyZWYsIGMgPSBhd2FpdCBXKFxuICAgIHAsXG4gICAgXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCJcbiAgKSwgbCA9IGF3YWl0IFcoXG4gICAgcyAhPT0gdm9pZCAwID8gcyA6IHAucmVwbGFjZShcImZmbXBlZy1jb3JlLmpzXCIsIFwiZmZtcGVnLWNvcmUud2FzbVwiKSxcbiAgICBcImFwcGxpY2F0aW9uL3dhc21cIlxuICApLCBqID0gYXdhaXQgVyhcbiAgICBmICE9PSB2b2lkIDAgPyBmIDogcC5yZXBsYWNlKFwiZmZtcGVnLWNvcmUuanNcIiwgXCJmZm1wZWctY29yZS53b3JrZXIuanNcIiksXG4gICAgXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCJcbiAgKTtcbiAgcmV0dXJuIHR5cGVvZiBjcmVhdGVGRm1wZWdDb3JlID4gXCJ1XCIgPyBuZXcgUHJvbWlzZSgoeSkgPT4ge1xuICAgIGNvbnN0IG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpLCB2ID0gKCkgPT4ge1xuICAgICAgaWYgKG0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgdiksIHR5cGVvZiBjcmVhdGVGRm1wZWdDb3JlID4gXCJ1XCIpXG4gICAgICAgIHRocm93IEVycm9yKEsuQ1JFQVRFX0ZGTVBFR19DT1JFX0lTX05PVF9ERUZJTkVEKHApKTtcbiAgICAgIEEubG9nKFwiaW5mb1wiLCBcImZmbXBlZy1jb3JlLmpzIHNjcmlwdCBsb2FkZWRcIiksIHkoe1xuICAgICAgICBjcmVhdGVGRm1wZWdDb3JlLFxuICAgICAgICBjb3JlUGF0aDogYyxcbiAgICAgICAgd2FzbVBhdGg6IGwsXG4gICAgICAgIHdvcmtlclBhdGg6IGpcbiAgICAgIH0pO1xuICAgIH07XG4gICAgbS5zcmMgPSBjLCBtLnR5cGUgPSBcInRleHQvamF2YXNjcmlwdFwiLCBtLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHYpLCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0uYXBwZW5kQ2hpbGQobSk7XG4gIH0pIDogKEEubG9nKFwiaW5mb1wiLCBcImZmbXBlZy1jb3JlLmpzIHNjcmlwdCBpcyBsb2FkZWQgYWxyZWFkeVwiKSwgUHJvbWlzZS5yZXNvbHZlKHtcbiAgICBjcmVhdGVGRm1wZWdDb3JlLFxuICAgIGNvcmVQYXRoOiBjLFxuICAgIHdhc21QYXRoOiBsLFxuICAgIHdvcmtlclBhdGg6IGpcbiAgfSkpO1xufSwgVGUgPSAobykgPT4gbmV3IFByb21pc2UoKGYsIHMpID0+IHtcbiAgY29uc3QgcCA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gIHAub25sb2FkID0gKCkgPT4ge1xuICAgIGYocC5yZXN1bHQpO1xuICB9LCBwLm9uZXJyb3IgPSAoeyB0YXJnZXQ6IHsgZXJyb3I6IHsgY29kZTogYyB9IH0gfSkgPT4ge1xuICAgIHMoRXJyb3IoYEZpbGUgY291bGQgbm90IGJlIHJlYWQhIENvZGU9JHtjfWApKTtcbiAgfSwgcC5yZWFkQXNBcnJheUJ1ZmZlcihvKTtcbn0pLCBSZSA9IGFzeW5jIChvKSA9PiB7XG4gIGxldCBmID0gbztcbiAgcmV0dXJuIHR5cGVvZiBvID4gXCJ1XCIgPyBuZXcgVWludDhBcnJheSgpIDogKHR5cGVvZiBvID09IFwic3RyaW5nXCIgPyAvZGF0YTpfZGF0YVxcLyhbYS16QS1aXSopO2Jhc2U2NCwoW15cIl0qKS8udGVzdChvKSA/IGYgPSBhdG9iKG8uc3BsaXQoXCIsXCIpWzFdKS5zcGxpdChcIlwiKS5tYXAoKHMpID0+IHMuY2hhckNvZGVBdCgwKSkgOiBmID0gYXdhaXQgKGF3YWl0IGZldGNoKG5ldyBVUkwobywgaW1wb3J0Lm1ldGEudXJsKS5ocmVmKSkuYXJyYXlCdWZmZXIoKSA6IChvIGluc3RhbmNlb2YgRmlsZSB8fCBvIGluc3RhbmNlb2YgQmxvYikgJiYgKGYgPSBhd2FpdCBUZShvKSksIG5ldyBVaW50OEFycmF5KGYpKTtcbn0sIEFlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZGVmYXVsdE9wdGlvbnM6IFNlLFxuICBmZXRjaEZpbGU6IFJlLFxuICBnZXRDcmVhdGVGRm1wZWdDb3JlOiBDZVxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgZWUgPSAvKiBAX19QVVJFX18gKi8gbmUoQWUpLCB7IGRlZmF1bHRBcmdzOiBOZSwgYmFzZU9wdGlvbnM6IEdlIH0gPSBhZSwgVWUgPSBzZSwgeyBkZWZhdWx0T3B0aW9uczogRGUsIGdldENyZWF0ZUZGbXBlZ0NvcmU6IE1lIH0gPSBlZSwgeyB2ZXJzaW9uOiBJZSB9ID0gUSwgSiA9IEVycm9yKFwiZmZtcGVnLndhc20gaXMgbm90IHJlYWR5LCBtYWtlIHN1cmUgeW91IGhhdmUgY29tcGxldGVkIGxvYWQoKS5cIik7XG52YXIgV2UgPSAobyA9IHt9KSA9PiB7XG4gIGNvbnN0IHtcbiAgICBsb2c6IGYsXG4gICAgbG9nZ2VyOiBzLFxuICAgIHByb2dyZXNzOiBwLFxuICAgIC4uLmNcbiAgfSA9IHtcbiAgICAuLi5HZSxcbiAgICAuLi5EZSxcbiAgICAuLi5vXG4gIH07XG4gIGxldCBsID0gbnVsbCwgaiA9IG51bGwsIHkgPSBudWxsLCBtID0gbnVsbCwgdiA9ICExLCB3ID0gKCkgPT4ge1xuICB9LCBDID0gZiwgTiA9IHAsIF8gPSAwLCBHID0gMCwgVSA9ICExLCBQID0gMDtcbiAgY29uc3QgTCA9IChhKSA9PiB7XG4gICAgYSA9PT0gXCJGRk1QRUdfRU5EXCIgJiYgeSAhPT0gbnVsbCAmJiAoeSgpLCB5ID0gbnVsbCwgbSA9IG51bGwsIHYgPSAhMSk7XG4gIH0sIE8gPSAoYSwgdSkgPT4ge1xuICAgIHcoeyB0eXBlOiBhLCBtZXNzYWdlOiB1IH0pLCBDICYmIGNvbnNvbGUubG9nKGBbJHthfV0gJHt1fWApO1xuICB9LCBUID0gKGEpID0+IHtcbiAgICBjb25zdCBbdSwgaCwgZ10gPSBhLnNwbGl0KFwiOlwiKTtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh1KSAqIDYwICogNjAgKyBwYXJzZUZsb2F0KGgpICogNjAgKyBwYXJzZUZsb2F0KGcpO1xuICB9LCBrID0gKGEsIHUpID0+IHtcbiAgICBpZiAodHlwZW9mIGEgPT0gXCJzdHJpbmdcIilcbiAgICAgIGlmIChhLnN0YXJ0c1dpdGgoXCIgIER1cmF0aW9uXCIpKSB7XG4gICAgICAgIGNvbnN0IGggPSBhLnNwbGl0KFwiLCBcIilbMF0uc3BsaXQoXCI6IFwiKVsxXSwgZyA9IFQoaCk7XG4gICAgICAgIHUoeyBkdXJhdGlvbjogZywgcmF0aW86IFAgfSksIChfID09PSAwIHx8IF8gPiBnKSAmJiAoXyA9IGcsIFUgPSAhMCk7XG4gICAgICB9IGVsc2UgaWYgKFUgJiYgYS5zdGFydHNXaXRoKFwiICAgIFN0cmVhbVwiKSkge1xuICAgICAgICBjb25zdCBoID0gYS5tYXRjaCgvKFtcXGQuXSspIGZwcy8pO1xuICAgICAgICBpZiAoaCkge1xuICAgICAgICAgIGNvbnN0IGcgPSBwYXJzZUZsb2F0KGhbMV0pO1xuICAgICAgICAgIEcgPSBfICogZztcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgRyA9IDA7XG4gICAgICAgIFUgPSAhMTtcbiAgICAgIH0gZWxzZSBpZiAoYS5zdGFydHNXaXRoKFwiZnJhbWVcIikgfHwgYS5zdGFydHNXaXRoKFwic2l6ZVwiKSkge1xuICAgICAgICBjb25zdCBoID0gYS5zcGxpdChcInRpbWU9XCIpWzFdLnNwbGl0KFwiIFwiKVswXSwgZyA9IFQoaCksIHQgPSBhLm1hdGNoKC9mcmFtZT1cXHMqKFxcZCspLyk7XG4gICAgICAgIGlmIChHICYmIHQpIHtcbiAgICAgICAgICBjb25zdCBlID0gcGFyc2VGbG9hdCh0WzFdKTtcbiAgICAgICAgICBQID0gTWF0aC5taW4oZSAvIEcsIDEpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBQID0gZyAvIF87XG4gICAgICAgIHUoeyByYXRpbzogUCwgdGltZTogZyB9KTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBhLnN0YXJ0c1dpdGgoXCJ2aWRlbzpcIikgJiYgKHUoeyByYXRpbzogMSB9KSwgXyA9IDApO1xuICB9LCBEID0gKHsgdHlwZTogYSwgbWVzc2FnZTogdSB9KSA9PiB7XG4gICAgTyhhLCB1KSwgayh1LCBOKSwgTCh1KTtcbiAgfSwgQiA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoTyhcImluZm9cIiwgXCJsb2FkIGZmbXBlZy1jb3JlXCIpLCBsID09PSBudWxsKSB7XG4gICAgICBPKFwiaW5mb1wiLCBcImxvYWRpbmcgZmZtcGVnLWNvcmVcIik7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNyZWF0ZUZGbXBlZ0NvcmU6IGEsXG4gICAgICAgIGNvcmVQYXRoOiB1LFxuICAgICAgICB3b3JrZXJQYXRoOiBoLFxuICAgICAgICB3YXNtUGF0aDogZ1xuICAgICAgfSA9IGF3YWl0IE1lKGMpO1xuICAgICAgbCA9IGF3YWl0IGEoe1xuICAgICAgICAvKlxuICAgICAgICAgKiBBc3NpZ24gbWFpblNjcmlwdFVybE9yQmxvYiBmaXhlcyBjaHJvbWUgZXh0ZW5zaW9uIHdlYiB3b3JrZXIgaXNzdWVcbiAgICAgICAgICogYXMgdGhlcmUgaXMgbm8gZG9jdW1lbnQuY3VycmVudFNjcmlwdCBpbiB0aGUgY29udGV4dCBvZiBjb250ZW50X3NjcmlwdHNcbiAgICAgICAgICovXG4gICAgICAgIG1haW5TY3JpcHRVcmxPckJsb2I6IHUsXG4gICAgICAgIHByaW50RXJyOiAodCkgPT4gRCh7IHR5cGU6IFwiZmZlcnJcIiwgbWVzc2FnZTogdCB9KSxcbiAgICAgICAgcHJpbnQ6ICh0KSA9PiBEKHsgdHlwZTogXCJmZm91dFwiLCBtZXNzYWdlOiB0IH0pLFxuICAgICAgICAvKlxuICAgICAgICAgKiBsb2NhdGVGaWxlIG92ZXJyaWRlcyBwYXRocyBvZiBmaWxlcyB0aGF0IGlzIGxvYWRlZCBieSBtYWluIHNjcmlwdCAoZmZtcGVnLWNvcmUuanMpLlxuICAgICAgICAgKiBJdCBpcyBjcml0aWNhbCBmb3IgYnJvd3NlciBlbnZpcm9ubWVudCBhbmQgd2Ugb3ZlcnJpZGUgYm90aCB3YXNtIGFuZCB3b3JrZXIgcGF0aHNcbiAgICAgICAgICogYXMgd2UgYXJlIHVzaW5nIGJsb2IgVVJMIGluc3RlYWQgb2Ygb3JpZ2luYWwgVVJMIHRvIGF2b2lkIGNyb3NzIG9yaWdpbiBpc3N1ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBsb2NhdGVGaWxlOiAodCwgZSkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93IDwgXCJ1XCIgfHwgdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlIDwgXCJ1XCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZyA8IFwidVwiICYmIHQuZW5kc1dpdGgoXCJmZm1wZWctY29yZS53YXNtXCIpKVxuICAgICAgICAgICAgICByZXR1cm4gZztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaCA8IFwidVwiICYmIHQuZW5kc1dpdGgoXCJmZm1wZWctY29yZS53b3JrZXIuanNcIikpXG4gICAgICAgICAgICAgIHJldHVybiBoO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZSArIHQ7XG4gICAgICAgIH1cbiAgICAgIH0pLCBqID0gbC5jd3JhcChjLm1haW5OYW1lIHx8IFwicHJveHlfbWFpblwiLCBcIm51bWJlclwiLCBbXCJudW1iZXJcIiwgXCJudW1iZXJcIl0pLCBPKFwiaW5mb1wiLCBcImZmbXBlZy1jb3JlIGxvYWRlZFwiKTtcbiAgICB9IGVsc2VcbiAgICAgIHRocm93IEVycm9yKFwiZmZtcGVnLndhc20gd2FzIGxvYWRlZCwgeW91IHNob3VsZCBub3QgbG9hZCBpdCBhZ2FpbiwgdXNlIGZmbXBlZy5pc0xvYWRlZCgpIHRvIGNoZWNrIG5leHQgdGltZS5cIik7XG4gIH0sIE0gPSAoKSA9PiBsICE9PSBudWxsLCAkID0gKC4uLmEpID0+IHtcbiAgICBpZiAoTyhcImluZm9cIiwgYHJ1biBmZm1wZWcgY29tbWFuZDogJHthLmpvaW4oXCIgXCIpfWApLCBsID09PSBudWxsKVxuICAgICAgdGhyb3cgSjtcbiAgICBpZiAodilcbiAgICAgIHRocm93IEVycm9yKFwiZmZtcGVnLndhc20gY2FuIG9ubHkgcnVuIG9uZSBjb21tYW5kIGF0IGEgdGltZVwiKTtcbiAgICByZXR1cm4gdiA9ICEwLCBuZXcgUHJvbWlzZSgodSwgaCkgPT4ge1xuICAgICAgY29uc3QgZyA9IFsuLi5OZSwgLi4uYV0uZmlsdGVyKCh0KSA9PiB0Lmxlbmd0aCAhPT0gMCk7XG4gICAgICB5ID0gdSwgbSA9IGgsIGooLi4uVWUobCwgZykpO1xuICAgIH0pO1xuICB9LCBZID0gKGEsIC4uLnUpID0+IHtcbiAgICBpZiAoTyhcImluZm9cIiwgYHJ1biBGUy4ke2F9ICR7dS5tYXAoKGgpID0+IHR5cGVvZiBoID09IFwic3RyaW5nXCIgPyBoIDogYDwke2gubGVuZ3RofSBieXRlcyBiaW5hcnkgZmlsZT5gKS5qb2luKFwiIFwiKX1gKSwgbCA9PT0gbnVsbClcbiAgICAgIHRocm93IEo7XG4gICAge1xuICAgICAgbGV0IGggPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaCA9IGwuRlNbYV0oLi4udSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYSA9PT0gXCJyZWFkZGlyXCIgPyBgZmZtcGVnLkZTKCdyZWFkZGlyJywgJyR7dVswXX0nKSBlcnJvci4gQ2hlY2sgaWYgdGhlIHBhdGggZXhpc3RzLCBleDogZmZtcGVnLkZTKCdyZWFkZGlyJywgJy8nKWAgOiBhID09PSBcInJlYWRGaWxlXCIgPyBgZmZtcGVnLkZTKCdyZWFkRmlsZScsICcke3VbMF19JykgZXJyb3IuIENoZWNrIGlmIHRoZSBwYXRoIGV4aXN0c2AgOiBcIk9vcHMsIHNvbWV0aGluZyB3ZW50IHdyb25nIGluIEZTIG9wZXJhdGlvbi5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gaDtcbiAgICB9XG4gIH0sIEkgPSAoKSA9PiB7XG4gICAgaWYgKGwgPT09IG51bGwpXG4gICAgICB0aHJvdyBKO1xuICAgIG0gJiYgbShcImZmbXBlZyBoYXMgZXhpdGVkXCIpLCB2ID0gITE7XG4gICAgdHJ5IHtcbiAgICAgIGwuZXhpdCgxKTtcbiAgICB9IGNhdGNoIChhKSB7XG4gICAgICBPKGEubWVzc2FnZSksIG0gJiYgbShhKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgbCA9IG51bGwsIGogPSBudWxsLCB5ID0gbnVsbCwgbSA9IG51bGw7XG4gICAgfVxuICB9LCBWID0gKGEpID0+IHtcbiAgICBOID0gYTtcbiAgfSwgcSA9IChhKSA9PiB7XG4gICAgdyA9IGE7XG4gIH0sIHggPSAoYSkgPT4ge1xuICAgIEMgPSBhO1xuICB9O1xuICByZXR1cm4gTyhcImluZm9cIiwgYHVzZSBmZm1wZWcud2FzbSB2JHtJZX1gKSwge1xuICAgIHNldFByb2dyZXNzOiBWLFxuICAgIHNldExvZ2dlcjogcSxcbiAgICBzZXRMb2dnaW5nOiB4LFxuICAgIGxvYWQ6IEIsXG4gICAgaXNMb2FkZWQ6IE0sXG4gICAgcnVuOiAkLFxuICAgIGV4aXQ6IEksXG4gICAgRlM6IFlcbiAgfTtcbn07XG5jb25zdCBCZSA9IFdlLCB7IGZldGNoRmlsZTogemUgfSA9IGVlO1xudmFyIHRlID0ge1xuICAvKlxuICAgKiBDcmVhdGUgZmZtcGVnIGluc3RhbmNlLlxuICAgKiBFYWNoIGZmbXBlZyBpbnN0YW5jZSBvd25zIGFuIGlzb2xhdGVkIE1FTUZTIGFuZCB3b3Jrc1xuICAgKiBpbmRlcGVuZGVudGx5LlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogYGBgXG4gICAqIGNvbnN0IGZmbXBlZyA9IGNyZWF0ZUZGbXBlZyh7XG4gICAqICBsb2c6IHRydWUsXG4gICAqICBsb2dnZXI6ICgpID0+IHt9LFxuICAgKiAgcHJvZ3Jlc3M6ICgpID0+IHt9LFxuICAgKiAgY29yZVBhdGg6ICcnLFxuICAgKiB9KVxuICAgKiBgYGBcbiAgICpcbiAgICogRm9yIHRoZSB1c2FnZSBvZiB0aGVzZSBmb3VyIGFyZ3VtZW50cywgY2hlY2sgY29uZmlnLmpzXG4gICAqXG4gICAqL1xuICBjcmVhdGVGRm1wZWc6IEJlLFxuICAvKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIGZldGNoaW5nIGZpbGVzIGZyb20gdmFyaW91cyByZXNvdXJjZS5cbiAgICogU29tZXRpbWVzIHRoZSB2aWRlby9hdWRpbyBmaWxlIHlvdSB3YW50IHRvIHByb2Nlc3MgbWF5IGxvY2F0ZWRcbiAgICogaW4gYSByZW1vdGUgVVJMIGFuZCBzb21ld2hlcmUgaW4geW91ciBsb2NhbCBmaWxlIHN5c3RlbS5cbiAgICpcbiAgICogVGhpcyBoZWxwZXIgZnVuY3Rpb24gaGVscHMgeW91IHRvIGZldGNoIHRvIGZpbGUgYW5kIHJldHVybiBhblxuICAgKiBVaW50OEFycmF5IHZhcmlhYmxlIGZvciBmZm1wZWcud2FzbSB0byBjb25zdW1lLlxuICAgKlxuICAgKi9cbiAgZmV0Y2hGaWxlOiB6ZVxufTtcbmNvbnN0IFllID0gLyogQF9fUFVSRV9fICovIG9lKHRlKSwgcWUgPSAvKiBAX19QVVJFX18gKi8gcmUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGRlZmF1bHQ6IFllXG59LCBbdGVdKTtcbmV4cG9ydCB7XG4gIHFlIGFzIGlcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-audio-voice-recorder@2.2.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-audio-voice-recorder/dist/index-1c988149.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/react-audio-voice-recorder@2.2.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-audio-voice-recorder/dist/react-audio-visualize.es-69216c73.js":
/*!*******************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-audio-voice-recorder@2.2.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-audio-voice-recorder/dist/react-audio-visualize.es-69216c73.js ***!
  \*******************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioVisualizer: () => (/* binding */ br),\n/* harmony export */   LiveAudioVisualizer: () => (/* binding */ Sr)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@14.2.3_@opentelemetry+api@1.9.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nvar ne = { exports: {} }, z = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar je;\nfunction dr() {\n  if (je)\n    return z;\n  je = 1;\n  var y = react__WEBPACK_IMPORTED_MODULE_0__, m = Symbol.for(\"react.element\"), _ = Symbol.for(\"react.fragment\"), b = Object.prototype.hasOwnProperty, h = y.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, w = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function k(i, s, g) {\n    var o, a = {}, d = null, E = null;\n    g !== void 0 && (d = \"\" + g), s.key !== void 0 && (d = \"\" + s.key), s.ref !== void 0 && (E = s.ref);\n    for (o in s)\n      b.call(s, o) && !w.hasOwnProperty(o) && (a[o] = s[o]);\n    if (i && i.defaultProps)\n      for (o in s = i.defaultProps, s)\n        a[o] === void 0 && (a[o] = s[o]);\n    return { $$typeof: m, type: i, key: d, ref: E, props: a, _owner: h.current };\n  }\n  return z.Fragment = _, z.jsx = k, z.jsxs = k, z;\n}\nvar q = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Pe;\nfunction mr() {\n  return Pe || (Pe = 1,  true && function() {\n    var y = react__WEBPACK_IMPORTED_MODULE_0__, m = Symbol.for(\"react.element\"), _ = Symbol.for(\"react.portal\"), b = Symbol.for(\"react.fragment\"), h = Symbol.for(\"react.strict_mode\"), w = Symbol.for(\"react.profiler\"), k = Symbol.for(\"react.provider\"), i = Symbol.for(\"react.context\"), s = Symbol.for(\"react.forward_ref\"), g = Symbol.for(\"react.suspense\"), o = Symbol.for(\"react.suspense_list\"), a = Symbol.for(\"react.memo\"), d = Symbol.for(\"react.lazy\"), E = Symbol.for(\"react.offscreen\"), C = Symbol.iterator, T = \"@@iterator\";\n    function D(e) {\n      if (e === null || typeof e != \"object\")\n        return null;\n      var r = C && e[C] || e[T];\n      return typeof r == \"function\" ? r : null;\n    }\n    var l = y.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function f(e) {\n      {\n        for (var r = arguments.length, t = new Array(r > 1 ? r - 1 : 0), n = 1; n < r; n++)\n          t[n - 1] = arguments[n];\n        j(\"error\", e, t);\n      }\n    }\n    function j(e, r, t) {\n      {\n        var n = l.ReactDebugCurrentFrame, p = n.getStackAddendum();\n        p !== \"\" && (r += \"%s\", t = t.concat([p]));\n        var v = t.map(function(u) {\n          return String(u);\n        });\n        v.unshift(\"Warning: \" + r), Function.prototype.apply.call(console[e], console, v);\n      }\n    }\n    var xe = !1, Fe = !1, Ne = !1, Ae = !1, Ie = !1, oe;\n    oe = Symbol.for(\"react.module.reference\");\n    function Le(e) {\n      return !!(typeof e == \"string\" || typeof e == \"function\" || e === b || e === w || Ie || e === h || e === g || e === o || Ae || e === E || xe || Fe || Ne || typeof e == \"object\" && e !== null && (e.$$typeof === d || e.$$typeof === a || e.$$typeof === k || e.$$typeof === i || e.$$typeof === s || // This needs to include all possible module reference object\n      // types supported by any Flight configuration anywhere since\n      // we don't know which Flight build this will end up being used\n      // with.\n      e.$$typeof === oe || e.getModuleId !== void 0));\n    }\n    function ze(e, r, t) {\n      var n = e.displayName;\n      if (n)\n        return n;\n      var p = r.displayName || r.name || \"\";\n      return p !== \"\" ? t + \"(\" + p + \")\" : t;\n    }\n    function ae(e) {\n      return e.displayName || \"Context\";\n    }\n    function $(e) {\n      if (e == null)\n        return null;\n      if (typeof e.tag == \"number\" && f(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof e == \"function\")\n        return e.displayName || e.name || null;\n      if (typeof e == \"string\")\n        return e;\n      switch (e) {\n        case b:\n          return \"Fragment\";\n        case _:\n          return \"Portal\";\n        case w:\n          return \"Profiler\";\n        case h:\n          return \"StrictMode\";\n        case g:\n          return \"Suspense\";\n        case o:\n          return \"SuspenseList\";\n      }\n      if (typeof e == \"object\")\n        switch (e.$$typeof) {\n          case i:\n            var r = e;\n            return ae(r) + \".Consumer\";\n          case k:\n            var t = e;\n            return ae(t._context) + \".Provider\";\n          case s:\n            return ze(e, e.render, \"ForwardRef\");\n          case a:\n            var n = e.displayName || null;\n            return n !== null ? n : $(e.type) || \"Memo\";\n          case d: {\n            var p = e, v = p._payload, u = p._init;\n            try {\n              return $(u(v));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var F = Object.assign, I = 0, ie, ce, le, se, ue, fe, pe;\n    function ye() {\n    }\n    ye.__reactDisabledLog = !0;\n    function We() {\n      {\n        if (I === 0) {\n          ie = console.log, ce = console.info, le = console.warn, se = console.error, ue = console.group, fe = console.groupCollapsed, pe = console.groupEnd;\n          var e = {\n            configurable: !0,\n            enumerable: !0,\n            value: ye,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: e,\n            log: e,\n            warn: e,\n            error: e,\n            group: e,\n            groupCollapsed: e,\n            groupEnd: e\n          });\n        }\n        I++;\n      }\n    }\n    function Me() {\n      {\n        if (I--, I === 0) {\n          var e = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: F({}, e, {\n              value: ie\n            }),\n            info: F({}, e, {\n              value: ce\n            }),\n            warn: F({}, e, {\n              value: le\n            }),\n            error: F({}, e, {\n              value: se\n            }),\n            group: F({}, e, {\n              value: ue\n            }),\n            groupCollapsed: F({}, e, {\n              value: fe\n            }),\n            groupEnd: F({}, e, {\n              value: pe\n            })\n          });\n        }\n        I < 0 && f(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var X = l.ReactCurrentDispatcher, J;\n    function W(e, r, t) {\n      {\n        if (J === void 0)\n          try {\n            throw Error();\n          } catch (p) {\n            var n = p.stack.trim().match(/\\n( *(at )?)/);\n            J = n && n[1] || \"\";\n          }\n        return `\n` + J + e;\n      }\n    }\n    var K = !1, M;\n    {\n      var Ue = typeof WeakMap == \"function\" ? WeakMap : Map;\n      M = new Ue();\n    }\n    function de(e, r) {\n      if (!e || K)\n        return \"\";\n      {\n        var t = M.get(e);\n        if (t !== void 0)\n          return t;\n      }\n      var n;\n      K = !0;\n      var p = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var v;\n      v = X.current, X.current = null, We();\n      try {\n        if (r) {\n          var u = function() {\n            throw Error();\n          };\n          if (Object.defineProperty(u.prototype, \"props\", {\n            set: function() {\n              throw Error();\n            }\n          }), typeof Reflect == \"object\" && Reflect.construct) {\n            try {\n              Reflect.construct(u, []);\n            } catch (x) {\n              n = x;\n            }\n            Reflect.construct(e, [], u);\n          } else {\n            try {\n              u.call();\n            } catch (x) {\n              n = x;\n            }\n            e.call(u.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            n = x;\n          }\n          e();\n        }\n      } catch (x) {\n        if (x && n && typeof x.stack == \"string\") {\n          for (var c = x.stack.split(`\n`), O = n.stack.split(`\n`), S = c.length - 1, R = O.length - 1; S >= 1 && R >= 0 && c[S] !== O[R]; )\n            R--;\n          for (; S >= 1 && R >= 0; S--, R--)\n            if (c[S] !== O[R]) {\n              if (S !== 1 || R !== 1)\n                do\n                  if (S--, R--, R < 0 || c[S] !== O[R]) {\n                    var P = `\n` + c[S].replace(\" at new \", \" at \");\n                    return e.displayName && P.includes(\"<anonymous>\") && (P = P.replace(\"<anonymous>\", e.displayName)), typeof e == \"function\" && M.set(e, P), P;\n                  }\n                while (S >= 1 && R >= 0);\n              break;\n            }\n        }\n      } finally {\n        K = !1, X.current = v, Me(), Error.prepareStackTrace = p;\n      }\n      var A = e ? e.displayName || e.name : \"\", Oe = A ? W(A) : \"\";\n      return typeof e == \"function\" && M.set(e, Oe), Oe;\n    }\n    function Be(e, r, t) {\n      return de(e, !1);\n    }\n    function Ve(e) {\n      var r = e.prototype;\n      return !!(r && r.isReactComponent);\n    }\n    function U(e, r, t) {\n      if (e == null)\n        return \"\";\n      if (typeof e == \"function\")\n        return de(e, Ve(e));\n      if (typeof e == \"string\")\n        return W(e);\n      switch (e) {\n        case g:\n          return W(\"Suspense\");\n        case o:\n          return W(\"SuspenseList\");\n      }\n      if (typeof e == \"object\")\n        switch (e.$$typeof) {\n          case s:\n            return Be(e.render);\n          case a:\n            return U(e.type, r, t);\n          case d: {\n            var n = e, p = n._payload, v = n._init;\n            try {\n              return U(v(p), r, t);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var B = Object.prototype.hasOwnProperty, me = {}, ge = l.ReactDebugCurrentFrame;\n    function V(e) {\n      if (e) {\n        var r = e._owner, t = U(e.type, e._source, r ? r.type : null);\n        ge.setExtraStackFrame(t);\n      } else\n        ge.setExtraStackFrame(null);\n    }\n    function qe(e, r, t, n, p) {\n      {\n        var v = Function.call.bind(B);\n        for (var u in e)\n          if (v(e, u)) {\n            var c = void 0;\n            try {\n              if (typeof e[u] != \"function\") {\n                var O = Error((n || \"React class\") + \": \" + t + \" type `\" + u + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof e[u] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                throw O.name = \"Invariant Violation\", O;\n              }\n              c = e[u](r, u, n, t, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n            } catch (S) {\n              c = S;\n            }\n            c && !(c instanceof Error) && (V(p), f(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", n || \"React class\", t, u, typeof c), V(null)), c instanceof Error && !(c.message in me) && (me[c.message] = !0, V(p), f(\"Failed %s type: %s\", t, c.message), V(null));\n          }\n      }\n    }\n    var Ye = Array.isArray;\n    function Q(e) {\n      return Ye(e);\n    }\n    function He(e) {\n      {\n        var r = typeof Symbol == \"function\" && Symbol.toStringTag, t = r && e[Symbol.toStringTag] || e.constructor.name || \"Object\";\n        return t;\n      }\n    }\n    function Xe(e) {\n      try {\n        return ve(e), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function ve(e) {\n      return \"\" + e;\n    }\n    function he(e) {\n      if (Xe(e))\n        return f(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", He(e)), ve(e);\n    }\n    var L = l.ReactCurrentOwner, Je = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    }, be, we, Z;\n    Z = {};\n    function Ke(e) {\n      if (B.call(e, \"ref\")) {\n        var r = Object.getOwnPropertyDescriptor(e, \"ref\").get;\n        if (r && r.isReactWarning)\n          return !1;\n      }\n      return e.ref !== void 0;\n    }\n    function Qe(e) {\n      if (B.call(e, \"key\")) {\n        var r = Object.getOwnPropertyDescriptor(e, \"key\").get;\n        if (r && r.isReactWarning)\n          return !1;\n      }\n      return e.key !== void 0;\n    }\n    function Ze(e, r) {\n      if (typeof e.ref == \"string\" && L.current && r && L.current.stateNode !== r) {\n        var t = $(L.current.type);\n        Z[t] || (f('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(L.current.type), e.ref), Z[t] = !0);\n      }\n    }\n    function Ge(e, r) {\n      {\n        var t = function() {\n          be || (be = !0, f(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", r));\n        };\n        t.isReactWarning = !0, Object.defineProperty(e, \"key\", {\n          get: t,\n          configurable: !0\n        });\n      }\n    }\n    function er(e, r) {\n      {\n        var t = function() {\n          we || (we = !0, f(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", r));\n        };\n        t.isReactWarning = !0, Object.defineProperty(e, \"ref\", {\n          get: t,\n          configurable: !0\n        });\n      }\n    }\n    var rr = function(e, r, t, n, p, v, u) {\n      var c = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: m,\n        // Built-in properties that belong on the element\n        type: e,\n        key: r,\n        ref: t,\n        props: u,\n        // Record the component responsible for creating this element.\n        _owner: v\n      };\n      return c._store = {}, Object.defineProperty(c._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty(c, \"_self\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: n\n      }), Object.defineProperty(c, \"_source\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: p\n      }), Object.freeze && (Object.freeze(c.props), Object.freeze(c)), c;\n    };\n    function tr(e, r, t, n, p) {\n      {\n        var v, u = {}, c = null, O = null;\n        t !== void 0 && (he(t), c = \"\" + t), Qe(r) && (he(r.key), c = \"\" + r.key), Ke(r) && (O = r.ref, Ze(r, p));\n        for (v in r)\n          B.call(r, v) && !Je.hasOwnProperty(v) && (u[v] = r[v]);\n        if (e && e.defaultProps) {\n          var S = e.defaultProps;\n          for (v in S)\n            u[v] === void 0 && (u[v] = S[v]);\n        }\n        if (c || O) {\n          var R = typeof e == \"function\" ? e.displayName || e.name || \"Unknown\" : e;\n          c && Ge(u, R), O && er(u, R);\n        }\n        return rr(e, c, O, p, n, L.current, u);\n      }\n    }\n    var G = l.ReactCurrentOwner, Se = l.ReactDebugCurrentFrame;\n    function N(e) {\n      if (e) {\n        var r = e._owner, t = U(e.type, e._source, r ? r.type : null);\n        Se.setExtraStackFrame(t);\n      } else\n        Se.setExtraStackFrame(null);\n    }\n    var ee;\n    ee = !1;\n    function re(e) {\n      return typeof e == \"object\" && e !== null && e.$$typeof === m;\n    }\n    function ke() {\n      {\n        if (G.current) {\n          var e = $(G.current.type);\n          if (e)\n            return `\n\nCheck the render method of \\`` + e + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function nr(e) {\n      {\n        if (e !== void 0) {\n          var r = e.fileName.replace(/^.*[\\\\\\/]/, \"\"), t = e.lineNumber;\n          return `\n\nCheck your code at ` + r + \":\" + t + \".\";\n        }\n        return \"\";\n      }\n    }\n    var Re = {};\n    function or(e) {\n      {\n        var r = ke();\n        if (!r) {\n          var t = typeof e == \"string\" ? e : e.displayName || e.name;\n          t && (r = `\n\nCheck the top-level render call using <` + t + \">.\");\n        }\n        return r;\n      }\n    }\n    function _e(e, r) {\n      {\n        if (!e._store || e._store.validated || e.key != null)\n          return;\n        e._store.validated = !0;\n        var t = or(r);\n        if (Re[t])\n          return;\n        Re[t] = !0;\n        var n = \"\";\n        e && e._owner && e._owner !== G.current && (n = \" It was passed a child from \" + $(e._owner.type) + \".\"), N(e), f('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', t, n), N(null);\n      }\n    }\n    function Ee(e, r) {\n      {\n        if (typeof e != \"object\")\n          return;\n        if (Q(e))\n          for (var t = 0; t < e.length; t++) {\n            var n = e[t];\n            re(n) && _e(n, r);\n          }\n        else if (re(e))\n          e._store && (e._store.validated = !0);\n        else if (e) {\n          var p = D(e);\n          if (typeof p == \"function\" && p !== e.entries)\n            for (var v = p.call(e), u; !(u = v.next()).done; )\n              re(u.value) && _e(u.value, r);\n        }\n      }\n    }\n    function ar(e) {\n      {\n        var r = e.type;\n        if (r == null || typeof r == \"string\")\n          return;\n        var t;\n        if (typeof r == \"function\")\n          t = r.propTypes;\n        else if (typeof r == \"object\" && (r.$$typeof === s || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        r.$$typeof === a))\n          t = r.propTypes;\n        else\n          return;\n        if (t) {\n          var n = $(r);\n          qe(t, e.props, \"prop\", n, e);\n        } else if (r.PropTypes !== void 0 && !ee) {\n          ee = !0;\n          var p = $(r);\n          f(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", p || \"Unknown\");\n        }\n        typeof r.getDefaultProps == \"function\" && !r.getDefaultProps.isReactClassApproved && f(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n      }\n    }\n    function ir(e) {\n      {\n        for (var r = Object.keys(e.props), t = 0; t < r.length; t++) {\n          var n = r[t];\n          if (n !== \"children\" && n !== \"key\") {\n            N(e), f(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", n), N(null);\n            break;\n          }\n        }\n        e.ref !== null && (N(e), f(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), N(null));\n      }\n    }\n    function Ce(e, r, t, n, p, v) {\n      {\n        var u = Le(e);\n        if (!u) {\n          var c = \"\";\n          (e === void 0 || typeof e == \"object\" && e !== null && Object.keys(e).length === 0) && (c += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var O = nr(p);\n          O ? c += O : c += ke();\n          var S;\n          e === null ? S = \"null\" : Q(e) ? S = \"array\" : e !== void 0 && e.$$typeof === m ? (S = \"<\" + ($(e.type) || \"Unknown\") + \" />\", c = \" Did you accidentally export a JSX literal instead of a component?\") : S = typeof e, f(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", S, c);\n        }\n        var R = tr(e, r, t, p, v);\n        if (R == null)\n          return R;\n        if (u) {\n          var P = r.children;\n          if (P !== void 0)\n            if (n)\n              if (Q(P)) {\n                for (var A = 0; A < P.length; A++)\n                  Ee(P[A], e);\n                Object.freeze && Object.freeze(P);\n              } else\n                f(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              Ee(P, e);\n        }\n        return e === b ? ir(R) : ar(R), R;\n      }\n    }\n    function cr(e, r, t) {\n      return Ce(e, r, t, !0);\n    }\n    function lr(e, r, t) {\n      return Ce(e, r, t, !1);\n    }\n    var sr = lr, ur = cr;\n    q.Fragment = b, q.jsx = sr, q.jsxs = ur;\n  }()), q;\n}\n false ? 0 : ne.exports = mr();\nvar $e = ne.exports;\nconst gr = (y, m, _, b) => {\n  let h = m / (_ + b), w = Math.floor(y.length / h);\n  h > y.length && (h = y.length, w = 1);\n  const k = [];\n  for (let i = 0; i < h; i++) {\n    let s = 0;\n    for (let g = 0; g < w && i * w + g < y.length; g++)\n      s += y[i * w + g];\n    k.push(s / w);\n  }\n  return k;\n}, vr = (y, m, _, b, h, w) => {\n  const k = m.height / 2, i = m.getContext(\"2d\");\n  i && (i.clearRect(0, 0, m.width, m.height), h !== \"transparent\" && (i.fillStyle = h, i.fillRect(0, 0, m.width, m.height)), y.forEach((s, g) => {\n    i.fillStyle = w;\n    const o = g * (_ + b), a = k - s / 2, d = _, E = s || 1;\n    i.beginPath(), i.roundRect ? (i.roundRect(o, a, d, E, 50), i.fill()) : i.fillRect(o, a, d, E);\n  }));\n}, Sr = ({\n  mediaRecorder: y,\n  width: m = \"100%\",\n  height: _ = \"100%\",\n  barWidth: b = 2,\n  gap: h = 1,\n  backgroundColor: w = \"transparent\",\n  barColor: k = \"rgb(160, 198, 255)\",\n  fftSize: i = 1024,\n  maxDecibels: s = -10,\n  minDecibels: g = -90,\n  smoothingTimeConstant: o = 0.4\n}) => {\n  const [a] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => new AudioContext()), [d, E] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), C = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!y.stream)\n      return;\n    const l = a.createAnalyser();\n    E(l), l.fftSize = i, l.minDecibels = g, l.maxDecibels = s, l.smoothingTimeConstant = o, a.createMediaStreamSource(y.stream).connect(l);\n  }, [y.stream]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    d && y.state === \"recording\" && T();\n  }, [d, y.state]);\n  const T = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    if (!d)\n      return;\n    const l = new Uint8Array(d == null ? void 0 : d.frequencyBinCount);\n    y.state === \"recording\" ? (d == null || d.getByteFrequencyData(l), D(l), requestAnimationFrame(T)) : y.state === \"paused\" ? D(l) : y.state === \"inactive\" && a.state !== \"closed\" && a.close();\n  }, [d, a.state]), D = (l) => {\n    if (!C.current)\n      return;\n    const f = gr(\n      l,\n      C.current.width,\n      b,\n      h\n    );\n    vr(\n      f,\n      C.current,\n      b,\n      h,\n      w,\n      k\n    );\n  };\n  return /* @__PURE__ */ $e.jsx(\n    \"canvas\",\n    {\n      ref: C,\n      width: m,\n      height: _,\n      style: {\n        aspectRatio: \"unset\"\n      }\n    }\n  );\n}, hr = (y, m, _, b, h) => {\n  const w = y.getChannelData(0), k = _ / (b + h), i = Math.floor(w.length / k), s = m / 2;\n  let g = [], o = 0;\n  for (let a = 0; a < k; a++) {\n    const d = [];\n    let E = 0;\n    const C = [];\n    let T = 0;\n    for (let f = 0; f < i && a * i + f < y.length; f++) {\n      const j = w[a * i + f];\n      j <= 0 && (d.push(j), E++), j > 0 && (C.push(j), T++);\n    }\n    const D = d.reduce((f, j) => f + j, 0) / E, l = { max: C.reduce((f, j) => f + j, 0) / T, min: D };\n    l.max > o && (o = l.max), Math.abs(l.min) > o && (o = Math.abs(l.min)), g.push(l);\n  }\n  if (s * 0.8 > o * s) {\n    const a = s * 0.8 / o;\n    g = g.map((d) => ({\n      max: d.max * a,\n      min: d.min * a\n    }));\n  }\n  return g;\n}, te = (y, m, _, b, h, w, k, i = 0, s = 1) => {\n  const g = m.height / 2, o = m.getContext(\"2d\");\n  if (!o)\n    return;\n  o.clearRect(0, 0, m.width, m.height), h !== \"transparent\" && (o.fillStyle = h, o.fillRect(0, 0, m.width, m.height));\n  const a = (i || 0) / s;\n  y.forEach((d, E) => {\n    const C = E / y.length, T = a > C;\n    o.fillStyle = T && k ? k : w;\n    const D = E * (_ + b), l = g + d.min, f = _, j = g + d.max - l;\n    o.beginPath(), o.roundRect ? (o.roundRect(D, l, f, j, 50), o.fill()) : o.fillRect(D, l, f, j);\n  });\n}, br = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(\n  ({\n    blob: y,\n    width: m,\n    height: _,\n    barWidth: b = 2,\n    gap: h = 1,\n    currentTime: w,\n    style: k,\n    backgroundColor: i = \"transparent\",\n    barColor: s = \"rgb(184, 184, 184)\",\n    barPlayedColor: g = \"rgb(160, 198, 255)\"\n  }, o) => {\n    const a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), [d, E] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]), [C, T] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(\n      o,\n      () => a.current,\n      []\n    ), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      (async () => {\n        if (!a.current)\n          return;\n        if (!y) {\n          const l = Array.from({ length: 100 }, () => ({\n            max: 0,\n            min: 0\n          }));\n          te(\n            l,\n            a.current,\n            b,\n            h,\n            i,\n            s,\n            g\n          );\n          return;\n        }\n        const D = await y.arrayBuffer();\n        await new AudioContext().decodeAudioData(D, (l) => {\n          if (!a.current)\n            return;\n          T(l.duration);\n          const f = hr(\n            l,\n            _,\n            m,\n            b,\n            h\n          );\n          E(f), te(\n            f,\n            a.current,\n            b,\n            h,\n            i,\n            s,\n            g\n          );\n        });\n      })();\n    }, [y, a.current]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      a.current && te(\n        d,\n        a.current,\n        b,\n        h,\n        i,\n        s,\n        g,\n        w,\n        C\n      );\n    }, [w, C]), /* @__PURE__ */ $e.jsx(\n      \"canvas\",\n      {\n        ref: a,\n        width: m,\n        height: _,\n        style: {\n          ...k\n        }\n      }\n    );\n  }\n);\nbr.displayName = \"AudioVisualizer\";\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtYXVkaW8tdm9pY2UtcmVjb3JkZXJAMi4yLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvcmVhY3QtYXVkaW8tdm9pY2UtcmVjb3JkZXIvZGlzdC9yZWFjdC1hdWRpby12aXN1YWxpemUuZXMtNjkyMTZjNzMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXdJO0FBQ3hJLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQ0FBRSw0TEFBNEw7QUFDeE07QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFxQztBQUM3RCxZQUFZLGtDQUFFO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLE9BQU87QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxzQkFBc0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxNQUFxQyxHQUFHLENBQWlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjLCtDQUFDLHFDQUFxQywrQ0FBQyxRQUFRLDZDQUFFO0FBQy9ELEVBQUUsZ0RBQUM7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZUFBZSxnREFBQztBQUNuQjtBQUNBLEdBQUc7QUFDSCxZQUFZLGtEQUFFO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLE9BQU8saURBQUU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGNBQWMsNkNBQUUsaUJBQWlCLCtDQUFDLGVBQWUsK0NBQUM7QUFDbEQsV0FBVywwREFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZ0RBQUM7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhO0FBQzlDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSyxtQkFBbUIsZ0RBQUM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW5ub3ZhX2NoYXRib3QvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtYXVkaW8tdm9pY2UtcmVjb3JkZXJAMi4yLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvcmVhY3QtYXVkaW8tdm9pY2UtcmVjb3JkZXIvZGlzdC9yZWFjdC1hdWRpby12aXN1YWxpemUuZXMtNjkyMTZjNzMuanM/YWMzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVGUsIHsgdXNlU3RhdGUgYXMgWSwgdXNlUmVmIGFzIERlLCB1c2VFZmZlY3QgYXMgSCwgdXNlQ2FsbGJhY2sgYXMgZnIsIGZvcndhcmRSZWYgYXMgcHIsIHVzZUltcGVyYXRpdmVIYW5kbGUgYXMgeXIgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBuZSA9IHsgZXhwb3J0czoge30gfSwgeiA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIGplO1xuZnVuY3Rpb24gZHIoKSB7XG4gIGlmIChqZSlcbiAgICByZXR1cm4gejtcbiAgamUgPSAxO1xuICB2YXIgeSA9IFRlLCBtID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksIF8gPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksIGIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBoID0geS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRC5SZWFjdEN1cnJlbnRPd25lciwgdyA9IHsga2V5OiAhMCwgcmVmOiAhMCwgX19zZWxmOiAhMCwgX19zb3VyY2U6ICEwIH07XG4gIGZ1bmN0aW9uIGsoaSwgcywgZykge1xuICAgIHZhciBvLCBhID0ge30sIGQgPSBudWxsLCBFID0gbnVsbDtcbiAgICBnICE9PSB2b2lkIDAgJiYgKGQgPSBcIlwiICsgZyksIHMua2V5ICE9PSB2b2lkIDAgJiYgKGQgPSBcIlwiICsgcy5rZXkpLCBzLnJlZiAhPT0gdm9pZCAwICYmIChFID0gcy5yZWYpO1xuICAgIGZvciAobyBpbiBzKVxuICAgICAgYi5jYWxsKHMsIG8pICYmICF3Lmhhc093blByb3BlcnR5KG8pICYmIChhW29dID0gc1tvXSk7XG4gICAgaWYgKGkgJiYgaS5kZWZhdWx0UHJvcHMpXG4gICAgICBmb3IgKG8gaW4gcyA9IGkuZGVmYXVsdFByb3BzLCBzKVxuICAgICAgICBhW29dID09PSB2b2lkIDAgJiYgKGFbb10gPSBzW29dKTtcbiAgICByZXR1cm4geyAkJHR5cGVvZjogbSwgdHlwZTogaSwga2V5OiBkLCByZWY6IEUsIHByb3BzOiBhLCBfb3duZXI6IGguY3VycmVudCB9O1xuICB9XG4gIHJldHVybiB6LkZyYWdtZW50ID0gXywgei5qc3ggPSBrLCB6LmpzeHMgPSBrLCB6O1xufVxudmFyIHEgPSB7fTtcbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBQZTtcbmZ1bmN0aW9uIG1yKCkge1xuICByZXR1cm4gUGUgfHwgKFBlID0gMSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGZ1bmN0aW9uKCkge1xuICAgIHZhciB5ID0gVGUsIG0gPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSwgXyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksIGIgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksIGggPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksIHcgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksIGsgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIiksIGkgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSwgcyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSwgZyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSwgbyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLCBhID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksIGQgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSwgRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIiksIEMgPSBTeW1ib2wuaXRlcmF0b3IsIFQgPSBcIkBAaXRlcmF0b3JcIjtcbiAgICBmdW5jdGlvbiBEKGUpIHtcbiAgICAgIGlmIChlID09PSBudWxsIHx8IHR5cGVvZiBlICE9IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgdmFyIHIgPSBDICYmIGVbQ10gfHwgZVtUXTtcbiAgICAgIHJldHVybiB0eXBlb2YgciA9PSBcImZ1bmN0aW9uXCIgPyByIDogbnVsbDtcbiAgICB9XG4gICAgdmFyIGwgPSB5Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuICAgIGZ1bmN0aW9uIGYoZSkge1xuICAgICAge1xuICAgICAgICBmb3IgKHZhciByID0gYXJndW1lbnRzLmxlbmd0aCwgdCA9IG5ldyBBcnJheShyID4gMSA/IHIgLSAxIDogMCksIG4gPSAxOyBuIDwgcjsgbisrKVxuICAgICAgICAgIHRbbiAtIDFdID0gYXJndW1lbnRzW25dO1xuICAgICAgICBqKFwiZXJyb3JcIiwgZSwgdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGooZSwgciwgdCkge1xuICAgICAge1xuICAgICAgICB2YXIgbiA9IGwuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSwgcCA9IG4uZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICAgICAgICBwICE9PSBcIlwiICYmIChyICs9IFwiJXNcIiwgdCA9IHQuY29uY2F0KFtwXSkpO1xuICAgICAgICB2YXIgdiA9IHQubWFwKGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdi51bnNoaWZ0KFwiV2FybmluZzogXCIgKyByKSwgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtlXSwgY29uc29sZSwgdik7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB4ZSA9ICExLCBGZSA9ICExLCBOZSA9ICExLCBBZSA9ICExLCBJZSA9ICExLCBvZTtcbiAgICBvZSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tb2R1bGUucmVmZXJlbmNlXCIpO1xuICAgIGZ1bmN0aW9uIExlKGUpIHtcbiAgICAgIHJldHVybiAhISh0eXBlb2YgZSA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiB8fCBlID09PSBiIHx8IGUgPT09IHcgfHwgSWUgfHwgZSA9PT0gaCB8fCBlID09PSBnIHx8IGUgPT09IG8gfHwgQWUgfHwgZSA9PT0gRSB8fCB4ZSB8fCBGZSB8fCBOZSB8fCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIGUgIT09IG51bGwgJiYgKGUuJCR0eXBlb2YgPT09IGQgfHwgZS4kJHR5cGVvZiA9PT0gYSB8fCBlLiQkdHlwZW9mID09PSBrIHx8IGUuJCR0eXBlb2YgPT09IGkgfHwgZS4kJHR5cGVvZiA9PT0gcyB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAgIC8vIHdpdGguXG4gICAgICBlLiQkdHlwZW9mID09PSBvZSB8fCBlLmdldE1vZHVsZUlkICE9PSB2b2lkIDApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gemUoZSwgciwgdCkge1xuICAgICAgdmFyIG4gPSBlLmRpc3BsYXlOYW1lO1xuICAgICAgaWYgKG4pXG4gICAgICAgIHJldHVybiBuO1xuICAgICAgdmFyIHAgPSByLmRpc3BsYXlOYW1lIHx8IHIubmFtZSB8fCBcIlwiO1xuICAgICAgcmV0dXJuIHAgIT09IFwiXCIgPyB0ICsgXCIoXCIgKyBwICsgXCIpXCIgOiB0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZShlKSB7XG4gICAgICByZXR1cm4gZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gJChlKSB7XG4gICAgICBpZiAoZSA9PSBudWxsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgZS50YWcgPT0gXCJudW1iZXJcIiAmJiBmKFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiksIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIGUuZGlzcGxheU5hbWUgfHwgZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICBzd2l0Y2ggKGUpIHtcbiAgICAgICAgY2FzZSBiOlxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgXzpcbiAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgY2FzZSB3OlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgaDpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgZzpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIG86XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGUgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3dpdGNoIChlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBpOlxuICAgICAgICAgICAgdmFyIHIgPSBlO1xuICAgICAgICAgICAgcmV0dXJuIGFlKHIpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIGs6XG4gICAgICAgICAgICB2YXIgdCA9IGU7XG4gICAgICAgICAgICByZXR1cm4gYWUodC5fY29udGV4dCkgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgczpcbiAgICAgICAgICAgIHJldHVybiB6ZShlLCBlLnJlbmRlciwgXCJGb3J3YXJkUmVmXCIpO1xuICAgICAgICAgIGNhc2UgYTpcbiAgICAgICAgICAgIHZhciBuID0gZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIG4gIT09IG51bGwgPyBuIDogJChlLnR5cGUpIHx8IFwiTWVtb1wiO1xuICAgICAgICAgIGNhc2UgZDoge1xuICAgICAgICAgICAgdmFyIHAgPSBlLCB2ID0gcC5fcGF5bG9hZCwgdSA9IHAuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gJCh1KHYpKTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgRiA9IE9iamVjdC5hc3NpZ24sIEkgPSAwLCBpZSwgY2UsIGxlLCBzZSwgdWUsIGZlLCBwZTtcbiAgICBmdW5jdGlvbiB5ZSgpIHtcbiAgICB9XG4gICAgeWUuX19yZWFjdERpc2FibGVkTG9nID0gITA7XG4gICAgZnVuY3Rpb24gV2UoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChJID09PSAwKSB7XG4gICAgICAgICAgaWUgPSBjb25zb2xlLmxvZywgY2UgPSBjb25zb2xlLmluZm8sIGxlID0gY29uc29sZS53YXJuLCBzZSA9IGNvbnNvbGUuZXJyb3IsIHVlID0gY29uc29sZS5ncm91cCwgZmUgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkLCBwZSA9IGNvbnNvbGUuZ3JvdXBFbmQ7XG4gICAgICAgICAgdmFyIGUgPSB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICB2YWx1ZTogeWUsXG4gICAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgICB9O1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICAgIGluZm86IGUsXG4gICAgICAgICAgICBsb2c6IGUsXG4gICAgICAgICAgICB3YXJuOiBlLFxuICAgICAgICAgICAgZXJyb3I6IGUsXG4gICAgICAgICAgICBncm91cDogZSxcbiAgICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBlLFxuICAgICAgICAgICAgZ3JvdXBFbmQ6IGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBJKys7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIE1lKCkge1xuICAgICAge1xuICAgICAgICBpZiAoSS0tLCBJID09PSAwKSB7XG4gICAgICAgICAgdmFyIGUgPSB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgICB9O1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICAgIGxvZzogRih7fSwgZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogaWVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgaW5mbzogRih7fSwgZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogY2VcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgd2FybjogRih7fSwgZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogbGVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZXJyb3I6IEYoe30sIGUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHNlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdyb3VwOiBGKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB1ZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cENvbGxhcHNlZDogRih7fSwgZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogZmVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXBFbmQ6IEYoe30sIGUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHBlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIEkgPCAwICYmIGYoXCJkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgWCA9IGwuUmVhY3RDdXJyZW50RGlzcGF0Y2hlciwgSjtcbiAgICBmdW5jdGlvbiBXKGUsIHIsIHQpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKEogPT09IHZvaWQgMClcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9IGNhdGNoIChwKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHAuc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgICAgICBKID0gbiAmJiBuWzFdIHx8IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFxuYCArIEogKyBlO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgSyA9ICExLCBNO1xuICAgIHtcbiAgICAgIHZhciBVZSA9IHR5cGVvZiBXZWFrTWFwID09IFwiZnVuY3Rpb25cIiA/IFdlYWtNYXAgOiBNYXA7XG4gICAgICBNID0gbmV3IFVlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlKGUsIHIpIHtcbiAgICAgIGlmICghZSB8fCBLKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIHtcbiAgICAgICAgdmFyIHQgPSBNLmdldChlKTtcbiAgICAgICAgaWYgKHQgIT09IHZvaWQgMClcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgIH1cbiAgICAgIHZhciBuO1xuICAgICAgSyA9ICEwO1xuICAgICAgdmFyIHAgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdm9pZCAwO1xuICAgICAgdmFyIHY7XG4gICAgICB2ID0gWC5jdXJyZW50LCBYLmN1cnJlbnQgPSBudWxsLCBXZSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICB2YXIgdSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkodS5wcm90b3R5cGUsIFwicHJvcHNcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgdHlwZW9mIFJlZmxlY3QgPT0gXCJvYmplY3RcIiAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QodSwgW10pO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBuID0geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGUsIFtdLCB1KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdS5jYWxsKCk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIG4gPSB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZS5jYWxsKHUucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgbiA9IHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGUoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBpZiAoeCAmJiBuICYmIHR5cGVvZiB4LnN0YWNrID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBmb3IgKHZhciBjID0geC5zdGFjay5zcGxpdChgXG5gKSwgTyA9IG4uc3RhY2suc3BsaXQoYFxuYCksIFMgPSBjLmxlbmd0aCAtIDEsIFIgPSBPLmxlbmd0aCAtIDE7IFMgPj0gMSAmJiBSID49IDAgJiYgY1tTXSAhPT0gT1tSXTsgKVxuICAgICAgICAgICAgUi0tO1xuICAgICAgICAgIGZvciAoOyBTID49IDEgJiYgUiA+PSAwOyBTLS0sIFItLSlcbiAgICAgICAgICAgIGlmIChjW1NdICE9PSBPW1JdKSB7XG4gICAgICAgICAgICAgIGlmIChTICE9PSAxIHx8IFIgIT09IDEpXG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChTLS0sIFItLSwgUiA8IDAgfHwgY1tTXSAhPT0gT1tSXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgUCA9IGBcbmAgKyBjW1NdLnJlcGxhY2UoXCIgYXQgbmV3IFwiLCBcIiBhdCBcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmRpc3BsYXlOYW1lICYmIFAuaW5jbHVkZXMoXCI8YW5vbnltb3VzPlwiKSAmJiAoUCA9IFAucmVwbGFjZShcIjxhbm9ueW1vdXM+XCIsIGUuZGlzcGxheU5hbWUpKSwgdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiICYmIE0uc2V0KGUsIFApLCBQO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChTID49IDEgJiYgUiA+PSAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIEsgPSAhMSwgWC5jdXJyZW50ID0gdiwgTWUoKSwgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwO1xuICAgICAgfVxuICAgICAgdmFyIEEgPSBlID8gZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWUgOiBcIlwiLCBPZSA9IEEgPyBXKEEpIDogXCJcIjtcbiAgICAgIHJldHVybiB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgJiYgTS5zZXQoZSwgT2UpLCBPZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQmUoZSwgciwgdCkge1xuICAgICAgcmV0dXJuIGRlKGUsICExKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVmUoZSkge1xuICAgICAgdmFyIHIgPSBlLnByb3RvdHlwZTtcbiAgICAgIHJldHVybiAhIShyICYmIHIuaXNSZWFjdENvbXBvbmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFUoZSwgciwgdCkge1xuICAgICAgaWYgKGUgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICBpZiAodHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gZGUoZSwgVmUoZSkpO1xuICAgICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBXKGUpO1xuICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgIGNhc2UgZzpcbiAgICAgICAgICByZXR1cm4gVyhcIlN1c3BlbnNlXCIpO1xuICAgICAgICBjYXNlIG86XG4gICAgICAgICAgcmV0dXJuIFcoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGUgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3dpdGNoIChlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBzOlxuICAgICAgICAgICAgcmV0dXJuIEJlKGUucmVuZGVyKTtcbiAgICAgICAgICBjYXNlIGE6XG4gICAgICAgICAgICByZXR1cm4gVShlLnR5cGUsIHIsIHQpO1xuICAgICAgICAgIGNhc2UgZDoge1xuICAgICAgICAgICAgdmFyIG4gPSBlLCBwID0gbi5fcGF5bG9hZCwgdiA9IG4uX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gVSh2KHApLCByLCB0KTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHZhciBCID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgbWUgPSB7fSwgZ2UgPSBsLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgZnVuY3Rpb24gVihlKSB7XG4gICAgICBpZiAoZSkge1xuICAgICAgICB2YXIgciA9IGUuX293bmVyLCB0ID0gVShlLnR5cGUsIGUuX3NvdXJjZSwgciA/IHIudHlwZSA6IG51bGwpO1xuICAgICAgICBnZS5zZXRFeHRyYVN0YWNrRnJhbWUodCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgZ2Uuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBxZShlLCByLCB0LCBuLCBwKSB7XG4gICAgICB7XG4gICAgICAgIHZhciB2ID0gRnVuY3Rpb24uY2FsbC5iaW5kKEIpO1xuICAgICAgICBmb3IgKHZhciB1IGluIGUpXG4gICAgICAgICAgaWYgKHYoZSwgdSkpIHtcbiAgICAgICAgICAgIHZhciBjID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlW3VdICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBPID0gRXJyb3IoKG4gfHwgXCJSZWFjdCBjbGFzc1wiKSArIFwiOiBcIiArIHQgKyBcIiB0eXBlIGBcIiArIHUgKyBcImAgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYFwiICsgdHlwZW9mIGVbdV0gKyBcImAuVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuXCIpO1xuICAgICAgICAgICAgICAgIHRocm93IE8ubmFtZSA9IFwiSW52YXJpYW50IFZpb2xhdGlvblwiLCBPO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGMgPSBlW3VdKHIsIHUsIG4sIHQsIG51bGwsIFwiU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRURcIik7XG4gICAgICAgICAgICB9IGNhdGNoIChTKSB7XG4gICAgICAgICAgICAgIGMgPSBTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYyAmJiAhKGMgaW5zdGFuY2VvZiBFcnJvcikgJiYgKFYocCksIGYoXCIlczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciBmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCBzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuXCIsIG4gfHwgXCJSZWFjdCBjbGFzc1wiLCB0LCB1LCB0eXBlb2YgYyksIFYobnVsbCkpLCBjIGluc3RhbmNlb2YgRXJyb3IgJiYgIShjLm1lc3NhZ2UgaW4gbWUpICYmIChtZVtjLm1lc3NhZ2VdID0gITAsIFYocCksIGYoXCJGYWlsZWQgJXMgdHlwZTogJXNcIiwgdCwgYy5tZXNzYWdlKSwgVihudWxsKSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgWWUgPSBBcnJheS5pc0FycmF5O1xuICAgIGZ1bmN0aW9uIFEoZSkge1xuICAgICAgcmV0dXJuIFllKGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBIZShlKSB7XG4gICAgICB7XG4gICAgICAgIHZhciByID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLnRvU3RyaW5nVGFnLCB0ID0gciAmJiBlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgZS5jb25zdHJ1Y3Rvci5uYW1lIHx8IFwiT2JqZWN0XCI7XG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBYZShlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdmUoZSksICExO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdmUoZSkge1xuICAgICAgcmV0dXJuIFwiXCIgKyBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoZShlKSB7XG4gICAgICBpZiAoWGUoZSkpXG4gICAgICAgIHJldHVybiBmKFwiVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsIEhlKGUpKSwgdmUoZSk7XG4gICAgfVxuICAgIHZhciBMID0gbC5SZWFjdEN1cnJlbnRPd25lciwgSmUgPSB7XG4gICAgICBrZXk6ICEwLFxuICAgICAgcmVmOiAhMCxcbiAgICAgIF9fc2VsZjogITAsXG4gICAgICBfX3NvdXJjZTogITBcbiAgICB9LCBiZSwgd2UsIFo7XG4gICAgWiA9IHt9O1xuICAgIGZ1bmN0aW9uIEtlKGUpIHtcbiAgICAgIGlmIChCLmNhbGwoZSwgXCJyZWZcIikpIHtcbiAgICAgICAgdmFyIHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIFwicmVmXCIpLmdldDtcbiAgICAgICAgaWYgKHIgJiYgci5pc1JlYWN0V2FybmluZylcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gZS5yZWYgIT09IHZvaWQgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUWUoZSkge1xuICAgICAgaWYgKEIuY2FsbChlLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgXCJrZXlcIikuZ2V0O1xuICAgICAgICBpZiAociAmJiByLmlzUmVhY3RXYXJuaW5nKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlLmtleSAhPT0gdm9pZCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBaZShlLCByKSB7XG4gICAgICBpZiAodHlwZW9mIGUucmVmID09IFwic3RyaW5nXCIgJiYgTC5jdXJyZW50ICYmIHIgJiYgTC5jdXJyZW50LnN0YXRlTm9kZSAhPT0gcikge1xuICAgICAgICB2YXIgdCA9ICQoTC5jdXJyZW50LnR5cGUpO1xuICAgICAgICBaW3RdIHx8IChmKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuIFRoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uIFdlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiBMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgJChMLmN1cnJlbnQudHlwZSksIGUucmVmKSwgWlt0XSA9ICEwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gR2UoZSwgcikge1xuICAgICAge1xuICAgICAgICB2YXIgdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGJlIHx8IChiZSA9ICEwLCBmKFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcylcIiwgcikpO1xuICAgICAgICB9O1xuICAgICAgICB0LmlzUmVhY3RXYXJuaW5nID0gITAsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImtleVwiLCB7XG4gICAgICAgICAgZ2V0OiB0LFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVyKGUsIHIpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB3ZSB8fCAod2UgPSAhMCwgZihcIiVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpXCIsIHIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdC5pc1JlYWN0V2FybmluZyA9ICEwLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJyZWZcIiwge1xuICAgICAgICAgIGdldDogdCxcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcnIgPSBmdW5jdGlvbihlLCByLCB0LCBuLCBwLCB2LCB1KSB7XG4gICAgICB2YXIgYyA9IHtcbiAgICAgICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgICAgICQkdHlwZW9mOiBtLFxuICAgICAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgICAgIHR5cGU6IGUsXG4gICAgICAgIGtleTogcixcbiAgICAgICAgcmVmOiB0LFxuICAgICAgICBwcm9wczogdSxcbiAgICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgICAgX293bmVyOiB2XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGMuX3N0b3JlID0ge30sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjLl9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogITFcbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYywgXCJfc2VsZlwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITEsXG4gICAgICAgIHZhbHVlOiBuXG4gICAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGMsIFwiX3NvdXJjZVwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITEsXG4gICAgICAgIHZhbHVlOiBwXG4gICAgICB9KSwgT2JqZWN0LmZyZWV6ZSAmJiAoT2JqZWN0LmZyZWV6ZShjLnByb3BzKSwgT2JqZWN0LmZyZWV6ZShjKSksIGM7XG4gICAgfTtcbiAgICBmdW5jdGlvbiB0cihlLCByLCB0LCBuLCBwKSB7XG4gICAgICB7XG4gICAgICAgIHZhciB2LCB1ID0ge30sIGMgPSBudWxsLCBPID0gbnVsbDtcbiAgICAgICAgdCAhPT0gdm9pZCAwICYmIChoZSh0KSwgYyA9IFwiXCIgKyB0KSwgUWUocikgJiYgKGhlKHIua2V5KSwgYyA9IFwiXCIgKyByLmtleSksIEtlKHIpICYmIChPID0gci5yZWYsIFplKHIsIHApKTtcbiAgICAgICAgZm9yICh2IGluIHIpXG4gICAgICAgICAgQi5jYWxsKHIsIHYpICYmICFKZS5oYXNPd25Qcm9wZXJ0eSh2KSAmJiAodVt2XSA9IHJbdl0pO1xuICAgICAgICBpZiAoZSAmJiBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgICAgIHZhciBTID0gZS5kZWZhdWx0UHJvcHM7XG4gICAgICAgICAgZm9yICh2IGluIFMpXG4gICAgICAgICAgICB1W3ZdID09PSB2b2lkIDAgJiYgKHVbdl0gPSBTW3ZdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyB8fCBPKSB7XG4gICAgICAgICAgdmFyIFIgPSB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlLmRpc3BsYXlOYW1lIHx8IGUubmFtZSB8fCBcIlVua25vd25cIiA6IGU7XG4gICAgICAgICAgYyAmJiBHZSh1LCBSKSwgTyAmJiBlcih1LCBSKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnIoZSwgYywgTywgcCwgbiwgTC5jdXJyZW50LCB1KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIEcgPSBsLlJlYWN0Q3VycmVudE93bmVyLCBTZSA9IGwuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICBmdW5jdGlvbiBOKGUpIHtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIHZhciByID0gZS5fb3duZXIsIHQgPSBVKGUudHlwZSwgZS5fc291cmNlLCByID8gci50eXBlIDogbnVsbCk7XG4gICAgICAgIFNlLnNldEV4dHJhU3RhY2tGcmFtZSh0KTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBTZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICAgIHZhciBlZTtcbiAgICBlZSA9ICExO1xuICAgIGZ1bmN0aW9uIHJlKGUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIGUgIT09IG51bGwgJiYgZS4kJHR5cGVvZiA9PT0gbTtcbiAgICB9XG4gICAgZnVuY3Rpb24ga2UoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChHLmN1cnJlbnQpIHtcbiAgICAgICAgICB2YXIgZSA9ICQoRy5jdXJyZW50LnR5cGUpO1xuICAgICAgICAgIGlmIChlKVxuICAgICAgICAgICAgcmV0dXJuIGBcblxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgXFxgYCArIGUgKyBcImAuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5yKGUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGUgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHZhciByID0gZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCBcIlwiKSwgdCA9IGUubGluZU51bWJlcjtcbiAgICAgICAgICByZXR1cm4gYFxuXG5DaGVjayB5b3VyIGNvZGUgYXQgYCArIHIgKyBcIjpcIiArIHQgKyBcIi5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIFJlID0ge307XG4gICAgZnVuY3Rpb24gb3IoZSkge1xuICAgICAge1xuICAgICAgICB2YXIgciA9IGtlKCk7XG4gICAgICAgIGlmICghcikge1xuICAgICAgICAgIHZhciB0ID0gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IGUgOiBlLmRpc3BsYXlOYW1lIHx8IGUubmFtZTtcbiAgICAgICAgICB0ICYmIChyID0gYFxuXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxgICsgdCArIFwiPi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9lKGUsIHIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFlLl9zdG9yZSB8fCBlLl9zdG9yZS52YWxpZGF0ZWQgfHwgZS5rZXkgIT0gbnVsbClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGUuX3N0b3JlLnZhbGlkYXRlZCA9ICEwO1xuICAgICAgICB2YXIgdCA9IG9yKHIpO1xuICAgICAgICBpZiAoUmVbdF0pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBSZVt0XSA9ICEwO1xuICAgICAgICB2YXIgbiA9IFwiXCI7XG4gICAgICAgIGUgJiYgZS5fb3duZXIgJiYgZS5fb3duZXIgIT09IEcuY3VycmVudCAmJiAobiA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgJChlLl9vd25lci50eXBlKSArIFwiLlwiKSwgTihlKSwgZignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLiVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgdCwgbiksIE4obnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIEVlKGUsIHIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlICE9IFwib2JqZWN0XCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoUShlKSlcbiAgICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IGUubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIHZhciBuID0gZVt0XTtcbiAgICAgICAgICAgIHJlKG4pICYmIF9lKG4sIHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmUoZSkpXG4gICAgICAgICAgZS5fc3RvcmUgJiYgKGUuX3N0b3JlLnZhbGlkYXRlZCA9ICEwKTtcbiAgICAgICAgZWxzZSBpZiAoZSkge1xuICAgICAgICAgIHZhciBwID0gRChlKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHAgPT0gXCJmdW5jdGlvblwiICYmIHAgIT09IGUuZW50cmllcylcbiAgICAgICAgICAgIGZvciAodmFyIHYgPSBwLmNhbGwoZSksIHU7ICEodSA9IHYubmV4dCgpKS5kb25lOyApXG4gICAgICAgICAgICAgIHJlKHUudmFsdWUpICYmIF9lKHUudmFsdWUsIHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyKGUpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHIgPSBlLnR5cGU7XG4gICAgICAgIGlmIChyID09IG51bGwgfHwgdHlwZW9mIHIgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciB0O1xuICAgICAgICBpZiAodHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHQgPSByLnByb3BUeXBlcztcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHIgPT0gXCJvYmplY3RcIiAmJiAoci4kJHR5cGVvZiA9PT0gcyB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgICAgICByLiQkdHlwZW9mID09PSBhKSlcbiAgICAgICAgICB0ID0gci5wcm9wVHlwZXM7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgdmFyIG4gPSAkKHIpO1xuICAgICAgICAgIHFlKHQsIGUucHJvcHMsIFwicHJvcFwiLCBuLCBlKTtcbiAgICAgICAgfSBlbHNlIGlmIChyLlByb3BUeXBlcyAhPT0gdm9pZCAwICYmICFlZSkge1xuICAgICAgICAgIGVlID0gITA7XG4gICAgICAgICAgdmFyIHAgPSAkKHIpO1xuICAgICAgICAgIGYoXCJDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD9cIiwgcCB8fCBcIlVua25vd25cIik7XG4gICAgICAgIH1cbiAgICAgICAgdHlwZW9mIHIuZ2V0RGVmYXVsdFByb3BzID09IFwiZnVuY3Rpb25cIiAmJiAhci5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgJiYgZihcImdldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyBkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpcihlKSB7XG4gICAgICB7XG4gICAgICAgIGZvciAodmFyIHIgPSBPYmplY3Qua2V5cyhlLnByb3BzKSwgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgdmFyIG4gPSByW3RdO1xuICAgICAgICAgIGlmIChuICE9PSBcImNoaWxkcmVuXCIgJiYgbiAhPT0gXCJrZXlcIikge1xuICAgICAgICAgICAgTihlKSwgZihcIkludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuIFJlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuXCIsIG4pLCBOKG51bGwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGUucmVmICE9PSBudWxsICYmIChOKGUpLCBmKFwiSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC5cIiksIE4obnVsbCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBDZShlLCByLCB0LCBuLCBwLCB2KSB7XG4gICAgICB7XG4gICAgICAgIHZhciB1ID0gTGUoZSk7XG4gICAgICAgIGlmICghdSkge1xuICAgICAgICAgIHZhciBjID0gXCJcIjtcbiAgICAgICAgICAoZSA9PT0gdm9pZCAwIHx8IHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyhlKS5sZW5ndGggPT09IDApICYmIChjICs9IFwiIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlIGl0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIik7XG4gICAgICAgICAgdmFyIE8gPSBucihwKTtcbiAgICAgICAgICBPID8gYyArPSBPIDogYyArPSBrZSgpO1xuICAgICAgICAgIHZhciBTO1xuICAgICAgICAgIGUgPT09IG51bGwgPyBTID0gXCJudWxsXCIgOiBRKGUpID8gUyA9IFwiYXJyYXlcIiA6IGUgIT09IHZvaWQgMCAmJiBlLiQkdHlwZW9mID09PSBtID8gKFMgPSBcIjxcIiArICgkKGUudHlwZSkgfHwgXCJVbmtub3duXCIpICsgXCIgLz5cIiwgYyA9IFwiIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/XCIpIDogUyA9IHR5cGVvZiBlLCBmKFwiUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzXCIsIFMsIGMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBSID0gdHIoZSwgciwgdCwgcCwgdik7XG4gICAgICAgIGlmIChSID09IG51bGwpXG4gICAgICAgICAgcmV0dXJuIFI7XG4gICAgICAgIGlmICh1KSB7XG4gICAgICAgICAgdmFyIFAgPSByLmNoaWxkcmVuO1xuICAgICAgICAgIGlmIChQICE9PSB2b2lkIDApXG4gICAgICAgICAgICBpZiAobilcbiAgICAgICAgICAgICAgaWYgKFEoUCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBBID0gMDsgQSA8IFAubGVuZ3RoOyBBKyspXG4gICAgICAgICAgICAgICAgICBFZShQW0FdLCBlKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZnJlZXplICYmIE9iamVjdC5mcmVlemUoUCk7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIGYoXCJSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiBZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuIFVzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBFZShQLCBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZSA9PT0gYiA/IGlyKFIpIDogYXIoUiksIFI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyKGUsIHIsIHQpIHtcbiAgICAgIHJldHVybiBDZShlLCByLCB0LCAhMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxyKGUsIHIsIHQpIHtcbiAgICAgIHJldHVybiBDZShlLCByLCB0LCAhMSk7XG4gICAgfVxuICAgIHZhciBzciA9IGxyLCB1ciA9IGNyO1xuICAgIHEuRnJhZ21lbnQgPSBiLCBxLmpzeCA9IHNyLCBxLmpzeHMgPSB1cjtcbiAgfSgpKSwgcTtcbn1cbnByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IG5lLmV4cG9ydHMgPSBkcigpIDogbmUuZXhwb3J0cyA9IG1yKCk7XG52YXIgJGUgPSBuZS5leHBvcnRzO1xuY29uc3QgZ3IgPSAoeSwgbSwgXywgYikgPT4ge1xuICBsZXQgaCA9IG0gLyAoXyArIGIpLCB3ID0gTWF0aC5mbG9vcih5Lmxlbmd0aCAvIGgpO1xuICBoID4geS5sZW5ndGggJiYgKGggPSB5Lmxlbmd0aCwgdyA9IDEpO1xuICBjb25zdCBrID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaDsgaSsrKSB7XG4gICAgbGV0IHMgPSAwO1xuICAgIGZvciAobGV0IGcgPSAwOyBnIDwgdyAmJiBpICogdyArIGcgPCB5Lmxlbmd0aDsgZysrKVxuICAgICAgcyArPSB5W2kgKiB3ICsgZ107XG4gICAgay5wdXNoKHMgLyB3KTtcbiAgfVxuICByZXR1cm4gaztcbn0sIHZyID0gKHksIG0sIF8sIGIsIGgsIHcpID0+IHtcbiAgY29uc3QgayA9IG0uaGVpZ2h0IC8gMiwgaSA9IG0uZ2V0Q29udGV4dChcIjJkXCIpO1xuICBpICYmIChpLmNsZWFyUmVjdCgwLCAwLCBtLndpZHRoLCBtLmhlaWdodCksIGggIT09IFwidHJhbnNwYXJlbnRcIiAmJiAoaS5maWxsU3R5bGUgPSBoLCBpLmZpbGxSZWN0KDAsIDAsIG0ud2lkdGgsIG0uaGVpZ2h0KSksIHkuZm9yRWFjaCgocywgZykgPT4ge1xuICAgIGkuZmlsbFN0eWxlID0gdztcbiAgICBjb25zdCBvID0gZyAqIChfICsgYiksIGEgPSBrIC0gcyAvIDIsIGQgPSBfLCBFID0gcyB8fCAxO1xuICAgIGkuYmVnaW5QYXRoKCksIGkucm91bmRSZWN0ID8gKGkucm91bmRSZWN0KG8sIGEsIGQsIEUsIDUwKSwgaS5maWxsKCkpIDogaS5maWxsUmVjdChvLCBhLCBkLCBFKTtcbiAgfSkpO1xufSwgU3IgPSAoe1xuICBtZWRpYVJlY29yZGVyOiB5LFxuICB3aWR0aDogbSA9IFwiMTAwJVwiLFxuICBoZWlnaHQ6IF8gPSBcIjEwMCVcIixcbiAgYmFyV2lkdGg6IGIgPSAyLFxuICBnYXA6IGggPSAxLFxuICBiYWNrZ3JvdW5kQ29sb3I6IHcgPSBcInRyYW5zcGFyZW50XCIsXG4gIGJhckNvbG9yOiBrID0gXCJyZ2IoMTYwLCAxOTgsIDI1NSlcIixcbiAgZmZ0U2l6ZTogaSA9IDEwMjQsXG4gIG1heERlY2liZWxzOiBzID0gLTEwLFxuICBtaW5EZWNpYmVsczogZyA9IC05MCxcbiAgc21vb3RoaW5nVGltZUNvbnN0YW50OiBvID0gMC40XG59KSA9PiB7XG4gIGNvbnN0IFthXSA9IFkoKCkgPT4gbmV3IEF1ZGlvQ29udGV4dCgpKSwgW2QsIEVdID0gWSgpLCBDID0gRGUobnVsbCk7XG4gIEgoKCkgPT4ge1xuICAgIGlmICgheS5zdHJlYW0pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbCA9IGEuY3JlYXRlQW5hbHlzZXIoKTtcbiAgICBFKGwpLCBsLmZmdFNpemUgPSBpLCBsLm1pbkRlY2liZWxzID0gZywgbC5tYXhEZWNpYmVscyA9IHMsIGwuc21vb3RoaW5nVGltZUNvbnN0YW50ID0gbywgYS5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZSh5LnN0cmVhbSkuY29ubmVjdChsKTtcbiAgfSwgW3kuc3RyZWFtXSksIEgoKCkgPT4ge1xuICAgIGQgJiYgeS5zdGF0ZSA9PT0gXCJyZWNvcmRpbmdcIiAmJiBUKCk7XG4gIH0sIFtkLCB5LnN0YXRlXSk7XG4gIGNvbnN0IFQgPSBmcigoKSA9PiB7XG4gICAgaWYgKCFkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGwgPSBuZXcgVWludDhBcnJheShkID09IG51bGwgPyB2b2lkIDAgOiBkLmZyZXF1ZW5jeUJpbkNvdW50KTtcbiAgICB5LnN0YXRlID09PSBcInJlY29yZGluZ1wiID8gKGQgPT0gbnVsbCB8fCBkLmdldEJ5dGVGcmVxdWVuY3lEYXRhKGwpLCBEKGwpLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoVCkpIDogeS5zdGF0ZSA9PT0gXCJwYXVzZWRcIiA/IEQobCkgOiB5LnN0YXRlID09PSBcImluYWN0aXZlXCIgJiYgYS5zdGF0ZSAhPT0gXCJjbG9zZWRcIiAmJiBhLmNsb3NlKCk7XG4gIH0sIFtkLCBhLnN0YXRlXSksIEQgPSAobCkgPT4ge1xuICAgIGlmICghQy5jdXJyZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGYgPSBncihcbiAgICAgIGwsXG4gICAgICBDLmN1cnJlbnQud2lkdGgsXG4gICAgICBiLFxuICAgICAgaFxuICAgICk7XG4gICAgdnIoXG4gICAgICBmLFxuICAgICAgQy5jdXJyZW50LFxuICAgICAgYixcbiAgICAgIGgsXG4gICAgICB3LFxuICAgICAga1xuICAgICk7XG4gIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gJGUuanN4KFxuICAgIFwiY2FudmFzXCIsXG4gICAge1xuICAgICAgcmVmOiBDLFxuICAgICAgd2lkdGg6IG0sXG4gICAgICBoZWlnaHQ6IF8sXG4gICAgICBzdHlsZToge1xuICAgICAgICBhc3BlY3RSYXRpbzogXCJ1bnNldFwiXG4gICAgICB9XG4gICAgfVxuICApO1xufSwgaHIgPSAoeSwgbSwgXywgYiwgaCkgPT4ge1xuICBjb25zdCB3ID0geS5nZXRDaGFubmVsRGF0YSgwKSwgayA9IF8gLyAoYiArIGgpLCBpID0gTWF0aC5mbG9vcih3Lmxlbmd0aCAvIGspLCBzID0gbSAvIDI7XG4gIGxldCBnID0gW10sIG8gPSAwO1xuICBmb3IgKGxldCBhID0gMDsgYSA8IGs7IGErKykge1xuICAgIGNvbnN0IGQgPSBbXTtcbiAgICBsZXQgRSA9IDA7XG4gICAgY29uc3QgQyA9IFtdO1xuICAgIGxldCBUID0gMDtcbiAgICBmb3IgKGxldCBmID0gMDsgZiA8IGkgJiYgYSAqIGkgKyBmIDwgeS5sZW5ndGg7IGYrKykge1xuICAgICAgY29uc3QgaiA9IHdbYSAqIGkgKyBmXTtcbiAgICAgIGogPD0gMCAmJiAoZC5wdXNoKGopLCBFKyspLCBqID4gMCAmJiAoQy5wdXNoKGopLCBUKyspO1xuICAgIH1cbiAgICBjb25zdCBEID0gZC5yZWR1Y2UoKGYsIGopID0+IGYgKyBqLCAwKSAvIEUsIGwgPSB7IG1heDogQy5yZWR1Y2UoKGYsIGopID0+IGYgKyBqLCAwKSAvIFQsIG1pbjogRCB9O1xuICAgIGwubWF4ID4gbyAmJiAobyA9IGwubWF4KSwgTWF0aC5hYnMobC5taW4pID4gbyAmJiAobyA9IE1hdGguYWJzKGwubWluKSksIGcucHVzaChsKTtcbiAgfVxuICBpZiAocyAqIDAuOCA+IG8gKiBzKSB7XG4gICAgY29uc3QgYSA9IHMgKiAwLjggLyBvO1xuICAgIGcgPSBnLm1hcCgoZCkgPT4gKHtcbiAgICAgIG1heDogZC5tYXggKiBhLFxuICAgICAgbWluOiBkLm1pbiAqIGFcbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIGc7XG59LCB0ZSA9ICh5LCBtLCBfLCBiLCBoLCB3LCBrLCBpID0gMCwgcyA9IDEpID0+IHtcbiAgY29uc3QgZyA9IG0uaGVpZ2h0IC8gMiwgbyA9IG0uZ2V0Q29udGV4dChcIjJkXCIpO1xuICBpZiAoIW8pXG4gICAgcmV0dXJuO1xuICBvLmNsZWFyUmVjdCgwLCAwLCBtLndpZHRoLCBtLmhlaWdodCksIGggIT09IFwidHJhbnNwYXJlbnRcIiAmJiAoby5maWxsU3R5bGUgPSBoLCBvLmZpbGxSZWN0KDAsIDAsIG0ud2lkdGgsIG0uaGVpZ2h0KSk7XG4gIGNvbnN0IGEgPSAoaSB8fCAwKSAvIHM7XG4gIHkuZm9yRWFjaCgoZCwgRSkgPT4ge1xuICAgIGNvbnN0IEMgPSBFIC8geS5sZW5ndGgsIFQgPSBhID4gQztcbiAgICBvLmZpbGxTdHlsZSA9IFQgJiYgayA/IGsgOiB3O1xuICAgIGNvbnN0IEQgPSBFICogKF8gKyBiKSwgbCA9IGcgKyBkLm1pbiwgZiA9IF8sIGogPSBnICsgZC5tYXggLSBsO1xuICAgIG8uYmVnaW5QYXRoKCksIG8ucm91bmRSZWN0ID8gKG8ucm91bmRSZWN0KEQsIGwsIGYsIGosIDUwKSwgby5maWxsKCkpIDogby5maWxsUmVjdChELCBsLCBmLCBqKTtcbiAgfSk7XG59LCBiciA9IHByKFxuICAoe1xuICAgIGJsb2I6IHksXG4gICAgd2lkdGg6IG0sXG4gICAgaGVpZ2h0OiBfLFxuICAgIGJhcldpZHRoOiBiID0gMixcbiAgICBnYXA6IGggPSAxLFxuICAgIGN1cnJlbnRUaW1lOiB3LFxuICAgIHN0eWxlOiBrLFxuICAgIGJhY2tncm91bmRDb2xvcjogaSA9IFwidHJhbnNwYXJlbnRcIixcbiAgICBiYXJDb2xvcjogcyA9IFwicmdiKDE4NCwgMTg0LCAxODQpXCIsXG4gICAgYmFyUGxheWVkQ29sb3I6IGcgPSBcInJnYigxNjAsIDE5OCwgMjU1KVwiXG4gIH0sIG8pID0+IHtcbiAgICBjb25zdCBhID0gRGUobnVsbCksIFtkLCBFXSA9IFkoW10pLCBbQywgVF0gPSBZKDApO1xuICAgIHJldHVybiB5cihcbiAgICAgIG8sXG4gICAgICAoKSA9PiBhLmN1cnJlbnQsXG4gICAgICBbXVxuICAgICksIEgoKCkgPT4ge1xuICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKCFhLmN1cnJlbnQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXkpIHtcbiAgICAgICAgICBjb25zdCBsID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwIH0sICgpID0+ICh7XG4gICAgICAgICAgICBtYXg6IDAsXG4gICAgICAgICAgICBtaW46IDBcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgdGUoXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgYS5jdXJyZW50LFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGgsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgcyxcbiAgICAgICAgICAgIGdcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBEID0gYXdhaXQgeS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICBhd2FpdCBuZXcgQXVkaW9Db250ZXh0KCkuZGVjb2RlQXVkaW9EYXRhKEQsIChsKSA9PiB7XG4gICAgICAgICAgaWYgKCFhLmN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgVChsLmR1cmF0aW9uKTtcbiAgICAgICAgICBjb25zdCBmID0gaHIoXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgXyxcbiAgICAgICAgICAgIG0sXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgaFxuICAgICAgICAgICk7XG4gICAgICAgICAgRShmKSwgdGUoXG4gICAgICAgICAgICBmLFxuICAgICAgICAgICAgYS5jdXJyZW50LFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGgsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgcyxcbiAgICAgICAgICAgIGdcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0pKCk7XG4gICAgfSwgW3ksIGEuY3VycmVudF0pLCBIKCgpID0+IHtcbiAgICAgIGEuY3VycmVudCAmJiB0ZShcbiAgICAgICAgZCxcbiAgICAgICAgYS5jdXJyZW50LFxuICAgICAgICBiLFxuICAgICAgICBoLFxuICAgICAgICBpLFxuICAgICAgICBzLFxuICAgICAgICBnLFxuICAgICAgICB3LFxuICAgICAgICBDXG4gICAgICApO1xuICAgIH0sIFt3LCBDXSksIC8qIEBfX1BVUkVfXyAqLyAkZS5qc3goXG4gICAgICBcImNhbnZhc1wiLFxuICAgICAge1xuICAgICAgICByZWY6IGEsXG4gICAgICAgIHdpZHRoOiBtLFxuICAgICAgICBoZWlnaHQ6IF8sXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgLi4ua1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgfVxuKTtcbmJyLmRpc3BsYXlOYW1lID0gXCJBdWRpb1Zpc3VhbGl6ZXJcIjtcbmV4cG9ydCB7XG4gIGJyIGFzIEF1ZGlvVmlzdWFsaXplcixcbiAgU3IgYXMgTGl2ZUF1ZGlvVmlzdWFsaXplclxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-audio-voice-recorder@2.2.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-audio-voice-recorder/dist/react-audio-visualize.es-69216c73.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/react-audio-voice-recorder@2.2.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-audio-voice-recorder/dist/react-audio-voice-recorder.es.js":
/*!***************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-audio-voice-recorder@2.2.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-audio-voice-recorder/dist/react-audio-voice-recorder.es.js ***!
  \***************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioRecorder: () => (/* binding */ pr),\n/* harmony export */   useAudioRecorder: () => (/* binding */ gr)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@14.2.3_@opentelemetry+api@1.9.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n(function(){\"use strict\";(r=>{try{if(typeof window>\"u\")return;var e=document.createElement(\"style\");e.appendChild(document.createTextNode(r)),document.head.appendChild(e)}catch(i){console.error(\"vite-plugin-css-injected-by-js\",i)}})(\".audio-recorder{background-color:#ebebeb;box-shadow:0 2px 5px #bebebe;border-radius:20px;box-sizing:border-box;color:#000;width:40px;display:flex;align-items:center;transition:all .2s ease-in;-webkit-tap-highlight-color:transparent}.audio-recorder-mic{box-sizing:content-box;cursor:pointer;height:16px;color:#000;padding:12px}.audio-recorder .audio-recorder-mic{border-radius:20px}.audio-recorder.recording .audio-recorder-mic{border-radius:0}.audio-recorder-timer,.audio-recorder-status{color:#000;margin-left:10px;font-family:Segoe UI,Tahoma,Geneva,Verdana,sans-serif;font-size:14px;font-weight:400;line-height:1}.audio-recorder-status{margin-left:15px;display:flex;align-items:baseline;flex-grow:1;animation-name:fading-ar-status;animation-duration:2s;animation-iteration-count:infinite}.audio-recorder-status-dot{background-color:#d00;border-radius:50%;height:10px;width:9px;margin-right:5px}.audio-recorder-options{box-sizing:content-box;height:16px;cursor:pointer;padding:12px 6px 12px 12px}.audio-recorder-options~.audio-recorder-options{padding:12px 12px 12px 6px;border-radius:0 5px 5px 0}.recording{border-radius:12px;width:300px;transition:all .2s ease-out}.display-none{display:none}.audio-recorder-visualizer{margin-left:15px;flex-grow:1;align-self:center;display:flex;align-items:center}@keyframes fading-ar-status{0%{opacity:1}50%{opacity:0}to{opacity:1}}\")})();\n\nvar de = { exports: {} }, H = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar ke;\nfunction fr() {\n  if (ke)\n    return H;\n  ke = 1;\n  var D = react__WEBPACK_IMPORTED_MODULE_0__, j = Symbol.for(\"react.element\"), z = Symbol.for(\"react.fragment\"), E = Object.prototype.hasOwnProperty, I = D.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, C = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function y(T, i, c) {\n    var d, v = {}, M = null, m = null;\n    c !== void 0 && (M = \"\" + c), i.key !== void 0 && (M = \"\" + i.key), i.ref !== void 0 && (m = i.ref);\n    for (d in i)\n      E.call(i, d) && !C.hasOwnProperty(d) && (v[d] = i[d]);\n    if (T && T.defaultProps)\n      for (d in i = T.defaultProps, i)\n        v[d] === void 0 && (v[d] = i[d]);\n    return { $$typeof: j, type: T, key: M, ref: m, props: v, _owner: I.current };\n  }\n  return H.Fragment = z, H.jsx = y, H.jsxs = y, H;\n}\nvar $ = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar _e;\nfunction dr() {\n  return _e || (_e = 1,  true && function() {\n    var D = react__WEBPACK_IMPORTED_MODULE_0__, j = Symbol.for(\"react.element\"), z = Symbol.for(\"react.portal\"), E = Symbol.for(\"react.fragment\"), I = Symbol.for(\"react.strict_mode\"), C = Symbol.for(\"react.profiler\"), y = Symbol.for(\"react.provider\"), T = Symbol.for(\"react.context\"), i = Symbol.for(\"react.forward_ref\"), c = Symbol.for(\"react.suspense\"), d = Symbol.for(\"react.suspense_list\"), v = Symbol.for(\"react.memo\"), M = Symbol.for(\"react.lazy\"), m = Symbol.for(\"react.offscreen\"), _ = Symbol.iterator, A = \"@@iterator\";\n    function O(e) {\n      if (e === null || typeof e != \"object\")\n        return null;\n      var r = _ && e[_] || e[A];\n      return typeof r == \"function\" ? r : null;\n    }\n    var h = D.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function g(e) {\n      {\n        for (var r = arguments.length, t = new Array(r > 1 ? r - 1 : 0), a = 1; a < r; a++)\n          t[a - 1] = arguments[a];\n        V(\"error\", e, t);\n      }\n    }\n    function V(e, r, t) {\n      {\n        var a = h.ReactDebugCurrentFrame, u = a.getStackAddendum();\n        u !== \"\" && (r += \"%s\", t = t.concat([u]));\n        var s = t.map(function(o) {\n          return String(o);\n        });\n        s.unshift(\"Warning: \" + r), Function.prototype.apply.call(console[e], console, s);\n      }\n    }\n    var p = !1, R = !1, x = !1, Q = !1, P = !1, Y;\n    Y = Symbol.for(\"react.module.reference\");\n    function L(e) {\n      return !!(typeof e == \"string\" || typeof e == \"function\" || e === E || e === C || P || e === I || e === c || e === d || Q || e === m || p || R || x || typeof e == \"object\" && e !== null && (e.$$typeof === M || e.$$typeof === v || e.$$typeof === y || e.$$typeof === T || e.$$typeof === i || // This needs to include all possible module reference object\n      // types supported by any Flight configuration anywhere since\n      // we don't know which Flight build this will end up being used\n      // with.\n      e.$$typeof === Y || e.getModuleId !== void 0));\n    }\n    function te(e, r, t) {\n      var a = e.displayName;\n      if (a)\n        return a;\n      var u = r.displayName || r.name || \"\";\n      return u !== \"\" ? t + \"(\" + u + \")\" : t;\n    }\n    function ae(e) {\n      return e.displayName || \"Context\";\n    }\n    function S(e) {\n      if (e == null)\n        return null;\n      if (typeof e.tag == \"number\" && g(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof e == \"function\")\n        return e.displayName || e.name || null;\n      if (typeof e == \"string\")\n        return e;\n      switch (e) {\n        case E:\n          return \"Fragment\";\n        case z:\n          return \"Portal\";\n        case C:\n          return \"Profiler\";\n        case I:\n          return \"StrictMode\";\n        case c:\n          return \"Suspense\";\n        case d:\n          return \"SuspenseList\";\n      }\n      if (typeof e == \"object\")\n        switch (e.$$typeof) {\n          case T:\n            var r = e;\n            return ae(r) + \".Consumer\";\n          case y:\n            var t = e;\n            return ae(t._context) + \".Provider\";\n          case i:\n            return te(e, e.render, \"ForwardRef\");\n          case v:\n            var a = e.displayName || null;\n            return a !== null ? a : S(e.type) || \"Memo\";\n          case M: {\n            var u = e, s = u._payload, o = u._init;\n            try {\n              return S(o(s));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var W = Object.assign, U = 0, ve, Me, me, we, ye, je, Ce;\n    function pe() {\n    }\n    pe.__reactDisabledLog = !0;\n    function Pe() {\n      {\n        if (U === 0) {\n          ve = console.log, Me = console.info, me = console.warn, we = console.error, ye = console.group, je = console.groupCollapsed, Ce = console.groupEnd;\n          var e = {\n            configurable: !0,\n            enumerable: !0,\n            value: pe,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: e,\n            log: e,\n            warn: e,\n            error: e,\n            group: e,\n            groupCollapsed: e,\n            groupEnd: e\n          });\n        }\n        U++;\n      }\n    }\n    function Ye() {\n      {\n        if (U--, U === 0) {\n          var e = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: W({}, e, {\n              value: ve\n            }),\n            info: W({}, e, {\n              value: Me\n            }),\n            warn: W({}, e, {\n              value: me\n            }),\n            error: W({}, e, {\n              value: we\n            }),\n            group: W({}, e, {\n              value: ye\n            }),\n            groupCollapsed: W({}, e, {\n              value: je\n            }),\n            groupEnd: W({}, e, {\n              value: Ce\n            })\n          });\n        }\n        U < 0 && g(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var ie = h.ReactCurrentDispatcher, ne;\n    function X(e, r, t) {\n      {\n        if (ne === void 0)\n          try {\n            throw Error();\n          } catch (u) {\n            var a = u.stack.trim().match(/\\n( *(at )?)/);\n            ne = a && a[1] || \"\";\n          }\n        return `\n` + ne + e;\n      }\n    }\n    var oe = !1, K;\n    {\n      var We = typeof WeakMap == \"function\" ? WeakMap : Map;\n      K = new We();\n    }\n    function be(e, r) {\n      if (!e || oe)\n        return \"\";\n      {\n        var t = K.get(e);\n        if (t !== void 0)\n          return t;\n      }\n      var a;\n      oe = !0;\n      var u = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var s;\n      s = ie.current, ie.current = null, Pe();\n      try {\n        if (r) {\n          var o = function() {\n            throw Error();\n          };\n          if (Object.defineProperty(o.prototype, \"props\", {\n            set: function() {\n              throw Error();\n            }\n          }), typeof Reflect == \"object\" && Reflect.construct) {\n            try {\n              Reflect.construct(o, []);\n            } catch (k) {\n              a = k;\n            }\n            Reflect.construct(e, [], o);\n          } else {\n            try {\n              o.call();\n            } catch (k) {\n              a = k;\n            }\n            e.call(o.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (k) {\n            a = k;\n          }\n          e();\n        }\n      } catch (k) {\n        if (k && a && typeof k.stack == \"string\") {\n          for (var n = k.stack.split(`\n`), w = a.stack.split(`\n`), l = n.length - 1, f = w.length - 1; l >= 1 && f >= 0 && n[l] !== w[f]; )\n            f--;\n          for (; l >= 1 && f >= 0; l--, f--)\n            if (n[l] !== w[f]) {\n              if (l !== 1 || f !== 1)\n                do\n                  if (l--, f--, f < 0 || n[l] !== w[f]) {\n                    var b = `\n` + n[l].replace(\" at new \", \" at \");\n                    return e.displayName && b.includes(\"<anonymous>\") && (b = b.replace(\"<anonymous>\", e.displayName)), typeof e == \"function\" && K.set(e, b), b;\n                  }\n                while (l >= 1 && f >= 0);\n              break;\n            }\n        }\n      } finally {\n        oe = !1, ie.current = s, Ye(), Error.prepareStackTrace = u;\n      }\n      var F = e ? e.displayName || e.name : \"\", Oe = F ? X(F) : \"\";\n      return typeof e == \"function\" && K.set(e, Oe), Oe;\n    }\n    function Be(e, r, t) {\n      return be(e, !1);\n    }\n    function Ve(e) {\n      var r = e.prototype;\n      return !!(r && r.isReactComponent);\n    }\n    function q(e, r, t) {\n      if (e == null)\n        return \"\";\n      if (typeof e == \"function\")\n        return be(e, Ve(e));\n      if (typeof e == \"string\")\n        return X(e);\n      switch (e) {\n        case c:\n          return X(\"Suspense\");\n        case d:\n          return X(\"SuspenseList\");\n      }\n      if (typeof e == \"object\")\n        switch (e.$$typeof) {\n          case i:\n            return Be(e.render);\n          case v:\n            return q(e.type, r, t);\n          case M: {\n            var a = e, u = a._payload, s = a._init;\n            try {\n              return q(s(u), r, t);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var ee = Object.prototype.hasOwnProperty, Ne = {}, Ie = h.ReactDebugCurrentFrame;\n    function re(e) {\n      if (e) {\n        var r = e._owner, t = q(e.type, e._source, r ? r.type : null);\n        Ie.setExtraStackFrame(t);\n      } else\n        Ie.setExtraStackFrame(null);\n    }\n    function Qe(e, r, t, a, u) {\n      {\n        var s = Function.call.bind(ee);\n        for (var o in e)\n          if (s(e, o)) {\n            var n = void 0;\n            try {\n              if (typeof e[o] != \"function\") {\n                var w = Error((a || \"React class\") + \": \" + t + \" type `\" + o + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof e[o] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                throw w.name = \"Invariant Violation\", w;\n              }\n              n = e[o](r, o, a, t, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n            } catch (l) {\n              n = l;\n            }\n            n && !(n instanceof Error) && (re(u), g(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", a || \"React class\", t, o, typeof n), re(null)), n instanceof Error && !(n.message in Ne) && (Ne[n.message] = !0, re(u), g(\"Failed %s type: %s\", t, n.message), re(null));\n          }\n      }\n    }\n    var Ze = Array.isArray;\n    function ue(e) {\n      return Ze(e);\n    }\n    function Fe(e) {\n      {\n        var r = typeof Symbol == \"function\" && Symbol.toStringTag, t = r && e[Symbol.toStringTag] || e.constructor.name || \"Object\";\n        return t;\n      }\n    }\n    function Ue(e) {\n      try {\n        return Te(e), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function Te(e) {\n      return \"\" + e;\n    }\n    function Le(e) {\n      if (Ue(e))\n        return g(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", Fe(e)), Te(e);\n    }\n    var G = h.ReactCurrentOwner, Ge = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    }, Se, De, se;\n    se = {};\n    function Je(e) {\n      if (ee.call(e, \"ref\")) {\n        var r = Object.getOwnPropertyDescriptor(e, \"ref\").get;\n        if (r && r.isReactWarning)\n          return !1;\n      }\n      return e.ref !== void 0;\n    }\n    function He(e) {\n      if (ee.call(e, \"key\")) {\n        var r = Object.getOwnPropertyDescriptor(e, \"key\").get;\n        if (r && r.isReactWarning)\n          return !1;\n      }\n      return e.key !== void 0;\n    }\n    function $e(e, r) {\n      if (typeof e.ref == \"string\" && G.current && r && G.current.stateNode !== r) {\n        var t = S(G.current.type);\n        se[t] || (g('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', S(G.current.type), e.ref), se[t] = !0);\n      }\n    }\n    function Xe(e, r) {\n      {\n        var t = function() {\n          Se || (Se = !0, g(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", r));\n        };\n        t.isReactWarning = !0, Object.defineProperty(e, \"key\", {\n          get: t,\n          configurable: !0\n        });\n      }\n    }\n    function Ke(e, r) {\n      {\n        var t = function() {\n          De || (De = !0, g(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", r));\n        };\n        t.isReactWarning = !0, Object.defineProperty(e, \"ref\", {\n          get: t,\n          configurable: !0\n        });\n      }\n    }\n    var qe = function(e, r, t, a, u, s, o) {\n      var n = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: j,\n        // Built-in properties that belong on the element\n        type: e,\n        key: r,\n        ref: t,\n        props: o,\n        // Record the component responsible for creating this element.\n        _owner: s\n      };\n      return n._store = {}, Object.defineProperty(n._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty(n, \"_self\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: a\n      }), Object.defineProperty(n, \"_source\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: u\n      }), Object.freeze && (Object.freeze(n.props), Object.freeze(n)), n;\n    };\n    function er(e, r, t, a, u) {\n      {\n        var s, o = {}, n = null, w = null;\n        t !== void 0 && (Le(t), n = \"\" + t), He(r) && (Le(r.key), n = \"\" + r.key), Je(r) && (w = r.ref, $e(r, u));\n        for (s in r)\n          ee.call(r, s) && !Ge.hasOwnProperty(s) && (o[s] = r[s]);\n        if (e && e.defaultProps) {\n          var l = e.defaultProps;\n          for (s in l)\n            o[s] === void 0 && (o[s] = l[s]);\n        }\n        if (n || w) {\n          var f = typeof e == \"function\" ? e.displayName || e.name || \"Unknown\" : e;\n          n && Xe(o, f), w && Ke(o, f);\n        }\n        return qe(e, n, w, u, a, G.current, o);\n      }\n    }\n    var ce = h.ReactCurrentOwner, Ee = h.ReactDebugCurrentFrame;\n    function Z(e) {\n      if (e) {\n        var r = e._owner, t = q(e.type, e._source, r ? r.type : null);\n        Ee.setExtraStackFrame(t);\n      } else\n        Ee.setExtraStackFrame(null);\n    }\n    var le;\n    le = !1;\n    function fe(e) {\n      return typeof e == \"object\" && e !== null && e.$$typeof === j;\n    }\n    function he() {\n      {\n        if (ce.current) {\n          var e = S(ce.current.type);\n          if (e)\n            return `\n\nCheck the render method of \\`` + e + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function rr(e) {\n      {\n        if (e !== void 0) {\n          var r = e.fileName.replace(/^.*[\\\\\\/]/, \"\"), t = e.lineNumber;\n          return `\n\nCheck your code at ` + r + \":\" + t + \".\";\n        }\n        return \"\";\n      }\n    }\n    var Re = {};\n    function tr(e) {\n      {\n        var r = he();\n        if (!r) {\n          var t = typeof e == \"string\" ? e : e.displayName || e.name;\n          t && (r = `\n\nCheck the top-level render call using <` + t + \">.\");\n        }\n        return r;\n      }\n    }\n    function xe(e, r) {\n      {\n        if (!e._store || e._store.validated || e.key != null)\n          return;\n        e._store.validated = !0;\n        var t = tr(r);\n        if (Re[t])\n          return;\n        Re[t] = !0;\n        var a = \"\";\n        e && e._owner && e._owner !== ce.current && (a = \" It was passed a child from \" + S(e._owner.type) + \".\"), Z(e), g('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', t, a), Z(null);\n      }\n    }\n    function ze(e, r) {\n      {\n        if (typeof e != \"object\")\n          return;\n        if (ue(e))\n          for (var t = 0; t < e.length; t++) {\n            var a = e[t];\n            fe(a) && xe(a, r);\n          }\n        else if (fe(e))\n          e._store && (e._store.validated = !0);\n        else if (e) {\n          var u = O(e);\n          if (typeof u == \"function\" && u !== e.entries)\n            for (var s = u.call(e), o; !(o = s.next()).done; )\n              fe(o.value) && xe(o.value, r);\n        }\n      }\n    }\n    function ar(e) {\n      {\n        var r = e.type;\n        if (r == null || typeof r == \"string\")\n          return;\n        var t;\n        if (typeof r == \"function\")\n          t = r.propTypes;\n        else if (typeof r == \"object\" && (r.$$typeof === i || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        r.$$typeof === v))\n          t = r.propTypes;\n        else\n          return;\n        if (t) {\n          var a = S(r);\n          Qe(t, e.props, \"prop\", a, e);\n        } else if (r.PropTypes !== void 0 && !le) {\n          le = !0;\n          var u = S(r);\n          g(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", u || \"Unknown\");\n        }\n        typeof r.getDefaultProps == \"function\" && !r.getDefaultProps.isReactClassApproved && g(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n      }\n    }\n    function ir(e) {\n      {\n        for (var r = Object.keys(e.props), t = 0; t < r.length; t++) {\n          var a = r[t];\n          if (a !== \"children\" && a !== \"key\") {\n            Z(e), g(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", a), Z(null);\n            break;\n          }\n        }\n        e.ref !== null && (Z(e), g(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), Z(null));\n      }\n    }\n    function Ae(e, r, t, a, u, s) {\n      {\n        var o = L(e);\n        if (!o) {\n          var n = \"\";\n          (e === void 0 || typeof e == \"object\" && e !== null && Object.keys(e).length === 0) && (n += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var w = rr(u);\n          w ? n += w : n += he();\n          var l;\n          e === null ? l = \"null\" : ue(e) ? l = \"array\" : e !== void 0 && e.$$typeof === j ? (l = \"<\" + (S(e.type) || \"Unknown\") + \" />\", n = \" Did you accidentally export a JSX literal instead of a component?\") : l = typeof e, g(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", l, n);\n        }\n        var f = er(e, r, t, u, s);\n        if (f == null)\n          return f;\n        if (o) {\n          var b = r.children;\n          if (b !== void 0)\n            if (a)\n              if (ue(b)) {\n                for (var F = 0; F < b.length; F++)\n                  ze(b[F], e);\n                Object.freeze && Object.freeze(b);\n              } else\n                g(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              ze(b, e);\n        }\n        return e === E ? ir(f) : ar(f), f;\n      }\n    }\n    function nr(e, r, t) {\n      return Ae(e, r, t, !0);\n    }\n    function or(e, r, t) {\n      return Ae(e, r, t, !1);\n    }\n    var ur = or, sr = nr;\n    $.Fragment = E, $.jsx = ur, $.jsxs = sr;\n  }()), $;\n}\n false ? 0 : de.exports = dr();\nvar N = de.exports;\nconst gr = (D, j, z) => {\n  const [E, I] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [C, y] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [T, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0), [c, d] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), [v, M] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), [m, _] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), A = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    const p = setInterval(() => {\n      i((R) => R + 1);\n    }, 1e3);\n    M(p);\n  }, [i, M]), O = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    v != null && clearInterval(v), M(void 0);\n  }, [v, M]), h = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    v == null && navigator.mediaDevices.getUserMedia({ audio: D ?? !0 }).then((p) => {\n      I(!0);\n      const R = new MediaRecorder(\n        p,\n        z\n      );\n      d(R), R.start(), A(), R.addEventListener(\"dataavailable\", (x) => {\n        _(x.data), R.stream.getTracks().forEach((Q) => Q.stop()), d(void 0);\n      });\n    }).catch((p) => {\n      console.log(p.name, p.message, p.cause), j == null || j(p);\n    });\n  }, [\n    v,\n    I,\n    d,\n    A,\n    _,\n    j,\n    z\n  ]), g = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    c == null || c.stop(), O(), i(0), I(!1), y(!1);\n  }, [\n    c,\n    i,\n    I,\n    y,\n    O\n  ]), V = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    C ? (y(!1), c == null || c.resume(), A()) : (y(!0), O(), c == null || c.pause());\n  }, [c, y, A, O]);\n  return {\n    startRecording: h,\n    stopRecording: g,\n    togglePauseResume: V,\n    recordingBlob: m,\n    isRecording: E,\n    isPaused: C,\n    recordingTime: T,\n    mediaRecorder: c\n  };\n}, vr = \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTkuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiCgkgdmlld0JveD0iMCAwIDQ3MCA0NzAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDQ3MCA0NzA7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KCTxnPgoJCTxwYXRoIGQ9Ik0yMzUsMzAyLjI5NmM0Ny4xNzcsMCw4NS40MjMtMzguMjQ1LDg1LjQyMy04NS40MjNWODUuNDIzQzMyMC40MjMsMzguMjQ1LDI4Mi4xNzcsMCwyMzUsMHMtODUuNDIzLDM4LjI0NS04NS40MjMsODUuNDIzCgkJCXYxMzEuNDUxQzE0OS41NzcsMjY0LjA1MSwxODcuODIzLDMwMi4yOTYsMjM1LDMwMi4yOTZ6Ii8+CgkJPHBhdGggZD0iTTM1MC40MjMsMTM2LjE0OHYzMGgxNXY1MC43MjZjMCw3MS45MTUtNTguNTA4LDEzMC40MjMtMTMwLjQyMywxMzAuNDIzcy0xMzAuNDIzLTU4LjUwNy0xMzAuNDIzLTEzMC40MjN2LTUwLjcyNmgxNXYtMzAKCQkJaC00NXY4MC43MjZDNzQuNTc3LDMwMC4yNzMsMTM4LjU1MSwzNjksMjIwLDM3Ni41ODlWNDQwaC05MC40NDR2MzBoMjEwLjg4OXYtMzBIMjUwdi02My40MTEKCQkJYzgxLjQ0OS03LjU4OSwxNDUuNDIzLTc2LjMxNywxNDUuNDIzLTE1OS43MTZ2LTgwLjcyNkgzNTAuNDIzeiIvPgoJPC9nPgo8L3N2Zz4K\", Mr = \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTkuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB2aWV3Qm94PSIwIDAgNDcuNjA3IDQ3LjYwNyIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDcuNjA3IDQ3LjYwNzsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgoJPGc+CgkJPHBhdGggZD0iTTE3Ljk5MSw0MC45NzZjMCwzLjY2Mi0yLjk2OSw2LjYzMS02LjYzMSw2LjYzMWwwLDBjLTMuNjYyLDAtNi42MzEtMi45NjktNi42MzEtNi42MzFWNi42MzFDNC43MjksMi45NjksNy42OTgsMCwxMS4zNiwwCgkJCWwwLDBjMy42NjIsMCw2LjYzMSwyLjk2OSw2LjYzMSw2LjYzMVY0MC45NzZ6Ii8+CgkJPHBhdGggZD0iTTQyLjg3Nyw0MC45NzZjMCwzLjY2Mi0yLjk2OSw2LjYzMS02LjYzMSw2LjYzMWwwLDBjLTMuNjYyLDAtNi42MzEtMi45NjktNi42MzEtNi42MzFWNi42MzEKCQkJQzI5LjYxNiwyLjk2OSwzMi41ODUsMCwzNi4yNDYsMGwwLDBjMy42NjIsMCw2LjYzMSwyLjk2OSw2LjYzMSw2LjYzMVY0MC45NzZ6Ii8+Cgk8L2c+Cjwvc3ZnPgo=\", mr = \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTkuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiCgkgdmlld0JveD0iMCAwIDQ5NC4xNDggNDk0LjE0OCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDk0LjE0OCA0OTQuMTQ4OyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+Cgk8Zz4KCQk8Zz4KCQkJPHBhdGggZD0iTTQwNS4yODQsMjAxLjE4OEwxMzAuODA0LDEzLjI4QzExOC4xMjgsNC41OTYsMTA1LjM1NiwwLDk0Ljc0LDBDNzQuMjE2LDAsNjEuNTIsMTYuNDcyLDYxLjUyLDQ0LjA0NHY0MDYuMTI0CgkJCQljMCwyNy41NCwxMi42OCw0My45OCwzMy4xNTYsNDMuOThjMTAuNjMyLDAsMjMuMi00LjYsMzUuOTA0LTEzLjMwOGwyNzQuNjA4LTE4Ny45MDRjMTcuNjYtMTIuMTA0LDI3LjQ0LTI4LjM5MiwyNy40NC00NS44ODQKCQkJCUM0MzIuNjMyLDIyOS41NzIsNDIyLjk2NCwyMTMuMjg4LDQwNS4yODQsMjAxLjE4OHoiLz4KCQk8L2c+Cgk8L2c+Cjwvc3ZnPgo=\", wr = \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMThweCIgaGVpZ2h0PSIxOHB4IiB2aWV3Qm94PSIwIDAgMTggMTgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgPHBhdGggZmlsbD0iIzAwMDAwMCIgZD0iTTE3Ljg1IDMuMTVsLTIuOTktM0EuNTA4LjUwOCAwIDAgMCAxNC41IDBIMS40QTEuNDE3IDEuNDE3IDAgMCAwIDAgMS40M3YxNS4xNEExLjQxNyAxLjQxNyAwIDAgMCAxLjQgMThoMTUuMmExLjQxNyAxLjQxNyAwIDAgMCAxLjQtMS40M1YzLjVhLjQ3LjQ3IDAgMCAwLS4xNS0uMzV6TTIgNVYzYTEgMSAwIDAgMSAxLTFoOGExIDEgMCAwIDEgMSAxdjJhMSAxIDAgMCAxLTEgMUgzYTEgMSAwIDAgMS0xLTF6bTcgMTFhNCA0IDAgMSAxIDQtNCA0IDQgMCAwIDEtNCA0eiIvPgo8L3N2Zz4K\", yr = \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTkuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB2aWV3Qm94PSIwIDAgNDYuNzM0IDQ2LjczNCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDYuNzM0IDQ2LjczNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8Zz4KCTxwYXRoIGQ9Ik00MS4zNDYsMEg1LjM4OEMyLjQxNywwLDAsMi40MTcsMCw1LjM4OHYzNS45NThjMCwyLjk3MSwyLjQxNyw1LjM4OCw1LjM4OCw1LjM4OGgzNS45NThjMi45NzEsMCw1LjM4OC0yLjQxNyw1LjM4OC01LjM4OAoJCVY1LjM4OEM0Ni43MzMsMi40MTcsNDQuMzE2LDAsNDEuMzQ2LDB6Ii8+CjwvZz4KPC9zdmc+Cg==\";\nconst jr = react__WEBPACK_IMPORTED_MODULE_0__.lazy(async () => {\n  const { LiveAudioVisualizer: D } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/react-audio-voice-recorder@2.2.0_react-dom@18.3.1_react@18.3.1__react@18.3.1\").then(__webpack_require__.bind(__webpack_require__, /*! ./react-audio-visualize.es-69216c73.js */ \"(ssr)/./node_modules/.pnpm/react-audio-voice-recorder@2.2.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-audio-voice-recorder/dist/react-audio-visualize.es-69216c73.js\"));\n  return { default: D };\n}), pr = ({\n  onRecordingComplete: D,\n  onNotAllowedOrFound: j,\n  recorderControls: z,\n  audioTrackConstraints: E,\n  downloadOnSavePress: I = !1,\n  downloadFileExtension: C = \"webm\",\n  showVisualizer: y = !1,\n  mediaRecorderOptions: T,\n  classes: i\n}) => {\n  const {\n    startRecording: c,\n    stopRecording: d,\n    togglePauseResume: v,\n    recordingBlob: M,\n    isRecording: m,\n    isPaused: _,\n    recordingTime: A,\n    mediaRecorder: O\n  } = z ?? // eslint-disable-next-line react-hooks/rules-of-hooks\n  gr(\n    E,\n    j,\n    T\n  ), [h, g] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), V = (x = !0) => {\n    g(x), d();\n  }, p = async (x) => {\n    const P = (await __webpack_require__.e(/*! import() */ \"vendor-chunks/react-audio-voice-recorder@2.2.0_react-dom@18.3.1_react@18.3.1__react@18.3.1\").then(__webpack_require__.bind(__webpack_require__, /*! ./index-1c988149.js */ \"(ssr)/./node_modules/.pnpm/react-audio-voice-recorder@2.2.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-audio-voice-recorder/dist/index-1c988149.js\")).then((S) => S.i)).createFFmpeg({ log: !1 });\n    await P.load();\n    const Y = \"input.webm\", L = `output.${C}`;\n    P.FS(\n      \"writeFile\",\n      Y,\n      new Uint8Array(await x.arrayBuffer())\n    ), await P.run(\"-i\", Y, L);\n    const te = P.FS(\"readFile\", L);\n    return new Blob([te.buffer], {\n      type: `audio/${C}`\n    });\n  }, R = async (x) => {\n    !crossOriginIsolated && C !== \"webm\" && console.warn(\n      'This website is not \"cross-origin isolated\". Audio will be downloaded in webm format, since mp3/wav encoding requires cross origin isolation. Please visit https://web.dev/cross-origin-isolation-guide/ and https://web.dev/coop-coep/ for information on how to make your website \"cross-origin isolated\"'\n    );\n    const Q = crossOriginIsolated ? await p(x) : x, P = crossOriginIsolated ? C : \"webm\", Y = URL.createObjectURL(Q), L = document.createElement(\"a\");\n    L.style.display = \"none\", L.href = Y, L.download = `audio.${P}`, document.body.appendChild(L), L.click(), L.remove();\n  };\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    (h || z) && M != null && D != null && (D(M), I && R(M));\n  }, [M]), /* @__PURE__ */ N.jsxs(\n    \"div\",\n    {\n      className: `audio-recorder ${m ? \"recording\" : \"\"} ${(i == null ? void 0 : i.AudioRecorderClass) ?? \"\"}`,\n      \"data-testid\": \"audio_recorder\",\n      children: [\n        /* @__PURE__ */ N.jsx(\n          \"img\",\n          {\n            src: m ? wr : vr,\n            className: `audio-recorder-mic ${(i == null ? void 0 : i.AudioRecorderStartSaveClass) ?? \"\"}`,\n            onClick: m ? () => V() : c,\n            \"data-testid\": \"ar_mic\",\n            title: m ? \"Save recording\" : \"Start recording\"\n          }\n        ),\n        /* @__PURE__ */ N.jsxs(\n          \"span\",\n          {\n            className: `audio-recorder-timer ${m ? \"\" : \"display-none\"} ${(i == null ? void 0 : i.AudioRecorderTimerClass) ?? \"\"}`,\n            \"data-testid\": \"ar_timer\",\n            children: [\n              Math.floor(A / 60),\n              \":\",\n              String(A % 60).padStart(2, \"0\")\n            ]\n          }\n        ),\n        y ? /* @__PURE__ */ N.jsx(\n          \"span\",\n          {\n            className: `audio-recorder-visualizer ${m ? \"\" : \"display-none\"}`,\n            children: O && /* @__PURE__ */ N.jsx(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, { fallback: /* @__PURE__ */ N.jsx(N.Fragment, {}), children: /* @__PURE__ */ N.jsx(\n              jr,\n              {\n                mediaRecorder: O,\n                barWidth: 2,\n                gap: 2,\n                width: 140,\n                height: 30,\n                fftSize: 512,\n                maxDecibels: -10,\n                minDecibels: -80,\n                smoothingTimeConstant: 0.4\n              }\n            ) })\n          }\n        ) : /* @__PURE__ */ N.jsxs(\n          \"span\",\n          {\n            className: `audio-recorder-status ${m ? \"\" : \"display-none\"} ${(i == null ? void 0 : i.AudioRecorderStatusClass) ?? \"\"}`,\n            children: [\n              /* @__PURE__ */ N.jsx(\"span\", { className: \"audio-recorder-status-dot\" }),\n              \"Recording\"\n            ]\n          }\n        ),\n        /* @__PURE__ */ N.jsx(\n          \"img\",\n          {\n            src: _ ? mr : Mr,\n            className: `audio-recorder-options ${m ? \"\" : \"display-none\"} ${(i == null ? void 0 : i.AudioRecorderPauseResumeClass) ?? \"\"}`,\n            onClick: v,\n            title: _ ? \"Resume recording\" : \"Pause recording\",\n            \"data-testid\": \"ar_pause\"\n          }\n        ),\n        /* @__PURE__ */ N.jsx(\n          \"img\",\n          {\n            src: yr,\n            className: `audio-recorder-options ${m ? \"\" : \"display-none\"} ${(i == null ? void 0 : i.AudioRecorderDiscardClass) ?? \"\"}`,\n            onClick: () => V(!1),\n            title: \"Discard Recording\",\n            \"data-testid\": \"ar_cancel\"\n          }\n        )\n      ]\n    }\n  );\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtYXVkaW8tdm9pY2UtcmVjb3JkZXJAMi4yLjBfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvcmVhY3QtYXVkaW8tdm9pY2UtcmVjb3JkZXIvZGlzdC9yZWFjdC1hdWRpby12b2ljZS1yZWNvcmRlci5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxZQUFZLGFBQWEsS0FBSyxJQUFJLDRCQUE0QixzQ0FBc0MsdUVBQXVFLFNBQVMsbURBQW1ELG1CQUFtQix5QkFBeUIsNkJBQTZCLG1CQUFtQixzQkFBc0IsV0FBVyxXQUFXLGFBQWEsbUJBQW1CLDJCQUEyQix3Q0FBd0Msb0JBQW9CLHVCQUF1QixlQUFlLFlBQVksV0FBVyxhQUFhLG9DQUFvQyxtQkFBbUIsOENBQThDLGdCQUFnQiw2Q0FBNkMsV0FBVyxpQkFBaUIsc0RBQXNELGVBQWUsZ0JBQWdCLGNBQWMsdUJBQXVCLGlCQUFpQixhQUFhLHFCQUFxQixZQUFZLGdDQUFnQyxzQkFBc0IsbUNBQW1DLDJCQUEyQixzQkFBc0Isa0JBQWtCLFlBQVksVUFBVSxpQkFBaUIsd0JBQXdCLHVCQUF1QixZQUFZLGVBQWUsMkJBQTJCLGdEQUFnRCwyQkFBMkIsMEJBQTBCLFdBQVcsbUJBQW1CLFlBQVksNEJBQTRCLGNBQWMsYUFBYSwyQkFBMkIsaUJBQWlCLFlBQVksa0JBQWtCLGFBQWEsbUJBQW1CLDRCQUE0QixHQUFHLFVBQVUsSUFBSSxVQUFVLEdBQUcsV0FBVyxHQUFHO0FBQzErQztBQUM3RixXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0NBQUUsNExBQTRMO0FBQ3hNO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FB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Q0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx3QkFBd0I7QUFDNUUsaURBQWlELDJDQUFFLElBQUksOENBQThDO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx5QkFBeUIsRUFBRSx3REFBd0Q7QUFDbkk7QUFDQSw4Q0FBOEMsd0NBQXdDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQseUJBQXlCLEVBQUUsNkRBQTZEO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx5QkFBeUIsRUFBRSx5REFBeUQ7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbm5vdmFfY2hhdGJvdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1hdWRpby12b2ljZS1yZWNvcmRlckAyLjIuMF9yZWFjdC1kb21AMTguMy4xX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9yZWFjdC1hdWRpby12b2ljZS1yZWNvcmRlci9kaXN0L3JlYWN0LWF1ZGlvLXZvaWNlLXJlY29yZGVyLmVzLmpzPzczYzEiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7KHI9Pnt0cnl7aWYodHlwZW9mIHdpbmRvdz5cInVcIilyZXR1cm47dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO2UuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocikpLGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZSl9Y2F0Y2goaSl7Y29uc29sZS5lcnJvcihcInZpdGUtcGx1Z2luLWNzcy1pbmplY3RlZC1ieS1qc1wiLGkpfX0pKFwiLmF1ZGlvLXJlY29yZGVye2JhY2tncm91bmQtY29sb3I6I2ViZWJlYjtib3gtc2hhZG93OjAgMnB4IDVweCAjYmViZWJlO2JvcmRlci1yYWRpdXM6MjBweDtib3gtc2l6aW5nOmJvcmRlci1ib3g7Y29sb3I6IzAwMDt3aWR0aDo0MHB4O2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7dHJhbnNpdGlvbjphbGwgLjJzIGVhc2UtaW47LXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOnRyYW5zcGFyZW50fS5hdWRpby1yZWNvcmRlci1taWN7Ym94LXNpemluZzpjb250ZW50LWJveDtjdXJzb3I6cG9pbnRlcjtoZWlnaHQ6MTZweDtjb2xvcjojMDAwO3BhZGRpbmc6MTJweH0uYXVkaW8tcmVjb3JkZXIgLmF1ZGlvLXJlY29yZGVyLW1pY3tib3JkZXItcmFkaXVzOjIwcHh9LmF1ZGlvLXJlY29yZGVyLnJlY29yZGluZyAuYXVkaW8tcmVjb3JkZXItbWlje2JvcmRlci1yYWRpdXM6MH0uYXVkaW8tcmVjb3JkZXItdGltZXIsLmF1ZGlvLXJlY29yZGVyLXN0YXR1c3tjb2xvcjojMDAwO21hcmdpbi1sZWZ0OjEwcHg7Zm9udC1mYW1pbHk6U2Vnb2UgVUksVGFob21hLEdlbmV2YSxWZXJkYW5hLHNhbnMtc2VyaWY7Zm9udC1zaXplOjE0cHg7Zm9udC13ZWlnaHQ6NDAwO2xpbmUtaGVpZ2h0OjF9LmF1ZGlvLXJlY29yZGVyLXN0YXR1c3ttYXJnaW4tbGVmdDoxNXB4O2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpiYXNlbGluZTtmbGV4LWdyb3c6MTthbmltYXRpb24tbmFtZTpmYWRpbmctYXItc3RhdHVzO2FuaW1hdGlvbi1kdXJhdGlvbjoyczthbmltYXRpb24taXRlcmF0aW9uLWNvdW50OmluZmluaXRlfS5hdWRpby1yZWNvcmRlci1zdGF0dXMtZG90e2JhY2tncm91bmQtY29sb3I6I2QwMDtib3JkZXItcmFkaXVzOjUwJTtoZWlnaHQ6MTBweDt3aWR0aDo5cHg7bWFyZ2luLXJpZ2h0OjVweH0uYXVkaW8tcmVjb3JkZXItb3B0aW9uc3tib3gtc2l6aW5nOmNvbnRlbnQtYm94O2hlaWdodDoxNnB4O2N1cnNvcjpwb2ludGVyO3BhZGRpbmc6MTJweCA2cHggMTJweCAxMnB4fS5hdWRpby1yZWNvcmRlci1vcHRpb25zfi5hdWRpby1yZWNvcmRlci1vcHRpb25ze3BhZGRpbmc6MTJweCAxMnB4IDEycHggNnB4O2JvcmRlci1yYWRpdXM6MCA1cHggNXB4IDB9LnJlY29yZGluZ3tib3JkZXItcmFkaXVzOjEycHg7d2lkdGg6MzAwcHg7dHJhbnNpdGlvbjphbGwgLjJzIGVhc2Utb3V0fS5kaXNwbGF5LW5vbmV7ZGlzcGxheTpub25lfS5hdWRpby1yZWNvcmRlci12aXN1YWxpemVye21hcmdpbi1sZWZ0OjE1cHg7ZmxleC1ncm93OjE7YWxpZ24tc2VsZjpjZW50ZXI7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcn1Aa2V5ZnJhbWVzIGZhZGluZy1hci1zdGF0dXN7MCV7b3BhY2l0eToxfTUwJXtvcGFjaXR5OjB9dG97b3BhY2l0eToxfX1cIil9KSgpO1xuaW1wb3J0IGdlLCB7IHVzZVN0YXRlIGFzIEIsIHVzZUNhbGxiYWNrIGFzIEosIHVzZUVmZmVjdCBhcyBjciwgU3VzcGVuc2UgYXMgbHIgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBkZSA9IHsgZXhwb3J0czoge30gfSwgSCA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIGtlO1xuZnVuY3Rpb24gZnIoKSB7XG4gIGlmIChrZSlcbiAgICByZXR1cm4gSDtcbiAga2UgPSAxO1xuICB2YXIgRCA9IGdlLCBqID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksIHogPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksIEUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBJID0gRC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRC5SZWFjdEN1cnJlbnRPd25lciwgQyA9IHsga2V5OiAhMCwgcmVmOiAhMCwgX19zZWxmOiAhMCwgX19zb3VyY2U6ICEwIH07XG4gIGZ1bmN0aW9uIHkoVCwgaSwgYykge1xuICAgIHZhciBkLCB2ID0ge30sIE0gPSBudWxsLCBtID0gbnVsbDtcbiAgICBjICE9PSB2b2lkIDAgJiYgKE0gPSBcIlwiICsgYyksIGkua2V5ICE9PSB2b2lkIDAgJiYgKE0gPSBcIlwiICsgaS5rZXkpLCBpLnJlZiAhPT0gdm9pZCAwICYmIChtID0gaS5yZWYpO1xuICAgIGZvciAoZCBpbiBpKVxuICAgICAgRS5jYWxsKGksIGQpICYmICFDLmhhc093blByb3BlcnR5KGQpICYmICh2W2RdID0gaVtkXSk7XG4gICAgaWYgKFQgJiYgVC5kZWZhdWx0UHJvcHMpXG4gICAgICBmb3IgKGQgaW4gaSA9IFQuZGVmYXVsdFByb3BzLCBpKVxuICAgICAgICB2W2RdID09PSB2b2lkIDAgJiYgKHZbZF0gPSBpW2RdKTtcbiAgICByZXR1cm4geyAkJHR5cGVvZjogaiwgdHlwZTogVCwga2V5OiBNLCByZWY6IG0sIHByb3BzOiB2LCBfb3duZXI6IEkuY3VycmVudCB9O1xuICB9XG4gIHJldHVybiBILkZyYWdtZW50ID0geiwgSC5qc3ggPSB5LCBILmpzeHMgPSB5LCBIO1xufVxudmFyICQgPSB7fTtcbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBfZTtcbmZ1bmN0aW9uIGRyKCkge1xuICByZXR1cm4gX2UgfHwgKF9lID0gMSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGZ1bmN0aW9uKCkge1xuICAgIHZhciBEID0gZ2UsIGogPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSwgeiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksIEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksIEkgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksIEMgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksIHkgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIiksIFQgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSwgaSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSwgYyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSwgZCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLCB2ID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksIE0gPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSwgbSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIiksIF8gPSBTeW1ib2wuaXRlcmF0b3IsIEEgPSBcIkBAaXRlcmF0b3JcIjtcbiAgICBmdW5jdGlvbiBPKGUpIHtcbiAgICAgIGlmIChlID09PSBudWxsIHx8IHR5cGVvZiBlICE9IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgdmFyIHIgPSBfICYmIGVbX10gfHwgZVtBXTtcbiAgICAgIHJldHVybiB0eXBlb2YgciA9PSBcImZ1bmN0aW9uXCIgPyByIDogbnVsbDtcbiAgICB9XG4gICAgdmFyIGggPSBELl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuICAgIGZ1bmN0aW9uIGcoZSkge1xuICAgICAge1xuICAgICAgICBmb3IgKHZhciByID0gYXJndW1lbnRzLmxlbmd0aCwgdCA9IG5ldyBBcnJheShyID4gMSA/IHIgLSAxIDogMCksIGEgPSAxOyBhIDwgcjsgYSsrKVxuICAgICAgICAgIHRbYSAtIDFdID0gYXJndW1lbnRzW2FdO1xuICAgICAgICBWKFwiZXJyb3JcIiwgZSwgdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFYoZSwgciwgdCkge1xuICAgICAge1xuICAgICAgICB2YXIgYSA9IGguUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSwgdSA9IGEuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICAgICAgICB1ICE9PSBcIlwiICYmIChyICs9IFwiJXNcIiwgdCA9IHQuY29uY2F0KFt1XSkpO1xuICAgICAgICB2YXIgcyA9IHQubWFwKGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKG8pO1xuICAgICAgICB9KTtcbiAgICAgICAgcy51bnNoaWZ0KFwiV2FybmluZzogXCIgKyByKSwgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtlXSwgY29uc29sZSwgcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBwID0gITEsIFIgPSAhMSwgeCA9ICExLCBRID0gITEsIFAgPSAhMSwgWTtcbiAgICBZID0gU3ltYm9sLmZvcihcInJlYWN0Lm1vZHVsZS5yZWZlcmVuY2VcIik7XG4gICAgZnVuY3Rpb24gTChlKSB7XG4gICAgICByZXR1cm4gISEodHlwZW9mIGUgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgfHwgZSA9PT0gRSB8fCBlID09PSBDIHx8IFAgfHwgZSA9PT0gSSB8fCBlID09PSBjIHx8IGUgPT09IGQgfHwgUSB8fCBlID09PSBtIHx8IHAgfHwgUiB8fCB4IHx8IHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgZSAhPT0gbnVsbCAmJiAoZS4kJHR5cGVvZiA9PT0gTSB8fCBlLiQkdHlwZW9mID09PSB2IHx8IGUuJCR0eXBlb2YgPT09IHkgfHwgZS4kJHR5cGVvZiA9PT0gVCB8fCBlLiQkdHlwZW9mID09PSBpIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgICAgLy8gd2l0aC5cbiAgICAgIGUuJCR0eXBlb2YgPT09IFkgfHwgZS5nZXRNb2R1bGVJZCAhPT0gdm9pZCAwKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRlKGUsIHIsIHQpIHtcbiAgICAgIHZhciBhID0gZS5kaXNwbGF5TmFtZTtcbiAgICAgIGlmIChhKVxuICAgICAgICByZXR1cm4gYTtcbiAgICAgIHZhciB1ID0gci5kaXNwbGF5TmFtZSB8fCByLm5hbWUgfHwgXCJcIjtcbiAgICAgIHJldHVybiB1ICE9PSBcIlwiID8gdCArIFwiKFwiICsgdSArIFwiKVwiIDogdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWUoZSkge1xuICAgICAgcmV0dXJuIGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFMoZSkge1xuICAgICAgaWYgKGUgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBpZiAodHlwZW9mIGUudGFnID09IFwibnVtYmVyXCIgJiYgZyhcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIpLCB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBlLmRpc3BsYXlOYW1lIHx8IGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBlO1xuICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgIGNhc2UgRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIHo6XG4gICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgIGNhc2UgQzpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIEk6XG4gICAgICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgICAgICBjYXNlIGM6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSBkOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlID09IFwib2JqZWN0XCIpXG4gICAgICAgIHN3aXRjaCAoZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgVDpcbiAgICAgICAgICAgIHZhciByID0gZTtcbiAgICAgICAgICAgIHJldHVybiBhZShyKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSB5OlxuICAgICAgICAgICAgdmFyIHQgPSBlO1xuICAgICAgICAgICAgcmV0dXJuIGFlKHQuX2NvbnRleHQpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgICBjYXNlIGk6XG4gICAgICAgICAgICByZXR1cm4gdGUoZSwgZS5yZW5kZXIsIFwiRm9yd2FyZFJlZlwiKTtcbiAgICAgICAgICBjYXNlIHY6XG4gICAgICAgICAgICB2YXIgYSA9IGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBhICE9PSBudWxsID8gYSA6IFMoZS50eXBlKSB8fCBcIk1lbW9cIjtcbiAgICAgICAgICBjYXNlIE06IHtcbiAgICAgICAgICAgIHZhciB1ID0gZSwgcyA9IHUuX3BheWxvYWQsIG8gPSB1Ll9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIFMobyhzKSk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIFcgPSBPYmplY3QuYXNzaWduLCBVID0gMCwgdmUsIE1lLCBtZSwgd2UsIHllLCBqZSwgQ2U7XG4gICAgZnVuY3Rpb24gcGUoKSB7XG4gICAgfVxuICAgIHBlLl9fcmVhY3REaXNhYmxlZExvZyA9ICEwO1xuICAgIGZ1bmN0aW9uIFBlKCkge1xuICAgICAge1xuICAgICAgICBpZiAoVSA9PT0gMCkge1xuICAgICAgICAgIHZlID0gY29uc29sZS5sb2csIE1lID0gY29uc29sZS5pbmZvLCBtZSA9IGNvbnNvbGUud2Fybiwgd2UgPSBjb25zb2xlLmVycm9yLCB5ZSA9IGNvbnNvbGUuZ3JvdXAsIGplID0gY29uc29sZS5ncm91cENvbGxhcHNlZCwgQ2UgPSBjb25zb2xlLmdyb3VwRW5kO1xuICAgICAgICAgIHZhciBlID0ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgdmFsdWU6IHBlLFxuICAgICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgICBpbmZvOiBlLFxuICAgICAgICAgICAgbG9nOiBlLFxuICAgICAgICAgICAgd2FybjogZSxcbiAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgZ3JvdXA6IGUsXG4gICAgICAgICAgICBncm91cENvbGxhcHNlZDogZSxcbiAgICAgICAgICAgIGdyb3VwRW5kOiBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgVSsrO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBZZSgpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKFUtLSwgVSA9PT0gMCkge1xuICAgICAgICAgIHZhciBlID0ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgICBsb2c6IFcoe30sIGUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHZlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGluZm86IFcoe30sIGUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IE1lXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHdhcm46IFcoe30sIGUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IG1lXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGVycm9yOiBXKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB3ZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cDogVyh7fSwgZSwge1xuICAgICAgICAgICAgICB2YWx1ZTogeWVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IFcoe30sIGUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGplXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdyb3VwRW5kOiBXKHt9LCBlLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBDZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBVIDwgMCAmJiBnKFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGllID0gaC5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLCBuZTtcbiAgICBmdW5jdGlvbiBYKGUsIHIsIHQpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKG5lID09PSB2b2lkIDApXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAodSkge1xuICAgICAgICAgICAgdmFyIGEgPSB1LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICAgICAgbmUgPSBhICYmIGFbMV0gfHwgXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBgXG5gICsgbmUgKyBlO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgb2UgPSAhMSwgSztcbiAgICB7XG4gICAgICB2YXIgV2UgPSB0eXBlb2YgV2Vha01hcCA9PSBcImZ1bmN0aW9uXCIgPyBXZWFrTWFwIDogTWFwO1xuICAgICAgSyA9IG5ldyBXZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiZShlLCByKSB7XG4gICAgICBpZiAoIWUgfHwgb2UpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAge1xuICAgICAgICB2YXIgdCA9IEsuZ2V0KGUpO1xuICAgICAgICBpZiAodCAhPT0gdm9pZCAwKVxuICAgICAgICAgIHJldHVybiB0O1xuICAgICAgfVxuICAgICAgdmFyIGE7XG4gICAgICBvZSA9ICEwO1xuICAgICAgdmFyIHUgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdm9pZCAwO1xuICAgICAgdmFyIHM7XG4gICAgICBzID0gaWUuY3VycmVudCwgaWUuY3VycmVudCA9IG51bGwsIFBlKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAocikge1xuICAgICAgICAgIHZhciBvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLnByb3RvdHlwZSwgXCJwcm9wc1wiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCB0eXBlb2YgUmVmbGVjdCA9PSBcIm9iamVjdFwiICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChvLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoIChrKSB7XG4gICAgICAgICAgICAgIGEgPSBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZSwgW10sIG8pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBvLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGspIHtcbiAgICAgICAgICAgICAgYSA9IGs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlLmNhbGwoby5wcm90b3R5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9IGNhdGNoIChrKSB7XG4gICAgICAgICAgICBhID0gaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZSgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChrKSB7XG4gICAgICAgIGlmIChrICYmIGEgJiYgdHlwZW9mIGsuc3RhY2sgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGZvciAodmFyIG4gPSBrLnN0YWNrLnNwbGl0KGBcbmApLCB3ID0gYS5zdGFjay5zcGxpdChgXG5gKSwgbCA9IG4ubGVuZ3RoIC0gMSwgZiA9IHcubGVuZ3RoIC0gMTsgbCA+PSAxICYmIGYgPj0gMCAmJiBuW2xdICE9PSB3W2ZdOyApXG4gICAgICAgICAgICBmLS07XG4gICAgICAgICAgZm9yICg7IGwgPj0gMSAmJiBmID49IDA7IGwtLSwgZi0tKVxuICAgICAgICAgICAgaWYgKG5bbF0gIT09IHdbZl0pIHtcbiAgICAgICAgICAgICAgaWYgKGwgIT09IDEgfHwgZiAhPT0gMSlcbiAgICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgICAgaWYgKGwtLSwgZi0tLCBmIDwgMCB8fCBuW2xdICE9PSB3W2ZdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gYFxuYCArIG5bbF0ucmVwbGFjZShcIiBhdCBuZXcgXCIsIFwiIGF0IFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUuZGlzcGxheU5hbWUgJiYgYi5pbmNsdWRlcyhcIjxhbm9ueW1vdXM+XCIpICYmIChiID0gYi5yZXBsYWNlKFwiPGFub255bW91cz5cIiwgZS5kaXNwbGF5TmFtZSkpLCB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgJiYgSy5zZXQoZSwgYiksIGI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGwgPj0gMSAmJiBmID49IDApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgb2UgPSAhMSwgaWUuY3VycmVudCA9IHMsIFllKCksIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdTtcbiAgICAgIH1cbiAgICAgIHZhciBGID0gZSA/IGUuZGlzcGxheU5hbWUgfHwgZS5uYW1lIDogXCJcIiwgT2UgPSBGID8gWChGKSA6IFwiXCI7XG4gICAgICByZXR1cm4gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiICYmIEsuc2V0KGUsIE9lKSwgT2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEJlKGUsIHIsIHQpIHtcbiAgICAgIHJldHVybiBiZShlLCAhMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFZlKGUpIHtcbiAgICAgIHZhciByID0gZS5wcm90b3R5cGU7XG4gICAgICByZXR1cm4gISEociAmJiByLmlzUmVhY3RDb21wb25lbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBxKGUsIHIsIHQpIHtcbiAgICAgIGlmIChlID09IG51bGwpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgaWYgKHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIGJlKGUsIFZlKGUpKTtcbiAgICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gWChlKTtcbiAgICAgIHN3aXRjaCAoZSkge1xuICAgICAgICBjYXNlIGM6XG4gICAgICAgICAgcmV0dXJuIFgoXCJTdXNwZW5zZVwiKTtcbiAgICAgICAgY2FzZSBkOlxuICAgICAgICAgIHJldHVybiBYKFwiU3VzcGVuc2VMaXN0XCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlID09IFwib2JqZWN0XCIpXG4gICAgICAgIHN3aXRjaCAoZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgaTpcbiAgICAgICAgICAgIHJldHVybiBCZShlLnJlbmRlcik7XG4gICAgICAgICAgY2FzZSB2OlxuICAgICAgICAgICAgcmV0dXJuIHEoZS50eXBlLCByLCB0KTtcbiAgICAgICAgICBjYXNlIE06IHtcbiAgICAgICAgICAgIHZhciBhID0gZSwgdSA9IGEuX3BheWxvYWQsIHMgPSBhLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHEocyh1KSwgciwgdCk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICB2YXIgZWUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBOZSA9IHt9LCBJZSA9IGguUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICBmdW5jdGlvbiByZShlKSB7XG4gICAgICBpZiAoZSkge1xuICAgICAgICB2YXIgciA9IGUuX293bmVyLCB0ID0gcShlLnR5cGUsIGUuX3NvdXJjZSwgciA/IHIudHlwZSA6IG51bGwpO1xuICAgICAgICBJZS5zZXRFeHRyYVN0YWNrRnJhbWUodCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgSWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBRZShlLCByLCB0LCBhLCB1KSB7XG4gICAgICB7XG4gICAgICAgIHZhciBzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGVlKTtcbiAgICAgICAgZm9yICh2YXIgbyBpbiBlKVxuICAgICAgICAgIGlmIChzKGUsIG8pKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZVtvXSAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdyA9IEVycm9yKChhIHx8IFwiUmVhY3QgY2xhc3NcIikgKyBcIjogXCIgKyB0ICsgXCIgdHlwZSBgXCIgKyBvICsgXCJgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGBcIiArIHR5cGVvZiBlW29dICsgXCJgLlRoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLlwiKTtcbiAgICAgICAgICAgICAgICB0aHJvdyB3Lm5hbWUgPSBcIkludmFyaWFudCBWaW9sYXRpb25cIiwgdztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuID0gZVtvXShyLCBvLCBhLCB0LCBudWxsLCBcIlNFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEXCIpO1xuICAgICAgICAgICAgfSBjYXRjaCAobCkge1xuICAgICAgICAgICAgICBuID0gbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4gJiYgIShuIGluc3RhbmNlb2YgRXJyb3IpICYmIChyZSh1KSwgZyhcIiVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiBZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciBjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kIHNoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS5cIiwgYSB8fCBcIlJlYWN0IGNsYXNzXCIsIHQsIG8sIHR5cGVvZiBuKSwgcmUobnVsbCkpLCBuIGluc3RhbmNlb2YgRXJyb3IgJiYgIShuLm1lc3NhZ2UgaW4gTmUpICYmIChOZVtuLm1lc3NhZ2VdID0gITAsIHJlKHUpLCBnKFwiRmFpbGVkICVzIHR5cGU6ICVzXCIsIHQsIG4ubWVzc2FnZSksIHJlKG51bGwpKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBaZSA9IEFycmF5LmlzQXJyYXk7XG4gICAgZnVuY3Rpb24gdWUoZSkge1xuICAgICAgcmV0dXJuIFplKGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBGZShlKSB7XG4gICAgICB7XG4gICAgICAgIHZhciByID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLnRvU3RyaW5nVGFnLCB0ID0gciAmJiBlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgZS5jb25zdHJ1Y3Rvci5uYW1lIHx8IFwiT2JqZWN0XCI7XG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBVZShlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gVGUoZSksICExO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gVGUoZSkge1xuICAgICAgcmV0dXJuIFwiXCIgKyBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBMZShlKSB7XG4gICAgICBpZiAoVWUoZSkpXG4gICAgICAgIHJldHVybiBnKFwiVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsIEZlKGUpKSwgVGUoZSk7XG4gICAgfVxuICAgIHZhciBHID0gaC5SZWFjdEN1cnJlbnRPd25lciwgR2UgPSB7XG4gICAgICBrZXk6ICEwLFxuICAgICAgcmVmOiAhMCxcbiAgICAgIF9fc2VsZjogITAsXG4gICAgICBfX3NvdXJjZTogITBcbiAgICB9LCBTZSwgRGUsIHNlO1xuICAgIHNlID0ge307XG4gICAgZnVuY3Rpb24gSmUoZSkge1xuICAgICAgaWYgKGVlLmNhbGwoZSwgXCJyZWZcIikpIHtcbiAgICAgICAgdmFyIHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIFwicmVmXCIpLmdldDtcbiAgICAgICAgaWYgKHIgJiYgci5pc1JlYWN0V2FybmluZylcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gZS5yZWYgIT09IHZvaWQgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gSGUoZSkge1xuICAgICAgaWYgKGVlLmNhbGwoZSwgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKHIgJiYgci5pc1JlYWN0V2FybmluZylcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gZS5rZXkgIT09IHZvaWQgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gJGUoZSwgcikge1xuICAgICAgaWYgKHR5cGVvZiBlLnJlZiA9PSBcInN0cmluZ1wiICYmIEcuY3VycmVudCAmJiByICYmIEcuY3VycmVudC5zdGF0ZU5vZGUgIT09IHIpIHtcbiAgICAgICAgdmFyIHQgPSBTKEcuY3VycmVudC50eXBlKTtcbiAgICAgICAgc2VbdF0gfHwgKGcoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiBTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuIExlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBTKEcuY3VycmVudC50eXBlKSwgZS5yZWYpLCBzZVt0XSA9ICEwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gWGUoZSwgcikge1xuICAgICAge1xuICAgICAgICB2YXIgdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIFNlIHx8IChTZSA9ICEwLCBnKFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcylcIiwgcikpO1xuICAgICAgICB9O1xuICAgICAgICB0LmlzUmVhY3RXYXJuaW5nID0gITAsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcImtleVwiLCB7XG4gICAgICAgICAgZ2V0OiB0LFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIEtlKGUsIHIpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBEZSB8fCAoRGUgPSAhMCwgZyhcIiVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpXCIsIHIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdC5pc1JlYWN0V2FybmluZyA9ICEwLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJyZWZcIiwge1xuICAgICAgICAgIGdldDogdCxcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcWUgPSBmdW5jdGlvbihlLCByLCB0LCBhLCB1LCBzLCBvKSB7XG4gICAgICB2YXIgbiA9IHtcbiAgICAgICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgICAgICQkdHlwZW9mOiBqLFxuICAgICAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgICAgIHR5cGU6IGUsXG4gICAgICAgIGtleTogcixcbiAgICAgICAgcmVmOiB0LFxuICAgICAgICBwcm9wczogbyxcbiAgICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgICAgX293bmVyOiBzXG4gICAgICB9O1xuICAgICAgcmV0dXJuIG4uX3N0b3JlID0ge30sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLl9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogITFcbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJfc2VsZlwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITEsXG4gICAgICAgIHZhbHVlOiBhXG4gICAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIFwiX3NvdXJjZVwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITEsXG4gICAgICAgIHZhbHVlOiB1XG4gICAgICB9KSwgT2JqZWN0LmZyZWV6ZSAmJiAoT2JqZWN0LmZyZWV6ZShuLnByb3BzKSwgT2JqZWN0LmZyZWV6ZShuKSksIG47XG4gICAgfTtcbiAgICBmdW5jdGlvbiBlcihlLCByLCB0LCBhLCB1KSB7XG4gICAgICB7XG4gICAgICAgIHZhciBzLCBvID0ge30sIG4gPSBudWxsLCB3ID0gbnVsbDtcbiAgICAgICAgdCAhPT0gdm9pZCAwICYmIChMZSh0KSwgbiA9IFwiXCIgKyB0KSwgSGUocikgJiYgKExlKHIua2V5KSwgbiA9IFwiXCIgKyByLmtleSksIEplKHIpICYmICh3ID0gci5yZWYsICRlKHIsIHUpKTtcbiAgICAgICAgZm9yIChzIGluIHIpXG4gICAgICAgICAgZWUuY2FsbChyLCBzKSAmJiAhR2UuaGFzT3duUHJvcGVydHkocykgJiYgKG9bc10gPSByW3NdKTtcbiAgICAgICAgaWYgKGUgJiYgZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICB2YXIgbCA9IGUuZGVmYXVsdFByb3BzO1xuICAgICAgICAgIGZvciAocyBpbiBsKVxuICAgICAgICAgICAgb1tzXSA9PT0gdm9pZCAwICYmIChvW3NdID0gbFtzXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gfHwgdykge1xuICAgICAgICAgIHZhciBmID0gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWUgfHwgXCJVbmtub3duXCIgOiBlO1xuICAgICAgICAgIG4gJiYgWGUobywgZiksIHcgJiYgS2UobywgZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHFlKGUsIG4sIHcsIHUsIGEsIEcuY3VycmVudCwgbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjZSA9IGguUmVhY3RDdXJyZW50T3duZXIsIEVlID0gaC5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIGZ1bmN0aW9uIFooZSkge1xuICAgICAgaWYgKGUpIHtcbiAgICAgICAgdmFyIHIgPSBlLl9vd25lciwgdCA9IHEoZS50eXBlLCBlLl9zb3VyY2UsIHIgPyByLnR5cGUgOiBudWxsKTtcbiAgICAgICAgRWUuc2V0RXh0cmFTdGFja0ZyYW1lKHQpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIEVlLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gICAgdmFyIGxlO1xuICAgIGxlID0gITE7XG4gICAgZnVuY3Rpb24gZmUoZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgZSAhPT0gbnVsbCAmJiBlLiQkdHlwZW9mID09PSBqO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoZSgpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGNlLmN1cnJlbnQpIHtcbiAgICAgICAgICB2YXIgZSA9IFMoY2UuY3VycmVudC50eXBlKTtcbiAgICAgICAgICBpZiAoZSlcbiAgICAgICAgICAgIHJldHVybiBgXG5cbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIFxcYGAgKyBlICsgXCJgLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBycihlKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB2YXIgciA9IGUuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgXCJcIiksIHQgPSBlLmxpbmVOdW1iZXI7XG4gICAgICAgICAgcmV0dXJuIGBcblxuQ2hlY2sgeW91ciBjb2RlIGF0IGAgKyByICsgXCI6XCIgKyB0ICsgXCIuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBSZSA9IHt9O1xuICAgIGZ1bmN0aW9uIHRyKGUpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHIgPSBoZSgpO1xuICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICB2YXIgdCA9IHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyBlIDogZS5kaXNwbGF5TmFtZSB8fCBlLm5hbWU7XG4gICAgICAgICAgdCAmJiAociA9IGBcblxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8YCArIHQgKyBcIj4uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB4ZShlLCByKSB7XG4gICAgICB7XG4gICAgICAgIGlmICghZS5fc3RvcmUgfHwgZS5fc3RvcmUudmFsaWRhdGVkIHx8IGUua2V5ICE9IG51bGwpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlLl9zdG9yZS52YWxpZGF0ZWQgPSAhMDtcbiAgICAgICAgdmFyIHQgPSB0cihyKTtcbiAgICAgICAgaWYgKFJlW3RdKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgUmVbdF0gPSAhMDtcbiAgICAgICAgdmFyIGEgPSBcIlwiO1xuICAgICAgICBlICYmIGUuX293bmVyICYmIGUuX293bmVyICE9PSBjZS5jdXJyZW50ICYmIChhID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBTKGUuX293bmVyLnR5cGUpICsgXCIuXCIpLCBaKGUpLCBnKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCB0LCBhKSwgWihudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gemUoZSwgcikge1xuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIGUgIT0gXCJvYmplY3RcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh1ZShlKSlcbiAgICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IGUubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIHZhciBhID0gZVt0XTtcbiAgICAgICAgICAgIGZlKGEpICYmIHhlKGEsIHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmUoZSkpXG4gICAgICAgICAgZS5fc3RvcmUgJiYgKGUuX3N0b3JlLnZhbGlkYXRlZCA9ICEwKTtcbiAgICAgICAgZWxzZSBpZiAoZSkge1xuICAgICAgICAgIHZhciB1ID0gTyhlKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHUgPT0gXCJmdW5jdGlvblwiICYmIHUgIT09IGUuZW50cmllcylcbiAgICAgICAgICAgIGZvciAodmFyIHMgPSB1LmNhbGwoZSksIG87ICEobyA9IHMubmV4dCgpKS5kb25lOyApXG4gICAgICAgICAgICAgIGZlKG8udmFsdWUpICYmIHhlKG8udmFsdWUsIHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyKGUpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHIgPSBlLnR5cGU7XG4gICAgICAgIGlmIChyID09IG51bGwgfHwgdHlwZW9mIHIgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciB0O1xuICAgICAgICBpZiAodHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHQgPSByLnByb3BUeXBlcztcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHIgPT0gXCJvYmplY3RcIiAmJiAoci4kJHR5cGVvZiA9PT0gaSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgICAgICByLiQkdHlwZW9mID09PSB2KSlcbiAgICAgICAgICB0ID0gci5wcm9wVHlwZXM7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgdmFyIGEgPSBTKHIpO1xuICAgICAgICAgIFFlKHQsIGUucHJvcHMsIFwicHJvcFwiLCBhLCBlKTtcbiAgICAgICAgfSBlbHNlIGlmIChyLlByb3BUeXBlcyAhPT0gdm9pZCAwICYmICFsZSkge1xuICAgICAgICAgIGxlID0gITA7XG4gICAgICAgICAgdmFyIHUgPSBTKHIpO1xuICAgICAgICAgIGcoXCJDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD9cIiwgdSB8fCBcIlVua25vd25cIik7XG4gICAgICAgIH1cbiAgICAgICAgdHlwZW9mIHIuZ2V0RGVmYXVsdFByb3BzID09IFwiZnVuY3Rpb25cIiAmJiAhci5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgJiYgZyhcImdldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyBkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpcihlKSB7XG4gICAgICB7XG4gICAgICAgIGZvciAodmFyIHIgPSBPYmplY3Qua2V5cyhlLnByb3BzKSwgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgdmFyIGEgPSByW3RdO1xuICAgICAgICAgIGlmIChhICE9PSBcImNoaWxkcmVuXCIgJiYgYSAhPT0gXCJrZXlcIikge1xuICAgICAgICAgICAgWihlKSwgZyhcIkludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuIFJlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuXCIsIGEpLCBaKG51bGwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGUucmVmICE9PSBudWxsICYmIChaKGUpLCBnKFwiSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC5cIiksIFoobnVsbCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBBZShlLCByLCB0LCBhLCB1LCBzKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBvID0gTChlKTtcbiAgICAgICAgaWYgKCFvKSB7XG4gICAgICAgICAgdmFyIG4gPSBcIlwiO1xuICAgICAgICAgIChlID09PSB2b2lkIDAgfHwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKGUpLmxlbmd0aCA9PT0gMCkgJiYgKG4gKz0gXCIgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiKTtcbiAgICAgICAgICB2YXIgdyA9IHJyKHUpO1xuICAgICAgICAgIHcgPyBuICs9IHcgOiBuICs9IGhlKCk7XG4gICAgICAgICAgdmFyIGw7XG4gICAgICAgICAgZSA9PT0gbnVsbCA/IGwgPSBcIm51bGxcIiA6IHVlKGUpID8gbCA9IFwiYXJyYXlcIiA6IGUgIT09IHZvaWQgMCAmJiBlLiQkdHlwZW9mID09PSBqID8gKGwgPSBcIjxcIiArIChTKGUudHlwZSkgfHwgXCJVbmtub3duXCIpICsgXCIgLz5cIiwgbiA9IFwiIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/XCIpIDogbCA9IHR5cGVvZiBlLCBnKFwiUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzXCIsIGwsIG4pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmID0gZXIoZSwgciwgdCwgdSwgcyk7XG4gICAgICAgIGlmIChmID09IG51bGwpXG4gICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgdmFyIGIgPSByLmNoaWxkcmVuO1xuICAgICAgICAgIGlmIChiICE9PSB2b2lkIDApXG4gICAgICAgICAgICBpZiAoYSlcbiAgICAgICAgICAgICAgaWYgKHVlKGIpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgRiA9IDA7IEYgPCBiLmxlbmd0aDsgRisrKVxuICAgICAgICAgICAgICAgICAgemUoYltGXSwgZSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGIpO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBnKFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgemUoYiwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGUgPT09IEUgPyBpcihmKSA6IGFyKGYpLCBmO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBucihlLCByLCB0KSB7XG4gICAgICByZXR1cm4gQWUoZSwgciwgdCwgITApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvcihlLCByLCB0KSB7XG4gICAgICByZXR1cm4gQWUoZSwgciwgdCwgITEpO1xuICAgIH1cbiAgICB2YXIgdXIgPSBvciwgc3IgPSBucjtcbiAgICAkLkZyYWdtZW50ID0gRSwgJC5qc3ggPSB1ciwgJC5qc3hzID0gc3I7XG4gIH0oKSksICQ7XG59XG5wcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBkZS5leHBvcnRzID0gZnIoKSA6IGRlLmV4cG9ydHMgPSBkcigpO1xudmFyIE4gPSBkZS5leHBvcnRzO1xuY29uc3QgZ3IgPSAoRCwgaiwgeikgPT4ge1xuICBjb25zdCBbRSwgSV0gPSBCKCExKSwgW0MsIHldID0gQighMSksIFtULCBpXSA9IEIoMCksIFtjLCBkXSA9IEIoKSwgW3YsIE1dID0gQigpLCBbbSwgX10gPSBCKCksIEEgPSBKKCgpID0+IHtcbiAgICBjb25zdCBwID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaSgoUikgPT4gUiArIDEpO1xuICAgIH0sIDFlMyk7XG4gICAgTShwKTtcbiAgfSwgW2ksIE1dKSwgTyA9IEooKCkgPT4ge1xuICAgIHYgIT0gbnVsbCAmJiBjbGVhckludGVydmFsKHYpLCBNKHZvaWQgMCk7XG4gIH0sIFt2LCBNXSksIGggPSBKKCgpID0+IHtcbiAgICB2ID09IG51bGwgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoeyBhdWRpbzogRCA/PyAhMCB9KS50aGVuKChwKSA9PiB7XG4gICAgICBJKCEwKTtcbiAgICAgIGNvbnN0IFIgPSBuZXcgTWVkaWFSZWNvcmRlcihcbiAgICAgICAgcCxcbiAgICAgICAgelxuICAgICAgKTtcbiAgICAgIGQoUiksIFIuc3RhcnQoKSwgQSgpLCBSLmFkZEV2ZW50TGlzdGVuZXIoXCJkYXRhYXZhaWxhYmxlXCIsICh4KSA9PiB7XG4gICAgICAgIF8oeC5kYXRhKSwgUi5zdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCgoUSkgPT4gUS5zdG9wKCkpLCBkKHZvaWQgMCk7XG4gICAgICB9KTtcbiAgICB9KS5jYXRjaCgocCkgPT4ge1xuICAgICAgY29uc29sZS5sb2cocC5uYW1lLCBwLm1lc3NhZ2UsIHAuY2F1c2UpLCBqID09IG51bGwgfHwgaihwKTtcbiAgICB9KTtcbiAgfSwgW1xuICAgIHYsXG4gICAgSSxcbiAgICBkLFxuICAgIEEsXG4gICAgXyxcbiAgICBqLFxuICAgIHpcbiAgXSksIGcgPSBKKCgpID0+IHtcbiAgICBjID09IG51bGwgfHwgYy5zdG9wKCksIE8oKSwgaSgwKSwgSSghMSksIHkoITEpO1xuICB9LCBbXG4gICAgYyxcbiAgICBpLFxuICAgIEksXG4gICAgeSxcbiAgICBPXG4gIF0pLCBWID0gSigoKSA9PiB7XG4gICAgQyA/ICh5KCExKSwgYyA9PSBudWxsIHx8IGMucmVzdW1lKCksIEEoKSkgOiAoeSghMCksIE8oKSwgYyA9PSBudWxsIHx8IGMucGF1c2UoKSk7XG4gIH0sIFtjLCB5LCBBLCBPXSk7XG4gIHJldHVybiB7XG4gICAgc3RhcnRSZWNvcmRpbmc6IGgsXG4gICAgc3RvcFJlY29yZGluZzogZyxcbiAgICB0b2dnbGVQYXVzZVJlc3VtZTogVixcbiAgICByZWNvcmRpbmdCbG9iOiBtLFxuICAgIGlzUmVjb3JkaW5nOiBFLFxuICAgIGlzUGF1c2VkOiBDLFxuICAgIHJlY29yZGluZ1RpbWU6IFQsXG4gICAgbWVkaWFSZWNvcmRlcjogY1xuICB9O1xufSwgdnIgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaWFYTnZMVGc0TlRrdE1TSS9QZ284SVMwdElFZGxibVZ5WVhSdmNqb2dRV1J2WW1VZ1NXeHNkWE4wY21GMGIzSWdNVGt1TUM0d0xDQlRWa2NnUlhod2IzSjBJRkJzZFdjdFNXNGdMaUJUVmtjZ1ZtVnljMmx2YmpvZ05pNHdNQ0JDZFdsc1pDQXdLU0FnTFMwK0NqeHpkbWNnZG1WeWMybHZiajBpTVM0eElpQnBaRDBpVEdGNVpYSmZNU0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JaUI0Yld4dWN6cDRiR2x1YXowaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1UazVPUzk0YkdsdWF5SWdlRDBpTUhCNElpQjVQU0l3Y0hnaUNna2dkbWxsZDBKdmVEMGlNQ0F3SURRM01DQTBOekFpSUhOMGVXeGxQU0psYm1GaWJHVXRZbUZqYTJkeWIzVnVaRHB1WlhjZ01DQXdJRFEzTUNBME56QTdJaUI0Yld3NmMzQmhZMlU5SW5CeVpYTmxjblpsSWo0S0NUeG5QZ29KQ1R4d1lYUm9JR1E5SWsweU16VXNNekF5TGpJNU5tTTBOeTR4Tnpjc01DdzROUzQwTWpNdE16Z3VNalExTERnMUxqUXlNeTA0TlM0ME1qTldPRFV1TkRJelF6TXlNQzQwTWpNc016Z3VNalExTERJNE1pNHhOemNzTUN3eU16VXNNSE10T0RVdU5ESXpMRE00TGpJME5TMDROUzQwTWpNc09EVXVOREl6Q2drSkNYWXhNekV1TkRVeFF6RTBPUzQxTnpjc01qWTBMakExTVN3eE9EY3VPREl6TERNd01pNHlPVFlzTWpNMUxETXdNaTR5T1RaNklpOCtDZ2tKUEhCaGRHZ2daRDBpVFRNMU1DNDBNak1zTVRNMkxqRTBPSFl6TUdneE5YWTFNQzQzTWpaak1DdzNNUzQ1TVRVdE5UZ3VOVEE0TERFek1DNDBNak10TVRNd0xqUXlNeXd4TXpBdU5ESXpjeTB4TXpBdU5ESXpMVFU0TGpVd055MHhNekF1TkRJekxURXpNQzQwTWpOMkxUVXdMamN5Tm1neE5YWXRNekFLQ1FrSmFDMDBOWFk0TUM0M01qWkROelF1TlRjM0xETXdNQzR5TnpNc01UTTRMalUxTVN3ek5qa3NNakl3TERNM05pNDFPRGxXTkRRd2FDMDVNQzQwTkRSMk16Qm9NakV3TGpnNE9YWXRNekJJTWpVd2RpMDJNeTQwTVRFS0NRa0pZemd4TGpRME9TMDNMalU0T1N3eE5EVXVOREl6TFRjMkxqTXhOeXd4TkRVdU5ESXpMVEUxT1M0M01UWjJMVGd3TGpjeU5rZ3pOVEF1TkRJemVpSXZQZ29KUEM5blBnbzhMM04yWno0S1wiLCBNciA9IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJsYm1OdlpHbHVaejBpYVhOdkxUZzROVGt0TVNJL1BnbzhJUzB0SUVkbGJtVnlZWFJ2Y2pvZ1FXUnZZbVVnU1d4c2RYTjBjbUYwYjNJZ01Ua3VNQzR3TENCVFZrY2dSWGh3YjNKMElGQnNkV2N0U1c0Z0xpQlRWa2NnVm1WeWMybHZiam9nTmk0d01DQkNkV2xzWkNBd0tTQWdMUzArQ2p4emRtY2dkbVZ5YzJsdmJqMGlNUzR4SWlCcFpEMGlRMkZ3WVY4eElpQjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIaHRiRzV6T25oc2FXNXJQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUwzaHNhVzVySWlCNFBTSXdjSGdpSUhrOUlqQndlQ0lLQ1NCMmFXVjNRbTk0UFNJd0lEQWdORGN1TmpBM0lEUTNMall3TnlJZ2MzUjViR1U5SW1WdVlXSnNaUzFpWVdOclozSnZkVzVrT201bGR5QXdJREFnTkRjdU5qQTNJRFEzTGpZd056c2lJSGh0YkRwemNHRmpaVDBpY0hKbGMyVnlkbVVpUGdvSlBHYytDZ2tKUEhCaGRHZ2daRDBpVFRFM0xqazVNU3cwTUM0NU56WmpNQ3d6TGpZMk1pMHlMamsyT1N3MkxqWXpNUzAyTGpZek1TdzJMall6TVd3d0xEQmpMVE11TmpZeUxEQXROaTQyTXpFdE1pNDVOamt0Tmk0Mk16RXROaTQyTXpGV05pNDJNekZETkM0M01qa3NNaTQ1Tmprc055NDJPVGdzTUN3eE1TNHpOaXd3Q2drSkNXd3dMREJqTXk0Mk5qSXNNQ3cyTGpZek1Td3lMamsyT1N3MkxqWXpNU3cyTGpZek1WWTBNQzQ1TnpaNklpOCtDZ2tKUEhCaGRHZ2daRDBpVFRReUxqZzNOeXcwTUM0NU56WmpNQ3d6TGpZMk1pMHlMamsyT1N3MkxqWXpNUzAyTGpZek1TdzJMall6TVd3d0xEQmpMVE11TmpZeUxEQXROaTQyTXpFdE1pNDVOamt0Tmk0Mk16RXROaTQyTXpGV05pNDJNekVLQ1FrSlF6STVMall4Tml3eUxqazJPU3d6TWk0MU9EVXNNQ3d6Tmk0eU5EWXNNR3d3TERCak15NDJOaklzTUN3MkxqWXpNU3d5TGprMk9TdzJMall6TVN3MkxqWXpNVlkwTUM0NU56WjZJaTgrQ2drOEwyYytDand2YzNablBnbz1cIiwgbXIgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaWFYTnZMVGc0TlRrdE1TSS9QZ284SVMwdElFZGxibVZ5WVhSdmNqb2dRV1J2WW1VZ1NXeHNkWE4wY21GMGIzSWdNVGt1TUM0d0xDQlRWa2NnUlhod2IzSjBJRkJzZFdjdFNXNGdMaUJUVmtjZ1ZtVnljMmx2YmpvZ05pNHdNQ0JDZFdsc1pDQXdLU0FnTFMwK0NqeHpkbWNnZG1WeWMybHZiajBpTVM0eElpQnBaRDBpVEdGNVpYSmZNU0lnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JaUI0Yld4dWN6cDRiR2x1YXowaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1UazVPUzk0YkdsdWF5SWdlRDBpTUhCNElpQjVQU0l3Y0hnaUNna2dkbWxsZDBKdmVEMGlNQ0F3SURRNU5DNHhORGdnTkRrMExqRTBPQ0lnYzNSNWJHVTlJbVZ1WVdKc1pTMWlZV05yWjNKdmRXNWtPbTVsZHlBd0lEQWdORGswTGpFME9DQTBPVFF1TVRRNE95SWdlRzFzT25Od1lXTmxQU0p3Y21WelpYSjJaU0krQ2drOFp6NEtDUWs4Wno0S0NRa0pQSEJoZEdnZ1pEMGlUVFF3TlM0eU9EUXNNakF4TGpFNE9Fd3hNekF1T0RBMExERXpMakk0UXpFeE9DNHhNamdzTkM0MU9UWXNNVEExTGpNMU5pd3dMRGswTGpjMExEQkROelF1TWpFMkxEQXNOakV1TlRJc01UWXVORGN5TERZeExqVXlMRFEwTGpBME5IWTBNRFl1TVRJMENna0pDUWxqTUN3eU55NDFOQ3d4TWk0Mk9DdzBNeTQ1T0N3ek15NHhOVFlzTkRNdU9UaGpNVEF1TmpNeUxEQXNNak11TWkwMExqWXNNelV1T1RBMExURXpMak13T0d3eU56UXVOakE0TFRFNE55NDVNRFJqTVRjdU5qWXRNVEl1TVRBMExESTNMalEwTFRJNExqTTVNaXd5Tnk0ME5DMDBOUzQ0T0RRS0NRa0pDVU0wTXpJdU5qTXlMREl5T1M0MU56SXNOREl5TGprMk5Dd3lNVE11TWpnNExEUXdOUzR5T0RRc01qQXhMakU0T0hvaUx6NEtDUWs4TDJjK0NnazhMMmMrQ2p3dmMzWm5QZ289XCIsIHdyID0gXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVGh3ZUNJZ2FHVnBaMmgwUFNJeE9IQjRJaUIyYVdWM1FtOTRQU0l3SURBZ01UZ2dNVGdpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrQ2lBZ1BIQmhkR2dnWm1sc2JEMGlJekF3TURBd01DSWdaRDBpVFRFM0xqZzFJRE11TVRWc0xUSXVPVGt0TTBFdU5UQTRMalV3T0NBd0lEQWdNQ0F4TkM0MUlEQklNUzQwUVRFdU5ERTNJREV1TkRFM0lEQWdNQ0F3SURBZ01TNDBNM1l4TlM0eE5FRXhMalF4TnlBeExqUXhOeUF3SURBZ01DQXhMalFnTVRob01UVXVNbUV4TGpReE55QXhMalF4TnlBd0lEQWdNQ0F4TGpRdE1TNDBNMVl6TGpWaExqUTNMalEzSURBZ01DQXdMUzR4TlMwdU16VjZUVElnTlZZellURWdNU0F3SURBZ01TQXhMVEZvT0dFeElERWdNQ0F3SURFZ01TQXhkakpoTVNBeElEQWdNQ0F4TFRFZ01VZ3pZVEVnTVNBd0lEQWdNUzB4TFRGNmJUY2dNVEZoTkNBMElEQWdNU0F4SURRdE5DQTBJRFFnTUNBd0lERXROQ0EwZWlJdlBnbzhMM04yWno0S1wiLCB5ciA9IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJsYm1OdlpHbHVaejBpYVhOdkxUZzROVGt0TVNJL1BnbzhJUzB0SUVkbGJtVnlZWFJ2Y2pvZ1FXUnZZbVVnU1d4c2RYTjBjbUYwYjNJZ01Ua3VNQzR3TENCVFZrY2dSWGh3YjNKMElGQnNkV2N0U1c0Z0xpQlRWa2NnVm1WeWMybHZiam9nTmk0d01DQkNkV2xzWkNBd0tTQWdMUzArQ2p4emRtY2dkbVZ5YzJsdmJqMGlNUzR4SWlCcFpEMGlRMkZ3WVY4eElpQjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIaHRiRzV6T25oc2FXNXJQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUwzaHNhVzVySWlCNFBTSXdjSGdpSUhrOUlqQndlQ0lLQ1NCMmFXVjNRbTk0UFNJd0lEQWdORFl1TnpNMElEUTJMamN6TkNJZ2MzUjViR1U5SW1WdVlXSnNaUzFpWVdOclozSnZkVzVrT201bGR5QXdJREFnTkRZdU56TTBJRFEyTGpjek5Ec2lJSGh0YkRwemNHRmpaVDBpY0hKbGMyVnlkbVVpUGdvOFp6NEtDVHh3WVhSb0lHUTlJazAwTVM0ek5EWXNNRWcxTGpNNE9FTXlMalF4Tnl3d0xEQXNNaTQwTVRjc01DdzFMak00T0hZek5TNDVOVGhqTUN3eUxqazNNU3d5TGpReE55dzFMak00T0N3MUxqTTRPQ3cxTGpNNE9HZ3pOUzQ1TlRoak1pNDVOekVzTUN3MUxqTTRPQzB5TGpReE55dzFMak00T0MwMUxqTTRPQW9KQ1ZZMUxqTTRPRU0wTmk0M016TXNNaTQwTVRjc05EUXVNekUyTERBc05ERXVNelEyTERCNklpOCtDand2Wno0S1BDOXpkbWMrQ2c9PVwiO1xuY29uc3QganIgPSBnZS5sYXp5KGFzeW5jICgpID0+IHtcbiAgY29uc3QgeyBMaXZlQXVkaW9WaXN1YWxpemVyOiBEIH0gPSBhd2FpdCBpbXBvcnQoXCIuL3JlYWN0LWF1ZGlvLXZpc3VhbGl6ZS5lcy02OTIxNmM3My5qc1wiKTtcbiAgcmV0dXJuIHsgZGVmYXVsdDogRCB9O1xufSksIHByID0gKHtcbiAgb25SZWNvcmRpbmdDb21wbGV0ZTogRCxcbiAgb25Ob3RBbGxvd2VkT3JGb3VuZDogaixcbiAgcmVjb3JkZXJDb250cm9sczogeixcbiAgYXVkaW9UcmFja0NvbnN0cmFpbnRzOiBFLFxuICBkb3dubG9hZE9uU2F2ZVByZXNzOiBJID0gITEsXG4gIGRvd25sb2FkRmlsZUV4dGVuc2lvbjogQyA9IFwid2VibVwiLFxuICBzaG93VmlzdWFsaXplcjogeSA9ICExLFxuICBtZWRpYVJlY29yZGVyT3B0aW9uczogVCxcbiAgY2xhc3NlczogaVxufSkgPT4ge1xuICBjb25zdCB7XG4gICAgc3RhcnRSZWNvcmRpbmc6IGMsXG4gICAgc3RvcFJlY29yZGluZzogZCxcbiAgICB0b2dnbGVQYXVzZVJlc3VtZTogdixcbiAgICByZWNvcmRpbmdCbG9iOiBNLFxuICAgIGlzUmVjb3JkaW5nOiBtLFxuICAgIGlzUGF1c2VkOiBfLFxuICAgIHJlY29yZGluZ1RpbWU6IEEsXG4gICAgbWVkaWFSZWNvcmRlcjogT1xuICB9ID0geiA/PyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgZ3IoXG4gICAgRSxcbiAgICBqLFxuICAgIFRcbiAgKSwgW2gsIGddID0gQighMSksIFYgPSAoeCA9ICEwKSA9PiB7XG4gICAgZyh4KSwgZCgpO1xuICB9LCBwID0gYXN5bmMgKHgpID0+IHtcbiAgICBjb25zdCBQID0gKGF3YWl0IGltcG9ydChcIi4vaW5kZXgtMWM5ODgxNDkuanNcIikudGhlbigoUykgPT4gUy5pKSkuY3JlYXRlRkZtcGVnKHsgbG9nOiAhMSB9KTtcbiAgICBhd2FpdCBQLmxvYWQoKTtcbiAgICBjb25zdCBZID0gXCJpbnB1dC53ZWJtXCIsIEwgPSBgb3V0cHV0LiR7Q31gO1xuICAgIFAuRlMoXG4gICAgICBcIndyaXRlRmlsZVwiLFxuICAgICAgWSxcbiAgICAgIG5ldyBVaW50OEFycmF5KGF3YWl0IHguYXJyYXlCdWZmZXIoKSlcbiAgICApLCBhd2FpdCBQLnJ1bihcIi1pXCIsIFksIEwpO1xuICAgIGNvbnN0IHRlID0gUC5GUyhcInJlYWRGaWxlXCIsIEwpO1xuICAgIHJldHVybiBuZXcgQmxvYihbdGUuYnVmZmVyXSwge1xuICAgICAgdHlwZTogYGF1ZGlvLyR7Q31gXG4gICAgfSk7XG4gIH0sIFIgPSBhc3luYyAoeCkgPT4ge1xuICAgICFjcm9zc09yaWdpbklzb2xhdGVkICYmIEMgIT09IFwid2VibVwiICYmIGNvbnNvbGUud2FybihcbiAgICAgICdUaGlzIHdlYnNpdGUgaXMgbm90IFwiY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkXCIuIEF1ZGlvIHdpbGwgYmUgZG93bmxvYWRlZCBpbiB3ZWJtIGZvcm1hdCwgc2luY2UgbXAzL3dhdiBlbmNvZGluZyByZXF1aXJlcyBjcm9zcyBvcmlnaW4gaXNvbGF0aW9uLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly93ZWIuZGV2L2Nyb3NzLW9yaWdpbi1pc29sYXRpb24tZ3VpZGUvIGFuZCBodHRwczovL3dlYi5kZXYvY29vcC1jb2VwLyBmb3IgaW5mb3JtYXRpb24gb24gaG93IHRvIG1ha2UgeW91ciB3ZWJzaXRlIFwiY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkXCInXG4gICAgKTtcbiAgICBjb25zdCBRID0gY3Jvc3NPcmlnaW5Jc29sYXRlZCA/IGF3YWl0IHAoeCkgOiB4LCBQID0gY3Jvc3NPcmlnaW5Jc29sYXRlZCA/IEMgOiBcIndlYm1cIiwgWSA9IFVSTC5jcmVhdGVPYmplY3RVUkwoUSksIEwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICBMLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIiwgTC5ocmVmID0gWSwgTC5kb3dubG9hZCA9IGBhdWRpby4ke1B9YCwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChMKSwgTC5jbGljaygpLCBMLnJlbW92ZSgpO1xuICB9O1xuICByZXR1cm4gY3IoKCkgPT4ge1xuICAgIChoIHx8IHopICYmIE0gIT0gbnVsbCAmJiBEICE9IG51bGwgJiYgKEQoTSksIEkgJiYgUihNKSk7XG4gIH0sIFtNXSksIC8qIEBfX1BVUkVfXyAqLyBOLmpzeHMoXG4gICAgXCJkaXZcIixcbiAgICB7XG4gICAgICBjbGFzc05hbWU6IGBhdWRpby1yZWNvcmRlciAke20gPyBcInJlY29yZGluZ1wiIDogXCJcIn0gJHsoaSA9PSBudWxsID8gdm9pZCAwIDogaS5BdWRpb1JlY29yZGVyQ2xhc3MpID8/IFwiXCJ9YCxcbiAgICAgIFwiZGF0YS10ZXN0aWRcIjogXCJhdWRpb19yZWNvcmRlclwiLFxuICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgLyogQF9fUFVSRV9fICovIE4uanN4KFxuICAgICAgICAgIFwiaW1nXCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3JjOiBtID8gd3IgOiB2cixcbiAgICAgICAgICAgIGNsYXNzTmFtZTogYGF1ZGlvLXJlY29yZGVyLW1pYyAkeyhpID09IG51bGwgPyB2b2lkIDAgOiBpLkF1ZGlvUmVjb3JkZXJTdGFydFNhdmVDbGFzcykgPz8gXCJcIn1gLFxuICAgICAgICAgICAgb25DbGljazogbSA/ICgpID0+IFYoKSA6IGMsXG4gICAgICAgICAgICBcImRhdGEtdGVzdGlkXCI6IFwiYXJfbWljXCIsXG4gICAgICAgICAgICB0aXRsZTogbSA/IFwiU2F2ZSByZWNvcmRpbmdcIiA6IFwiU3RhcnQgcmVjb3JkaW5nXCJcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBOLmpzeHMoXG4gICAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBgYXVkaW8tcmVjb3JkZXItdGltZXIgJHttID8gXCJcIiA6IFwiZGlzcGxheS1ub25lXCJ9ICR7KGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkuQXVkaW9SZWNvcmRlclRpbWVyQ2xhc3MpID8/IFwiXCJ9YCxcbiAgICAgICAgICAgIFwiZGF0YS10ZXN0aWRcIjogXCJhcl90aW1lclwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgTWF0aC5mbG9vcihBIC8gNjApLFxuICAgICAgICAgICAgICBcIjpcIixcbiAgICAgICAgICAgICAgU3RyaW5nKEEgJSA2MCkucGFkU3RhcnQoMiwgXCIwXCIpXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICB5ID8gLyogQF9fUFVSRV9fICovIE4uanN4KFxuICAgICAgICAgIFwic3BhblwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogYGF1ZGlvLXJlY29yZGVyLXZpc3VhbGl6ZXIgJHttID8gXCJcIiA6IFwiZGlzcGxheS1ub25lXCJ9YCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBPICYmIC8qIEBfX1BVUkVfXyAqLyBOLmpzeChsciwgeyBmYWxsYmFjazogLyogQF9fUFVSRV9fICovIE4uanN4KE4uRnJhZ21lbnQsIHt9KSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBOLmpzeChcbiAgICAgICAgICAgICAganIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZWRpYVJlY29yZGVyOiBPLFxuICAgICAgICAgICAgICAgIGJhcldpZHRoOiAyLFxuICAgICAgICAgICAgICAgIGdhcDogMixcbiAgICAgICAgICAgICAgICB3aWR0aDogMTQwLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMzAsXG4gICAgICAgICAgICAgICAgZmZ0U2l6ZTogNTEyLFxuICAgICAgICAgICAgICAgIG1heERlY2liZWxzOiAtMTAsXG4gICAgICAgICAgICAgICAgbWluRGVjaWJlbHM6IC04MCxcbiAgICAgICAgICAgICAgICBzbW9vdGhpbmdUaW1lQ29uc3RhbnQ6IDAuNFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApIH0pXG4gICAgICAgICAgfVxuICAgICAgICApIDogLyogQF9fUFVSRV9fICovIE4uanN4cyhcbiAgICAgICAgICBcInNwYW5cIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IGBhdWRpby1yZWNvcmRlci1zdGF0dXMgJHttID8gXCJcIiA6IFwiZGlzcGxheS1ub25lXCJ9ICR7KGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkuQXVkaW9SZWNvcmRlclN0YXR1c0NsYXNzKSA/PyBcIlwifWAsXG4gICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8gTi5qc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcImF1ZGlvLXJlY29yZGVyLXN0YXR1cy1kb3RcIiB9KSxcbiAgICAgICAgICAgICAgXCJSZWNvcmRpbmdcIlxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIE4uanN4KFxuICAgICAgICAgIFwiaW1nXCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3JjOiBfID8gbXIgOiBNcixcbiAgICAgICAgICAgIGNsYXNzTmFtZTogYGF1ZGlvLXJlY29yZGVyLW9wdGlvbnMgJHttID8gXCJcIiA6IFwiZGlzcGxheS1ub25lXCJ9ICR7KGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkuQXVkaW9SZWNvcmRlclBhdXNlUmVzdW1lQ2xhc3MpID8/IFwiXCJ9YCxcbiAgICAgICAgICAgIG9uQ2xpY2s6IHYsXG4gICAgICAgICAgICB0aXRsZTogXyA/IFwiUmVzdW1lIHJlY29yZGluZ1wiIDogXCJQYXVzZSByZWNvcmRpbmdcIixcbiAgICAgICAgICAgIFwiZGF0YS10ZXN0aWRcIjogXCJhcl9wYXVzZVwiXG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gTi5qc3goXG4gICAgICAgICAgXCJpbWdcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzcmM6IHlyLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBgYXVkaW8tcmVjb3JkZXItb3B0aW9ucyAke20gPyBcIlwiIDogXCJkaXNwbGF5LW5vbmVcIn0gJHsoaSA9PSBudWxsID8gdm9pZCAwIDogaS5BdWRpb1JlY29yZGVyRGlzY2FyZENsYXNzKSA/PyBcIlwifWAsXG4gICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBWKCExKSxcbiAgICAgICAgICAgIHRpdGxlOiBcIkRpc2NhcmQgUmVjb3JkaW5nXCIsXG4gICAgICAgICAgICBcImRhdGEtdGVzdGlkXCI6IFwiYXJfY2FuY2VsXCJcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIF1cbiAgICB9XG4gICk7XG59O1xuZXhwb3J0IHtcbiAgcHIgYXMgQXVkaW9SZWNvcmRlcixcbiAgZ3IgYXMgdXNlQXVkaW9SZWNvcmRlclxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-audio-voice-recorder@2.2.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-audio-voice-recorder/dist/react-audio-voice-recorder.es.js\n");

/***/ })

};
;